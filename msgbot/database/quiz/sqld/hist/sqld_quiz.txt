"1","모델링은 현실세계에 대해서 표현하는 것으로 이해할 수 있다. 다음 중 모델링의 특징으로 가장 부적절한 것은?","","3","1","애매모호함을 배제하고 누구나 이해가 가능하도록 정확하게 현상을 기술하는 정확화의 의미를 가짐"
"1","모델링은 현실세계에 대해서 표현하는 것으로 이해할 수 있다. 다음 중 모델링의 특징으로 가장 부적절한 것은?","","3","2","복잡한 현실을 제한된 언어나 표기법을 통해 이해하기 쉽게 하는 단순화의 의미를 가지고 있음"
"1","모델링은 현실세계에 대해서 표현하는 것으로 이해할 수 있다. 다음 중 모델링의 특징으로 가장 부적절한 것은?","","3","3","시스템 구현만을 위해 진행하는 사전단계의 작업으로서 데이터베이스 구축을 위한 사전작업의 의미가 있음"
"1","모델링은 현실세계에 대해서 표현하는 것으로 이해할 수 있다. 다음 중 모델링의 특징으로 가장 부적절한 것은?","","3","4","현실세계를 일정한 형식에 맞추어 표현하는 추상화의 의미를 가질 수 있음"
"4","다음 중 아래 설명이 의마하는 데이터모델링의 유의점에 해당히는 특성은 무엇인가?","데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중시킬 수 있다. 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.","3","1","일관성"
"4","다음 중 아래 설명이 의마하는 데이터모델링의 유의점에 해당히는 특성은 무엇인가?","데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중시킬 수 있다. 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.","3","2","비일관성"
"4","다음 중 아래 설명이 의마하는 데이터모델링의 유의점에 해당히는 특성은 무엇인가?","데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중시킬 수 있다. 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.","3","3","비유연성"
"4","다음 중 아래 설명이 의마하는 데이터모델링의 유의점에 해당히는 특성은 무엇인가?","데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중시킬 수 있다. 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.","3","4","중복"
"13","다음 중 엔터티의 이름을 부여하는 방법으로서 가장 부적절한 것은?","","4","1","엔터티가 생성되는 의미대로 자연스럽게 부여하도록 한다."
"13","다음 중 엔터티의 이름을 부여하는 방법으로서 가장 부적절한 것은?","","4","2","모든 엔터티에서 유일한 이름이 부여되어야 한다."
"13","다음 중 엔터티의 이름을 부여하는 방법으로서 가장 부적절한 것은?","","4","3","현업의 업무 용어를 사용하여 업무상의 의미를 분명하게 한다."
"13","다음 중 엔터티의 이름을 부여하는 방법으로서 가장 부적절한 것은?","","4","4","가능하면 약어를 사용하여 엔터티의 이름을 간결하고 명확하게 한다."
"14","다음 중 속성에 대한 설명으로 가장 부적절한 것은?","","2","1","속성도 집합이다."
"14","다음 중 속성에 대한 설명으로 가장 부적절한 것은?","","2","2","하나의 인스턴스에서 각각의 속성은 하나 이상의 속성값을 가질 수 있다."
"14","다음 중 속성에 대한 설명으로 가장 부적절한 것은?","","2","3","하나의 엔터티는 두 개 이상의 속성을 갖는다."
"14","다음 중 속성에 대한 설명으로 가장 부적절한 것은?","","2","4","엔터티에 대한 자세하고 구체적인 정보를 나타낸다."
"29","다음 중 비식별자 관계로 연결하는것을 고려해야 하는 경우로 가장 부적절한 것은?","","3","1","자식쪽 엔터티의 주식별자를 부모엔터티와는 별도로 생성하는 것이 더 유리하다고 판단하는 경우"
"29","다음 중 비식별자 관계로 연결하는것을 고려해야 하는 경우로 가장 부적절한 것은?","","3","2","여러 개의 엔터티를 하나로 통합하면서 각각의 엔터티가 갖고 있던 여러 개의 개별 관계가 통합되는 경우"
"29","다음 중 비식별자 관계로 연결하는것을 고려해야 하는 경우로 가장 부적절한 것은?","","3","3","부모엔터티의 인스턴스가 자식 엔터터와 같이 소멸되는 경우"
"29","다음 중 비식별자 관계로 연결하는것을 고려해야 하는 경우로 가장 부적절한 것은?","","3","4","부모엔터티에 참조값이 없어도 자식엔터티의 인스턴스가 생성될 수 있는 경우"
"32","다음 중 성능데이터 모델링을 할 때 고려사항으로 가장 부적절한 것은?","","4","1","이력데이터는 시간에 따라 반복적으로 발생이 되기 때문에 대량 데이터일 가능성이 높아 특별히 성능을 고려하여 칼럼 등을 추가하도록 설계해야 한다."
"32","다음 중 성능데이터 모델링을 할 때 고려사항으로 가장 부적절한 것은?","","4","2","물리적인 데이터 모델링을 할 때 PK/FK의 칼럼의 순서조정, FK인덱스 생성 등은 성능 향상을 위한 데이터 모델링 작업에 중요한 요소가 된다."
"32","다음 중 성능데이터 모델링을 할 때 고려사항으로 가장 부적절한 것은?","","4","3","용량산정은 전체적인 데이터베이스에 발생되는 트랜잭션의 유형과 양을 분석하는 자료가 되므로 성능데이터 모델링을 할 때 중요한 작업이 될 수 있다."
"32","다음 중 성능데이터 모델링을 할 때 고려사항으로 가장 부적절한 것은?","","4","4","데이터 모델링의 정규화는 항상 조회 성능저하를 나타내므로 반정규화 관점에서만 성능을 고려하여 설계하도록 한다."
"57","다음 중 아래와 같은 상황에서 사용할 수 있는 SQL 명령어는?","우리가 관리하는 데이터베이스의 ""매출"" 테이블이 너무나 많은 디스크 용량을 차지하여 ""매출” 테이블에서 필요한 데이터만을 추출하여 별도의 테이블로 옮겨 놓았다. 이후 ""매출"" 원본 테이블의 데이터를 모두 삭제함과 동시에, 디스크 사용량도 초기화 하고자 한다.(단, ""매출"" 테이블의 스키마 정의는 유지한다.)","4","1","DELETE TABLE FROM 매출;"
"57","다음 중 아래와 같은 상황에서 사용할 수 있는 SQL 명령어는?","우리가 관리하는 데이터베이스의 ""매출"" 테이블이 너무나 많은 디스크 용량을 차지하여 ""매출” 테이블에서 필요한 데이터만을 추출하여 별도의 테이블로 옮겨 놓았다. 이후 ""매출"" 원본 테이블의 데이터를 모두 삭제함과 동시에, 디스크 사용량도 초기화 하고자 한다.(단, ""매출"" 테이블의 스키마 정의는 유지한다.)","4","2","DROP TABLE 매출;"
"57","다음 중 아래와 같은 상황에서 사용할 수 있는 SQL 명령어는?","우리가 관리하는 데이터베이스의 ""매출"" 테이블이 너무나 많은 디스크 용량을 차지하여 ""매출” 테이블에서 필요한 데이터만을 추출하여 별도의 테이블로 옮겨 놓았다. 이후 ""매출"" 원본 테이블의 데이터를 모두 삭제함과 동시에, 디스크 사용량도 초기화 하고자 한다.(단, ""매출"" 테이블의 스키마 정의는 유지한다.)","4","3","DELETE FROM 매출;"
"57","다음 중 아래와 같은 상황에서 사용할 수 있는 SQL 명령어는?","우리가 관리하는 데이터베이스의 ""매출"" 테이블이 너무나 많은 디스크 용량을 차지하여 ""매출” 테이블에서 필요한 데이터만을 추출하여 별도의 테이블로 옮겨 놓았다. 이후 ""매출"" 원본 테이블의 데이터를 모두 삭제함과 동시에, 디스크 사용량도 초기화 하고자 한다.(단, ""매출"" 테이블의 스키마 정의는 유지한다.)","4","4","TRUNCATE TABLE 매출;"
"79","다음 중 오류가 발생하는 SQL 문장인 것은?","","1","1","SELECT 메뉴ID, 사용유형코드, AVG(COUNT(*)) AS AVGCNT
FROM 시스템사용이력
GROUP BY 메뉴ID, 사용유형코드;"
"79","다음 중 오류가 발생하는 SQL 문장인 것은?","","1","2","SELECT 메뉴ID, 사용유형코드, COUNT(*)  AS CNT
FROM 시스템사용이력
WHERE 사용일시 BETWEEN SYSDATE - 1 AND SYSDATE
GROUP BY 메뉴ID, 사용유형코드
HAVING 메뉴ID = 3 AND 사용유형코드 = 100；"
"79","다음 중 오류가 발생하는 SQL 문장인 것은?","","1","3","SELECT SUM(주문금액) AS 합계
FROM 주문
HAVING AVG(주문금액) > 100；"
"79","다음 중 오류가 발생하는 SQL 문장인 것은?","","1","4","SELECT 회원ID, SUM(주문금액) AS 합계
FROM 주문
GROUP BY 회원ID
HAVING COUNT(*) > 1；"
"90","다음 중 순수 관계 연산자에 해당하지 않는 것은?","","3","1","DIVIDE"
"90","다음 중 순수 관계 연산자에 해당하지 않는 것은?","","3","2","JOIN"
"90","다음 중 순수 관계 연산자에 해당하지 않는 것은?","","3","3","UPDATE"
"90","다음 중 순수 관계 연산자에 해당하지 않는 것은?","","3","4","SELECT"
"92","아래의 테이블 스키마 정보를 참고하여, 다음 중  '구매 이력이 있는 고객 중 구매 홧수가 3회 이상인 고객의 이름과 등급을 출력하시오'라는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 구문으로 가장 적절한 것은?","[테이블]
고객(고객번호(PK), 이름, 등급)
구매정보(구매 번호 (PK)，구매 금액, 고객 번호 (FK))
* 구매정보 테이블의 고객번호는 고객 테이블의 고객번호를 참조하는 외래키(Foreign Key)이다.
 [SQL 문장]
 SELECT A.이름 , A.등급
FROM 고객 A
(ㄱ) 
GROUP BY  A.이름 ,A.등급
(ㄴ)","3","1","(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호
(ㄴ) : WHERE B.구매번호〉=3"
"92","아래의 테이블 스키마 정보를 참고하여, 다음 중  '구매 이력이 있는 고객 중 구매 홧수가 3회 이상인 고객의 이름과 등급을 출력하시오'라는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 구문으로 가장 적절한 것은?","[테이블]
고객(고객번호(PK), 이름, 등급)
구매정보(구매 번호 (PK)，구매 금액, 고객 번호 (FK))
* 구매정보 테이블의 고객번호는 고객 테이블의 고객번호를 참조하는 외래키(Foreign Key)이다.
 [SQL 문장]
 SELECT A.이름 , A.등급
FROM 고객 A
(ㄱ) 
GROUP BY  A.이름 ,A.등급
(ㄴ)","3","2","(ㄱ) : LEFT OUTER JOIN 구매정보 B ON A.고객번호=B.고객번호
(ㄴ) : HAVING SUM(B.구매번호) >=3"
"92","아래의 테이블 스키마 정보를 참고하여, 다음 중  '구매 이력이 있는 고객 중 구매 홧수가 3회 이상인 고객의 이름과 등급을 출력하시오'라는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 구문으로 가장 적절한 것은?","[테이블]
고객(고객번호(PK), 이름, 등급)
구매정보(구매 번호 (PK)，구매 금액, 고객 번호 (FK))
* 구매정보 테이블의 고객번호는 고객 테이블의 고객번호를 참조하는 외래키(Foreign Key)이다.
 [SQL 문장]
 SELECT A.이름 , A.등급
FROM 고객 A
(ㄱ) 
GROUP BY  A.이름 ,A.등급
(ㄴ)","3","3","(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호
(ㄴ) : HAVING COUNT(B. 구매번호) >=3"
"92","아래의 테이블 스키마 정보를 참고하여, 다음 중  '구매 이력이 있는 고객 중 구매 홧수가 3회 이상인 고객의 이름과 등급을 출력하시오'라는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 구문으로 가장 적절한 것은?","[테이블]
고객(고객번호(PK), 이름, 등급)
구매정보(구매 번호 (PK)，구매 금액, 고객 번호 (FK))
* 구매정보 테이블의 고객번호는 고객 테이블의 고객번호를 참조하는 외래키(Foreign Key)이다.
 [SQL 문장]
 SELECT A.이름 , A.등급
FROM 고객 A
(ㄱ) 
GROUP BY  A.이름 ,A.등급
(ㄴ)","3","4","(ㄱ) : INNER JOIN 구매정보 B ON A.고객번호=B.고객번호
(ㄴ) : HAVING SUM(B. 구매번호)〉=3"
"108","다음 중 Oracle 계층형 질의에 대한 설명으로 가장 부적절한 것은?","","1","1","루트 노드의 LEVEL 값은 0이다."
"108","다음 중 Oracle 계층형 질의에 대한 설명으로 가장 부적절한 것은?","","1","2","순방향전개란 부모 노드로부터 자식 노드 방향으로 전개하는 것을 말한다."
"108","다음 중 Oracle 계층형 질의에 대한 설명으로 가장 부적절한 것은?","","1","3","ORDER SIBLINGS BY절은 형제 노드 사이에서 정렬을 지정하는 구문이다."
"108","다음 중 Oracle 계층형 질의에 대한 설명으로 가장 부적절한 것은?","","1","4","START WITH절은 계층 구조의 시작점을 지정하는 구문이다."
"134","다음 중 아래의 SQL에 대한 설명으로 가장 적절한 것은?","[SQL]
SELECT 상품분류코드
,AVG(상품가격) AS 상품가격
,COUNT(*) OVER(ORDER BY AVG(상품가격)
 RANGE BETWEEN 10000 PRECEDING
 AND 10000 FOLLOWING) AS 유사개수
FROM 상품
GROUP BY 상품분류코드;","2","1","유사개수 컬럼은 상품전체의 평균상품가격을 서로 비교하여 -10000 ~ +10000 사이에 존재하는 상품의 개수를 구한 것이다."
"134","다음 중 아래의 SQL에 대한 설명으로 가장 적절한 것은?","[SQL]
SELECT 상품분류코드
,AVG(상품가격) AS 상품가격
,COUNT(*) OVER(ORDER BY AVG(상품가격)
 RANGE BETWEEN 10000 PRECEDING
 AND 10000 FOLLOWING) AS 유사개수
FROM 상품
GROUP BY 상품분류코드;","2","2","유사개수 컬럼은 상품분류코드별 평균상품가격을 서로 비교하여 -10000 ~ +10000 사이에 존재하는 상품분류코드의 개수를 구한 것이다."
"134","다음 중 아래의 SQL에 대한 설명으로 가장 적절한 것은?","[SQL]
SELECT 상품분류코드
,AVG(상품가격) AS 상품가격
,COUNT(*) OVER(ORDER BY AVG(상품가격)
 RANGE BETWEEN 10000 PRECEDING
 AND 10000 FOLLOWING) AS 유사개수
FROM 상품
GROUP BY 상품분류코드;","2","3","WINDOW FUNCTION의 ORDER BY절에 AVG 집계 함수를 사용하였으므로 위의 SQL은 오류가 발생한다."
"134","다음 중 아래의 SQL에 대한 설명으로 가장 적절한 것은?","[SQL]
SELECT 상품분류코드
,AVG(상품가격) AS 상품가격
,COUNT(*) OVER(ORDER BY AVG(상품가격)
 RANGE BETWEEN 10000 PRECEDING
 AND 10000 FOLLOWING) AS 유사개수
FROM 상품
GROUP BY 상품분류코드;","2","4","WINDOW FUNCTION을 GROUP BY 절과 함께 사용하였으므로 위의 SQL은 오류가 발생한다."
"141","다음 중 절차형 SQL 모듈에 대한 설명으로 가장 부적절한 것은?","","1","1","데이터의 무결성과 일관성을 위해서 사용자 정의 함수를 사용한다.
"
"141","다음 중 절차형 SQL 모듈에 대한 설명으로 가장 부적절한 것은?","","1","2","트리거는 특정한 테이블에 INSERT, UPDATE, DELETE와 같은 DML문이 수행되었을 때 데이터베이스에서 자동으로 동작하도록 작성된 프로그램이다."
"141","다음 중 절차형 SQL 모듈에 대한 설명으로 가장 부적절한 것은?","","1","3","저장형 함수(사용자 정의 함수)는 단독적으로 실행되기 보다는 다른 SQL문을 통하여 호출되고 그 결과를 리턴하는 SQL의 보조적인 역할을 한다."
"141","다음 중 절차형 SQL 모듈에 대한 설명으로 가장 부적절한 것은?","","1","4","저장형 프로시져는 SQL을 로직과 함께 데이터베이스 내에 저장해 놓은 명령문의 집합을 의미한다.
"
"147","다음 설명이 나타내는 데이터 모델의 개념은 무엇인가?","","1","1","도메인"
"147","다음 설명이 나타내는 데이터 모델의 개념은 무엇인가?","","1","2","속성 사전"
"147","다음 설명이 나타내는 데이터 모델의 개념은 무엇인가?","","1","3","용어 사전"
"147","다음 설명이 나타내는 데이터 모델의 개념은 무엇인가?","","1","4","시스템 카탈로그"
"175","데이터를 입력하기 위해 사용하는 SQL 명령어는 무엇인가?","","3","1","ALTER"
"175","데이터를 입력하기 위해 사용하는 SQL 명령어는 무엇인가?","","3","2","UPDATE"
"175","데이터를 입력하기 위해 사용하는 SQL 명령어는 무엇인가?","","3","3","INSERT"
"175","데이터를 입력하기 위해 사용하는 SQL 명령어는 무엇인가?","","3","4","CREATE"
"177","다음 SQL 문장의 결과로 출력되는 데이터는 무엇인가?","SELECT PLAYER_NAME 선수명, E_PLAYER_NAME 선수영문명
FROM PLAYER
WHERE E_PLAYER_NMAE_LIKE '_A%';","4","1","위치에 상관없이 선수의 영문 이름에 A를 포함하는 선수들의 이름"
"177","다음 SQL 문장의 결과로 출력되는 데이터는 무엇인가?","SELECT PLAYER_NAME 선수명, E_PLAYER_NAME 선수영문명
FROM PLAYER
WHERE E_PLAYER_NMAE_LIKE '_A%';","4","2","선수의 영문 이름이 A로 시작하는 선수들의 이름"
"177","다음 SQL 문장의 결과로 출력되는 데이터는 무엇인가?","SELECT PLAYER_NAME 선수명, E_PLAYER_NAME 선수영문명
FROM PLAYER
WHERE E_PLAYER_NMAE_LIKE '_A%';","4","3","선수의 영문 이름이 A나 a로 시작하는 선수들의 이름"
"177","다음 SQL 문장의 결과로 출력되는 데이터는 무엇인가?","SELECT PLAYER_NAME 선수명, E_PLAYER_NAME 선수영문명
FROM PLAYER
WHERE E_PLAYER_NMAE_LIKE '_A%';","4","4","선수의 영문 이름의 두 번째 문자가 A인 선수들의 이름"
"178","어떠한 데이터 타입도 사용이 가능한 집계 함수는 어느 것인가?","","2","1","STDDEV"
"178","어떠한 데이터 타입도 사용이 가능한 집계 함수는 어느 것인가?","","2","2","COUNT"
"178","어떠한 데이터 타입도 사용이 가능한 집계 함수는 어느 것인가?","","2","3","SUM"
"178","어떠한 데이터 타입도 사용이 가능한 집계 함수는 어느 것인가?","","2","4","AVG"
"179","SQL 문장에서 집합별로 집계된 데이터에 대한 조회 조건을 제한하기 위해서 사용하는 절은 어느 것인가?","","4","1","FROM절"
"179","SQL 문장에서 집합별로 집계된 데이터에 대한 조회 조건을 제한하기 위해서 사용하는 절은 어느 것인가?","","4","2","WHERE절"
"179","SQL 문장에서 집합별로 집계된 데이터에 대한 조회 조건을 제한하기 위해서 사용하는 절은 어느 것인가?","","4","3","GROUP BY절"
"179","SQL 문장에서 집합별로 집계된 데이터에 대한 조회 조건을 제한하기 위해서 사용하는 절은 어느 것인가?","","4","4","HAVING절"
"185","다음 중 SELF JOIN을 수행해야 할 때는 어떤 경우인가?","","4","1","한 테이블 내에서 연관된 칼럼은 없으나 JOIN을 해야 한다."
"185","다음 중 SELF JOIN을 수행해야 할 때는 어떤 경우인가?","","4","2","두 테이블에 공통 칼럼이 존재하고 두 테이블이 연관 관계가 있다."
"185","다음 중 SELF JOIN을 수행해야 할 때는 어떤 경우인가?","","4","3","두 테이블에 연관된 칼럼은 없으나 JOIN을 해야 한다."
"185","다음 중 SELF JOIN을 수행해야 할 때는 어떤 경우인가?","","4","4","한 테이블 내에서 두 칼럼이 연관 관계가 있다."
"187","다음 서브쿼리에 대한 설명 중 틀린 것을 고르시오.","","4","1","다중행 연산자는 IN, ANY, ALL이 있으며 서브쿼리의 결과로 하나 이상의 데이터가 RETRUN되는 서브쿼리이다."
"187","다음 서브쿼리에 대한 설명 중 틀린 것을 고르시오.","","4","2","INLINE VIEW는 FROM절에 사용되는 서브쿼리로서 실질적인 OBJECT는 아니지만, SQL 문장에서 마치 VIEW나 테이블처럼 사용되는 서브쿼리이다."
"187","다음 서브쿼리에 대한 설명 중 틀린 것을 고르시오.","","4","3","TOP-N 서브쿼리는 INLINE VIEW의 정렬된 데이터를 ROWNUM을 이용해 결과 행 수를 제한하거나 TOP(N) 조건을 사용하는 서브쿼리이다."
"187","다음 서브쿼리에 대한 설명 중 틀린 것을 고르시오.","","4","4","상호연관 서브쿼리는 처리 속도가 가장 빠르기 때문에 최대한 활용하는 것이 좋다."
"291","다음 보기는 WINDOW 함수에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?","","2","1","SUM(급여) OVER
(PARTITION BY JOB ORDER BY JOB
RANGE BETWEEN
UNBOUNDED PRECEDING
AND CURRENT ROW) SAL"
"291","다음 보기는 WINDOW 함수에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?","","2","2","SUM(급여) OVER
(PARTITION BY JOB ORDER BY EMPNO
RANGE BETWEEN
UNBOUNDED PRECEDING
AND UNBOUNDED PRECEDING) SAL"
"291","다음 보기는 WINDOW 함수에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?","","2","3","SUM(급여) OVER
(PARTITION BY JOB ORDER BY EMPNO
RANGE BETWEEN
UNBOUNDED PRECEDING
AND UNBOUNDED FOLLOWING) SAL"
"291","다음 보기는 WINDOW 함수에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?","","2","4","SUM(급여) OVER()"
"296","다음의 Mytest 테이블에 데이터를 입력 시 에러가 발생하는 것은?","Create table Mytest
(
A number(10)  primary key,
B number(10),
C date,
D varchar2(10)
);","1","1","INSERT into Mytest values(4,32,20220420,'004')"
"296","다음의 Mytest 테이블에 데이터를 입력 시 에러가 발생하는 것은?","Create table Mytest
(
A number(10)  primary key,
B number(10),
C date,
D varchar2(10)
);","1","2","INSERT into Mytest values(3,200,sysdate-10,'004')"
"296","다음의 Mytest 테이블에 데이터를 입력 시 에러가 발생하는 것은?","Create table Mytest
(
A number(10)  primary key,
B number(10),
C date,
D varchar2(10)
);","1","3","INSERT into Mytest values(2,1111,to_date('20230101','YYYYMMDD'),'003')"
"296","다음의 Mytest 테이블에 데이터를 입력 시 에러가 발생하는 것은?","Create table Mytest
(
A number(10)  primary key,
B number(10),
C date,
D varchar2(10)
);","1","4","INSERT into Mytest values(1,12,sysdate,002)"
"308","다음 SQL의 실행 결과는?","SELECT ROUND(10.51234, 1) FROM DUAL;","3","1","11"
"308","다음 SQL의 실행 결과는?","SELECT ROUND(10.51234, 1) FROM DUAL;","3","2","10.51"
"308","다음 SQL의 실행 결과는?","SELECT ROUND(10.51234, 1) FROM DUAL;","3","3","10.5"
"308","다음 SQL의 실행 결과는?","SELECT ROUND(10.51234, 1) FROM DUAL;","3","4","10"
"310","다음에서 설명하고 있는 식별자는?","데이터베이스 키는 생성 여부에 따라 (A) 식별자와 (B)식별자로 분류된다. (A) 식별자는 엔터티 스스로 생성되는 식별자이고 (B)식별자는 다른 엔터티 간의 관계에 의해서 만들어지는 식별자이다.","2","1","A : 인조 식별자, B : 본질 식별자"
"310","다음에서 설명하고 있는 식별자는?","데이터베이스 키는 생성 여부에 따라 (A) 식별자와 (B)식별자로 분류된다. (A) 식별자는 엔터티 스스로 생성되는 식별자이고 (B)식별자는 다른 엔터티 간의 관계에 의해서 만들어지는 식별자이다.","2","2","A : 내부 식별자, B : 외부 식별자"
"310","다음에서 설명하고 있는 식별자는?","데이터베이스 키는 생성 여부에 따라 (A) 식별자와 (B)식별자로 분류된다. (A) 식별자는 엔터티 스스로 생성되는 식별자이고 (B)식별자는 다른 엔터티 간의 관계에 의해서 만들어지는 식별자이다.","2","3","A : 외부 식별자, B : 내부 식별자"
"310","다음에서 설명하고 있는 식별자는?","데이터베이스 키는 생성 여부에 따라 (A) 식별자와 (B)식별자로 분류된다. (A) 식별자는 엔터티 스스로 생성되는 식별자이고 (B)식별자는 다른 엔터티 간의 관계에 의해서 만들어지는 식별자이다.","2","4","A : 기본키, B : 대체키"
"312","다음은 데이터베이스 파티션 기법에 대한 설명이다. 보기에서 설명하고 있는 파티션 기법은 무엇인가?","-파티셔닝 할 항목을 관리자가 직접 지정하는 방법으로 제품에 대해서 파티션을 생성하였다.
-데이터 보관 주기에 따라서 쉽게 데이터를 삭제할 수 없다.","2","1","HYBRID PARTITION"
"312","다음은 데이터베이스 파티션 기법에 대한 설명이다. 보기에서 설명하고 있는 파티션 기법은 무엇인가?","-파티셔닝 할 항목을 관리자가 직접 지정하는 방법으로 제품에 대해서 파티션을 생성하였다.
-데이터 보관 주기에 따라서 쉽게 데이터를 삭제할 수 없다.","2","2","LIST PARTITION"
"312","다음은 데이터베이스 파티션 기법에 대한 설명이다. 보기에서 설명하고 있는 파티션 기법은 무엇인가?","-파티셔닝 할 항목을 관리자가 직접 지정하는 방법으로 제품에 대해서 파티션을 생성하였다.
-데이터 보관 주기에 따라서 쉽게 데이터를 삭제할 수 없다.","2","3","HASH PARTITON"
"312","다음은 데이터베이스 파티션 기법에 대한 설명이다. 보기에서 설명하고 있는 파티션 기법은 무엇인가?","-파티셔닝 할 항목을 관리자가 직접 지정하는 방법으로 제품에 대해서 파티션을 생성하였다.
-데이터 보관 주기에 따라서 쉽게 데이터를 삭제할 수 없다.","2","4","RANGE PARTITION"
"360","다음은 도메인에 대한 설명이다. 특징으로 알맞지 않은 것은?","","2","1","속성을 명사로 분리한다."
"360","다음은 도메인에 대한 설명이다. 특징으로 알맞지 않은 것은?","","2","2","공통으로 발생하는 명사는 여러 개의 도메인으로 생성한다."
"360","다음은 도메인에 대한 설명이다. 특징으로 알맞지 않은 것은?","","2","3","각 엔터티 속성에 도메인을 할당한다."
"360","다음은 도메인에 대한 설명이다. 특징으로 알맞지 않은 것은?","","2","4","도메인별로 데이터 타입과 길이를 지정한다."
"363","아래 시나리오에서 엔터티로 가장 적절한 것은?","A 쇼핑몰에서 상품을 주문하려면 회원에 가입해야 한다. 회원가입 시에는 회원ID, 이름, 전화번호를 입력하고 주문을 할 때는 배송지 주소를 입력해야 한다.","3","1","배송지 주소"
"363","아래 시나리오에서 엔터티로 가장 적절한 것은?","A 쇼핑몰에서 상품을 주문하려면 회원에 가입해야 한다. 회원가입 시에는 회원ID, 이름, 전화번호를 입력하고 주문을 할 때는 배송지 주소를 입력해야 한다.","3","2","A 쇼핑몰"
"363","아래 시나리오에서 엔터티로 가장 적절한 것은?","A 쇼핑몰에서 상품을 주문하려면 회원에 가입해야 한다. 회원가입 시에는 회원ID, 이름, 전화번호를 입력하고 주문을 할 때는 배송지 주소를 입력해야 한다.","3","3","회원"
"363","아래 시나리오에서 엔터티로 가장 적절한 것은?","A 쇼핑몰에서 상품을 주문하려면 회원에 가입해야 한다. 회원가입 시에는 회원ID, 이름, 전화번호를 입력하고 주문을 할 때는 배송지 주소를 입력해야 한다.","3","4","이름"
"383","다음의 SQL문을 수행하였을 때의 결과로 알맞은 것은?","CREATE TABLE MYTEST (N1 NUMBER(10), N2 NUMBER(10));
INSERT INTO MyTEST VALUES (100, 200);
INSERT INTO MyTEST VALUES (200, 300);
SAVEPOINT T1;
UPDATE MYTEST SET N1=300 WHERE N2=200;
SAVEPOINT T1;
DELETE MYTEST WHERE N1>=200;
ROLLBACK TO SAVEPOINT T1;
SELECT MAX(N1) FROM MYTEST;","3","1","200"
"383","다음의 SQL문을 수행하였을 때의 결과로 알맞은 것은?","CREATE TABLE MYTEST (N1 NUMBER(10), N2 NUMBER(10));
INSERT INTO MyTEST VALUES (100, 200);
INSERT INTO MyTEST VALUES (200, 300);
SAVEPOINT T1;
UPDATE MYTEST SET N1=300 WHERE N2=200;
SAVEPOINT T1;
DELETE MYTEST WHERE N1>=200;
ROLLBACK TO SAVEPOINT T1;
SELECT MAX(N1) FROM MYTEST;","3","2","100"
"383","다음의 SQL문을 수행하였을 때의 결과로 알맞은 것은?","CREATE TABLE MYTEST (N1 NUMBER(10), N2 NUMBER(10));
INSERT INTO MyTEST VALUES (100, 200);
INSERT INTO MyTEST VALUES (200, 300);
SAVEPOINT T1;
UPDATE MYTEST SET N1=300 WHERE N2=200;
SAVEPOINT T1;
DELETE MYTEST WHERE N1>=200;
ROLLBACK TO SAVEPOINT T1;
SELECT MAX(N1) FROM MYTEST;","3","3","300"
"383","다음의 SQL문을 수행하였을 때의 결과로 알맞은 것은?","CREATE TABLE MYTEST (N1 NUMBER(10), N2 NUMBER(10));
INSERT INTO MyTEST VALUES (100, 200);
INSERT INTO MyTEST VALUES (200, 300);
SAVEPOINT T1;
UPDATE MYTEST SET N1=300 WHERE N2=200;
SAVEPOINT T1;
DELETE MYTEST WHERE N1>=200;
ROLLBACK TO SAVEPOINT T1;
SELECT MAX(N1) FROM MYTEST;","3","4","NULL"
"385","다음의 SQL문과 동일한 결괏값을 보여주는 SQL문은?","SELECT * FROM Mytesta a full outer join Mytestb b
on a.col1 = b.col1;","1","1","SELECT * FROM Mytesta a left
outer join Mytestb b
on a.col1 = b.col1
union
SELECT * FROM Mytesta a right
outer join Mytestb b
on a.col1 = b.col1;"
"385","다음의 SQL문과 동일한 결괏값을 보여주는 SQL문은?","SELECT * FROM Mytesta a full outer join Mytestb b
on a.col1 = b.col1;","1","2","SELECT * FROM Mytesta a cross
 join Mytestb b
on a.col1 = b.col1"
"385","다음의 SQL문과 동일한 결괏값을 보여주는 SQL문은?","SELECT * FROM Mytesta a full outer join Mytestb b
on a.col1 = b.col1;","1","3","SELECT * FROM Mytesta a left
outer join Mytestb b
on a.col1 = b.col1
union all
SELECT * FROM Mytesta a left
outer join Mytestb b
on a.col1 = b.col1;"
"385","다음의 SQL문과 동일한 결괏값을 보여주는 SQL문은?","SELECT * FROM Mytesta a full outer join Mytestb b
on a.col1 = b.col1;","1","4","SELECT * FROM Mytesta group by col1;"
"420","다음 중 데이터베이스 무결성을 확보하기 위한 방안으로 가장 올바르지 않은 것은?","","2","1","애플리케이션에서 무결성 검사 로직을 추가한다."
"420","다음 중 데이터베이스 무결성을 확보하기 위한 방안으로 가장 올바르지 않은 것은?","","2","2","lock"
"420","다음 중 데이터베이스 무결성을 확보하기 위한 방안으로 가장 올바르지 않은 것은?","","2","3","트리거"
"420","다음 중 데이터베이스 무결성을 확보하기 위한 방안으로 가장 올바르지 않은 것은?","","2","4","제약조건"
"443","다음은 데이터베이스 모델링에 대한 설명으로 가장 올바른 것은?","증권회사에서 주문을 발주할 때 해당 종목에
대한 호가단위가 있다. 즉, 주문은 10호가를 기준으로
발주할 수가 있어서 어떤 종목을 주문할 때 1003원과 같은
금액으로는 발주할 수 없다. 이처럼 데이터베이스에서 값이 가질
수 있는 조건을 정의하는 것이다.","1","1","도메인"
"443","다음은 데이터베이스 모델링에 대한 설명으로 가장 올바른 것은?","증권회사에서 주문을 발주할 때 해당 종목에
대한 호가단위가 있다. 즉, 주문은 10호가를 기준으로
발주할 수가 있어서 어떤 종목을 주문할 때 1003원과 같은
금액으로는 발주할 수 없다. 이처럼 데이터베이스에서 값이 가질
수 있는 조건을 정의하는 것이다.","1","2","선텍도"
"443","다음은 데이터베이스 모델링에 대한 설명으로 가장 올바른 것은?","증권회사에서 주문을 발주할 때 해당 종목에
대한 호가단위가 있다. 즉, 주문은 10호가를 기준으로
발주할 수가 있어서 어떤 종목을 주문할 때 1003원과 같은
금액으로는 발주할 수 없다. 이처럼 데이터베이스에서 값이 가질
수 있는 조건을 정의하는 것이다.","1","3","다중 값 속성"
"443","다음은 데이터베이스 모델링에 대한 설명으로 가장 올바른 것은?","증권회사에서 주문을 발주할 때 해당 종목에
대한 호가단위가 있다. 즉, 주문은 10호가를 기준으로
발주할 수가 있어서 어떤 종목을 주문할 때 1003원과 같은
금액으로는 발주할 수 없다. 이처럼 데이터베이스에서 값이 가질
수 있는 조건을 정의하는 것이다.","1","4","시스템 카탈로그"
"454","순위 함수에 대한 설명 중 틀린 것은 무엇인가?","","1","1","순위 함수 사용 시 ORDER BY절은 입력하지 않아도 된다."
"454","순위 함수에 대한 설명 중 틀린 것은 무엇인가?","","1","2","ROW_NUMBER 함수는 특정 동일 순위가 부여되지 않는다."
"454","순위 함수에 대한 설명 중 틀린 것은 무엇인가?","","1","3","DENSE_RANK 함수는 RANK 함수와 같은 역할을 하지만 동일 등수 순위에 영향이 없다."
"454","순위 함수에 대한 설명 중 틀린 것은 무엇인가?","","1","4","RANK 함수는 동일순위 처리가 가능하다."
"490","아래의 내용은 주식별자의 어떤 특징을 설명한 것인가?","학생의 학번으로 고유한 구조를 표현할 수가 있다.하지만 ABC대학교의 학생 엔터티의 주식별자를 학번과 입학일자로 해서 잘못된 모델링을 했다.","3","1","존재성"
"490","아래의 내용은 주식별자의 어떤 특징을 설명한 것인가?","학생의 학번으로 고유한 구조를 표현할 수가 있다.하지만 ABC대학교의 학생 엔터티의 주식별자를 학번과 입학일자로 해서 잘못된 모델링을 했다.","3","2","불변성"
"490","아래의 내용은 주식별자의 어떤 특징을 설명한 것인가?","학생의 학번으로 고유한 구조를 표현할 수가 있다.하지만 ABC대학교의 학생 엔터티의 주식별자를 학번과 입학일자로 해서 잘못된 모델링을 했다.","3","3","최소성"
"490","아래의 내용은 주식별자의 어떤 특징을 설명한 것인가?","학생의 학번으로 고유한 구조를 표현할 수가 있다.하지만 ABC대학교의 학생 엔터티의 주식별자를 학번과 입학일자로 해서 잘못된 모델링을 했다.","3","4","유일성"
"516","다음 중 순수 관계 연산자에 해당하지 않는 것은?","","3","1","DIVIDE"
"516","다음 중 순수 관계 연산자에 해당하지 않는 것은?","","3","2","JOIN"
"516","다음 중 순수 관계 연산자에 해당하지 않는 것은?","","3","3","DELETE"
"516","다음 중 순수 관계 연산자에 해당하지 않는 것은?","","3","4","SELECT"
"560","테이블을 생성할 수 있는 권한을 부여하는 SQL문을 완성하시오.","(      ) CREATE TABLE TO LIMBEST;","3","1","ROLLBACK"
"560","테이블을 생성할 수 있는 권한을 부여하는 SQL문을 완성하시오.","(      ) CREATE TABLE TO LIMBEST;","3","2","COMMIT"
"560","테이블을 생성할 수 있는 권한을 부여하는 SQL문을 완성하시오.","(      ) CREATE TABLE TO LIMBEST;","3","3","GRANT"
"560","테이블을 생성할 수 있는 권한을 부여하는 SQL문을 완성하시오.","(      ) CREATE TABLE TO LIMBEST;","3","4","REVOKE"
"568","테이블명 생성시 주의사항으로 틀린 것을 고르시오.","","4","1","객체를 의미할 수 있는 적절한 이름을 사용한다."
"568","테이블명 생성시 주의사항으로 틀린 것을 고르시오.","","4","2","가능한 단수형을 사용한다."
"568","테이블명 생성시 주의사항으로 틀린 것을 고르시오.","","4","3","테이블명과 칼럼명은 반드시 문자로 시작해야 한다."
"568","테이블명 생성시 주의사항으로 틀린 것을 고르시오.","","4","4","예약어를 사용할 수 있다. "
"579","NULL에 대한 설명으로 가장 적절하지 않은 것은?","","2","1","공백문자 혹은 숫자 0과는 다른 의미를 갖는다."
"579","NULL에 대한 설명으로 가장 적절하지 않은 것은?","","2","2","NULL로만 구성된 컬럼을 COUNT한 결과는 공집합이다."
"579","NULL에 대한 설명으로 가장 적절하지 않은 것은?","","2","3","NULL과의 모든 비교(IS NULL 제외)는 알 수 없음을 반환한다."
"579","NULL에 대한 설명으로 가장 적절하지 않은 것은?","","2","4","정해지지 않은 값을 의미한다."
"590","다음 SQL 중 실행 결과가 다른 것은? ","","4","1","SELECT JOB, NVL(SUM(CASE WHEN DEPTNO = 10 THEN 1 END),0) AS ""10번부서원수"", NVL(SUM(CASE WHEN DEPTNO = 20 THEN 1 END),0) AS ""20번부서원수"", NVL(SUM(CASE WHEN DEPTNO = 30 THEN 1 END),0) AS ""30번부서원수"" FROM EMP GROUP BY JOB;"
"590","다음 SQL 중 실행 결과가 다른 것은? ","","4","2","SELECT JOB, SUM(CASE WHEN DEPTNO = 10 THEN 1 ELSE 0 END) AS ""10번부서원수"", SUM(CASE WHEN DEPTNO = 20 THEN 1 ELSE 0 END) AS ""20번부서원수"", SUM(CASE WHEN DEPTNO = 30 THEN 1 ELSE 0 END) AS ""30번부서원수"" FROM EMP GROUP BY JOB;"
"590","다음 SQL 중 실행 결과가 다른 것은? ","","4","3","SELECT JOB, COUNT(CASE WHEN DEPTNO = 10 THEN 1 END) AS ""10번부서원수"", COUNT(CASE WHEN DEPTNO = 20 THEN 1 END) AS ""20번부서원수"", COUNT(CASE WHEN DEPTNO = 30 THEN 1 END) AS ""30번부서원수"" FROM EMP GROUP BY JOB;"
"590","다음 SQL 중 실행 결과가 다른 것은? ","","4","4","SELECT JOB, COUNT(CASE WHEN DEPTNO = 10 THEN 1 ELSE 0 END) AS ""10번부서원수"", COUNT(CASE WHEN DEPTNO = 20 THEN 1 ELSE 0 END) AS ""20번부서원수"", COUNT(CASE WHEN DEPTNO = 30 THEN 1 ELSE 0 END) AS ""30번부서원수"" FROM EMP GROUP BY JOB;"
"592","다음 SQL 문장 중 실행 결과가 다른 하나는? ","","3","1","SELECT COUNT(*) FROM EMP WHERE (DEPTNO = 10 OR DEPTNO = 20 AND JOB = 'CLERK') ;"
"592","다음 SQL 문장 중 실행 결과가 다른 하나는? ","","3","2","SELECT COUNT(*) FROM EMP WHERE DEPTNO = 10 OR (DEPTNO = 20 AND JOB = 'CLERK'); "
"592","다음 SQL 문장 중 실행 결과가 다른 하나는? ","","3","3","SELECT COUNT(*) FROM EMP WHERE (DEPTNO = 10 OR DEPTNO = 20) AND JOB = 'CLERK';"
"592","다음 SQL 문장 중 실행 결과가 다른 하나는? ","","3","4","SELECT COUNT(*) FROM EMP WHERE DEPTNO = 10 OR DEPTNO = 20 AND JOB = 'CLERK';"
"622","엔터티 분류 중 발생시점에 따른 분류가 아닌 것은? ","","2","1","행위엔터티"
"622","엔터티 분류 중 발생시점에 따른 분류가 아닌 것은? ","","2","2","사건엔터티"
"622","엔터티 분류 중 발생시점에 따른 분류가 아닌 것은? ","","2","3","중심엔터티"
"622","엔터티 분류 중 발생시점에 따른 분류가 아닌 것은? ","","2","4","기본엔터티"
"629","NULL에 대한 설명으로 가장 적절하지 않은 것은? ","","1","1","바커 표기법에서는 속성 앞에 별(*)을 사용하여 널 허용 속성을 표현한다."
"629","NULL에 대한 설명으로 가장 적절하지 않은 것은? ","","1","2","IE 표기법에서는 각 컬럼별 NULL 허용 여부를 알 수 없다."
"629","NULL에 대한 설명으로 가장 적절하지 않은 것은? ","","1","3","논리모델 설계 시 각 컬럼별로 NULL을 허용할 지를 결정한다."
"629","NULL에 대한 설명으로 가장 적절하지 않은 것은? ","","1","4","정해지지 않은 값을 의미한다."
"630","본질식별자와 인조식별자에 대한 설명으로 가장 적절하지 않은 것은? ","","2","1","자동으로 증가하는 일련번호 같은 형태는 인조식별자에 해당한다."
"630","본질식별자와 인조식별자에 대한 설명으로 가장 적절하지 않은 것은? ","","2","2","인조식별자는 대체로 본질식별자가 복잡한 구성을 가질 때 만들어진다."
"630","본질식별자와 인조식별자에 대한 설명으로 가장 적절하지 않은 것은? ","","2","3","인조식별자를 사용하면 본질식별자를 사용할 때와 비교하여 추가적인 인덱스가 필요해진다."
"630","본질식별자와 인조식별자에 대한 설명으로 가장 적절하지 않은 것은? ","","2","4","인조식별자를 사용하면 불필요하게 발생하는 중복데이터를 막을 수 있다."
"652","서브쿼리 설명으로 가장 적절한 것은?","","3","1","서브 쿼리는 항상 메인쿼리에서 읽힌 데이터에 대해 서브쿼리에서 해당 조건이 만족하는지를 확인하는 방식으로 수행된다."
"652","서브쿼리 설명으로 가장 적절한 것은?","","3","2","연관 서브쿼리는 주로 메인쿼리에 값을 제공하기 위한 목적으로 사용한다."
"652","서브쿼리 설명으로 가장 적절한 것은?","","3","3","다중 행 서브쿼리 비교 연산자는 단일 행 서브쿼리의 비교 연산자로도 사용할 수 있다."
"652","서브쿼리 설명으로 가장 적절한 것은?","","3","4","단일 행 서브쿼리는 서브쿼리의 실행 결과가 항상 한 건 이하인 서브쿼리로 IN, ALL 등의 비교 연산자를 사용 하여야 한다."
"664","다음 SQL 실행 결과로 가장 알맞은 것은?","SELECT REGEXP_SUBSTR('ORA-00600 Oracle SQL-Server 50', '[^0-9]+') ""REGEXPR_SUBSTR"" 
FROM DUAL; ","2","1","ORA- Oracle SQL-Server"
"664","다음 SQL 실행 결과로 가장 알맞은 것은?","SELECT REGEXP_SUBSTR('ORA-00600 Oracle SQL-Server 50', '[^0-9]+') ""REGEXPR_SUBSTR"" 
FROM DUAL; ","2","2","ORA-"
"664","다음 SQL 실행 결과로 가장 알맞은 것은?","SELECT REGEXP_SUBSTR('ORA-00600 Oracle SQL-Server 50', '[^0-9]+') ""REGEXPR_SUBSTR"" 
FROM DUAL; ","2","3","00600 50"
"664","다음 SQL 실행 결과로 가장 알맞은 것은?","SELECT REGEXP_SUBSTR('ORA-00600 Oracle SQL-Server 50', '[^0-9]+') ""REGEXPR_SUBSTR"" 
FROM DUAL; ","2","4","50"
"669","제약조건에 대한 설명 중 가장 적절하지 않은 것은?","","3","1","FOREIGN KEY는 부모-자식 관계 중 자식 테이블에 생성한다."
"669","제약조건에 대한 설명 중 가장 적절하지 않은 것은?","","3","2","CREATE TABLE AS SELECT문으로 테이블 복제 시 NOT NULL속성은 복제된다."
"669","제약조건에 대한 설명 중 가장 적절하지 않은 것은?","","3","3","UNIQUE 제약조건에는 NULL값을 허용하지 않는다."
"669","제약조건에 대한 설명 중 가장 적절하지 않은 것은?","","3","4","PRIMARY KEY는 여러 컬럼으로 구성하여 생성할 수 있다."
"698","다음 중 SELECT절에 사용하는 서브쿼리인 스칼라 서브쿼리에 대한 설명으로 가장 적절하지 않은 것은?","","3","1","메인쿼리와 스칼라 서브쿼리의 연결 조건이 필요하다면 반드시 스칼라 서브쿼리에 정의해야 한다."
"698","다음 중 SELECT절에 사용하는 서브쿼리인 스칼라 서브쿼리에 대한 설명으로 가장 적절하지 않은 것은?","","3","2","스칼라 서브쿼리는 반드시 한 컬럼만 출력이 가능하다."
"698","다음 중 SELECT절에 사용하는 서브쿼리인 스칼라 서브쿼리에 대한 설명으로 가장 적절하지 않은 것은?","","3","3","하나의 로우에 해당하는 스칼라 서브쿼리 결과가 0건이면 생략된다."
"698","다음 중 SELECT절에 사용하는 서브쿼리인 스칼라 서브쿼리에 대한 설명으로 가장 적절하지 않은 것은?","","3","4","하나의 로우에 해당하는 스칼라 서브쿼리 결과 건수는 1건 이하여야 한다."
"717","아래와 같이 테이블 및 데이터가 생성된 경우 추가 실행이 불가능한 문장은?  ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
INSERT INTO TAB1 VALUES(100, 100); 
COMMIT; ","3","1","ALTER TABLE TAB1 DROP COLUMN COL4;"
"717","아래와 같이 테이블 및 데이터가 생성된 경우 추가 실행이 불가능한 문장은?  ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
INSERT INTO TAB1 VALUES(100, 100); 
COMMIT; ","3","2","ALTER TABLE TAB1 MODIFY COL2 DEFAULT 100 NOT NULL;"
"717","아래와 같이 테이블 및 데이터가 생성된 경우 추가 실행이 불가능한 문장은?  ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
INSERT INTO TAB1 VALUES(100, 100); 
COMMIT; ","3","3","ALTER TABLE TAB1 ADD COL5 NUMBER NOT NULL;"
"717","아래와 같이 테이블 및 데이터가 생성된 경우 추가 실행이 불가능한 문장은?  ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
INSERT INTO TAB1 VALUES(100, 100); 
COMMIT; ","3","4","ALTER TABLE TAB1 ADD (COL3 NUMBER, COL4 VARCHAR2(10));"
"729","NULL에 대한 설명으로 틀린 것은?","","2","1","NULL과의 비교 연산은 FALSE를 리턴한다."
"729","NULL에 대한 설명으로 틀린 것은?","","2","2","NULL이 포함된 컬럼의 SUM 값은 항상 NULL이다."
"729","NULL에 대한 설명으로 틀린 것은?","","2","3","NULL + 100은 NULL을 리턴한다."
"729","NULL에 대한 설명으로 틀린 것은?","","2","4","COUNT는 NULL을 세지 않는다."
"756","MIN 함수와 동일하게 사용할 수 있는 WINDOW 함수는?","","1","1","FIRST_VALUE"
"756","MIN 함수와 동일하게 사용할 수 있는 WINDOW 함수는?","","1","2","LEAD"
"756","MIN 함수와 동일하게 사용할 수 있는 WINDOW 함수는?","","1","3","RATIO_TO_REPORT"
"756","MIN 함수와 동일하게 사용할 수 있는 WINDOW 함수는?","","1","4","LAG"
"768","테이블 복제에 대한 설명 중 가장 적절하지 않은 것은?","","2","1","PRIMARY KEY 나 UNIQUE 설정 없이 부여된 NOT NULL 속성은 함께 복제된다."
"768","테이블 복제에 대한 설명 중 가장 적절하지 않은 것은?","","2","2","테이블에 생성한 PRIMARY KEY 도 함께 복제된다."
"768","테이블 복제에 대한 설명 중 가장 적절하지 않은 것은?","","2","3","테이블 복제 시 컬럼 순서 및 데이터 유형도 복제된다."
"768","테이블 복제에 대한 설명 중 가장 적절하지 않은 것은?","","2","4","CREATE TABLE 테이블명 AS SELECT 문으로 테이블 복제가 가능하다."
"776","다음 정규화에 대한 설명으로 가장 적절한 것은?","이행적 종속을 없애도록 테이블을 분리하는 단계","2","1","제4정규화"
"776","다음 정규화에 대한 설명으로 가장 적절한 것은?","이행적 종속을 없애도록 테이블을 분리하는 단계","2","2","제3정규화"
"776","다음 정규화에 대한 설명으로 가장 적절한 것은?","이행적 종속을 없애도록 테이블을 분리하는 단계","2","3","제2정규화"
"776","다음 정규화에 대한 설명으로 가장 적절한 것은?","이행적 종속을 없애도록 테이블을 분리하는 단계","2","4","제1정규화"
"788","다음 함수의 결과가 다른 것은?","","2","1","ISNULL(COMM, 100)"
"788","다음 함수의 결과가 다른 것은?","","2","2","NULLIF(COMM, 100)"
"788","다음 함수의 결과가 다른 것은?","","2","3","NVL2(COMM, COMM, 100)"
"788","다음 함수의 결과가 다른 것은?","","2","4","NVL(COMM, 100)"
"800","다음 중 순수 관계 연산자로 적절하지 않은 것은?","","1","1","PRODUCT"
"800","다음 중 순수 관계 연산자로 적절하지 않은 것은?","","1","2","JOIN"
"800","다음 중 순수 관계 연산자로 적절하지 않은 것은?","","1","3","DIVISION"
"800","다음 중 순수 관계 연산자로 적절하지 않은 것은?","","1","4","SELECT"
"239","다음 SQL문의 결과로 출력되는 데이터는 무엇인가?","SELECT NEXT_DAY
(ADD_MONTHS(sysdate,6),'월요일)
FROM dual;","2","1","오늘 날짜로부터 6일 후 두 번째 월요일을 출력한다."
"239","다음 SQL문의 결과로 출력되는 데이터는 무엇인가?","SELECT NEXT_DAY
(ADD_MONTHS(sysdate,6),'월요일)
FROM dual;","2","2","오늘 날짜로부터 6개월 후 첫 번째 월요일을 출력한다."
"239","다음 SQL문의 결과로 출력되는 데이터는 무엇인가?","SELECT NEXT_DAY
(ADD_MONTHS(sysdate,6),'월요일)
FROM dual;","2","3","오늘 날짜로부터 6개월 후 두 번째 월요일을 출력한다."
"239","다음 SQL문의 결과로 출력되는 데이터는 무엇인가?","SELECT NEXT_DAY
(ADD_MONTHS(sysdate,6),'월요일)
FROM dual;","2","4","오늘 날짜로부터 6일 후 첫 번째 월요일을 출력한다."
"255","다음의 SQL문을 사용할 때, 날짜형 변수를 문자형으로 바꿀 수 있는 것은?","SELECT SYSDATE FROM DUAL;","2","1","CONVERT"
"255","다음의 SQL문을 사용할 때, 날짜형 변수를 문자형으로 바꿀 수 있는 것은?","SELECT SYSDATE FROM DUAL;","2","2","TO_CHAR"
"255","다음의 SQL문을 사용할 때, 날짜형 변수를 문자형으로 바꿀 수 있는 것은?","SELECT SYSDATE FROM DUAL;","2","3","TO_DATE"
"255","다음의 SQL문을 사용할 때, 날짜형 변수를 문자형으로 바꿀 수 있는 것은?","SELECT SYSDATE FROM DUAL;","2","4","TO_NUMBER"
"256","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","ㄱ : SELECT SUM(SAL) FROM EMP
       GROUP BY DEPTNO;
ㄴ : SELECT SUM(SAL) FROM EMP
       GROUP BY ROLLUP(DEPTNO);","3","1","ㄱ의 SQL문은 전체합계는 출력되지 않는다."
"256","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","ㄱ : SELECT SUM(SAL) FROM EMP
       GROUP BY DEPTNO;
ㄴ : SELECT SUM(SAL) FROM EMP
       GROUP BY ROLLUP(DEPTNO);","3","2","ㄴ은 부서별 합계와 전체합계가 출력된다."
"256","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","ㄱ : SELECT SUM(SAL) FROM EMP
       GROUP BY DEPTNO;
ㄴ : SELECT SUM(SAL) FROM EMP
       GROUP BY ROLLUP(DEPTNO);","3","3","ㄱ과 ㄴ의 결과 행 수는 동일하다."
"256","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","ㄱ : SELECT SUM(SAL) FROM EMP
       GROUP BY DEPTNO;
ㄴ : SELECT SUM(SAL) FROM EMP
       GROUP BY ROLLUP(DEPTNO);","3","4","ㄱ은 부서별 합계를 출력한다."
"815","제3정규형(3NF)에서 제거해야 하는 종속성은?","","3","1","부분 종속"
"815","제3정규형(3NF)에서 제거해야 하는 종속성은?","","3","2","조인 종속"
"815","제3정규형(3NF)에서 제거해야 하는 종속성은?","","3","3","이행적 종속"
"815","제3정규형(3NF)에서 제거해야 하는 종속성은?","","3","4","기본키 종속"
"816","도메인이란 무엇을 의미하는가?","","2","1","속성의 이름"
"816","도메인이란 무엇을 의미하는가?","","2","2","속성 값의 유효 범위"
"816","도메인이란 무엇을 의미하는가?","","2","3","관계 유형"
"816","도메인이란 무엇을 의미하는가?","","2","4","외래 키 목록"
"820","외래 키(Foreign Key)의 주요 목적은?","","2","1","데이터를 암호화"
"820","외래 키(Foreign Key)의 주요 목적은?","","2","2","데이터 무결성 유지"
"820","외래 키(Foreign Key)의 주요 목적은?","","2","3","성능 향상"
"820","외래 키(Foreign Key)의 주요 목적은?","","2","4","정규화 방지"
"6","다음 중 ANSI-SPARC에서 정의한 3단계구조에서 아래 내용이 설명하는 스키마구조로 가장 적절한 것은?","- 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현 
- 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마","3","1","논리스키마"
"6","다음 중 ANSI-SPARC에서 정의한 3단계구조에서 아래 내용이 설명하는 스키마구조로 가장 적절한 것은?","- 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현 
- 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마","3","2","내부스키마"
"6","다음 중 ANSI-SPARC에서 정의한 3단계구조에서 아래 내용이 설명하는 스키마구조로 가장 적절한 것은?","- 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현 
- 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마","3","3","개념스키마"
"6","다음 중 ANSI-SPARC에서 정의한 3단계구조에서 아래 내용이 설명하는 스키마구조로 가장 적절한 것은?","- 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현 
- 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마","3","4","외부스키마"
"21","다음 중 엔터티간의 관계어서 1：1, 1：M과 같이 관계의 가수성을 나타내는 것으로 가장 적절한 것은?","","3","1","관계정의 (Relationship Definition)"
"21","다음 중 엔터티간의 관계어서 1：1, 1：M과 같이 관계의 가수성을 나타내는 것으로 가장 적절한 것은?","","3","2","관계선택사양(Relationship Optionality)"
"21","다음 중 엔터티간의 관계어서 1：1, 1：M과 같이 관계의 가수성을 나타내는 것으로 가장 적절한 것은?","","3","3","관계차수(Relationship Degree/Cardinality)"
"21","다음 중 엔터티간의 관계어서 1：1, 1：M과 같이 관계의 가수성을 나타내는 것으로 가장 적절한 것은?","","3","4","관계명 (Relationship Membership)"
"65","다음 SQL 문장중 COLUMN1의 값이 널(NULL) 이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은? (ANSI 표준 기준)","","4","1","SELECT * FROM MYTABLE WHERE COLUMN1 NOT NULL"
"65","다음 SQL 문장중 COLUMN1의 값이 널(NULL) 이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은? (ANSI 표준 기준)","","4","2","SELECT * FROM MYTABLE WHERE COLUMN1 != NULL"
"65","다음 SQL 문장중 COLUMN1의 값이 널(NULL) 이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은? (ANSI 표준 기준)","","4","3","SELECT * FROM MYTABLE WHERE COLUMN1〈〉NULL"
"65","다음 SQL 문장중 COLUMN1의 값이 널(NULL) 이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은? (ANSI 표준 기준)","","4","4","SELECT * FROM MYTABLE WHERE COLUMN1 IS NOT NULL"
"71","오라클환경에서 날찌형 데이터를 다룰 경우, 아래 SQL 결과로 가장 적절한 것은?","SELECT TO_CHAR(TO_DATE('2015.01.10 10', 'YYYY,MM,DD HH24') + 1/24/(60/10), 'YYYY,MM,DD HH24:MI:SS') FROM DUAL;","2","1","2015.01.10.10:30:00"
"71","오라클환경에서 날찌형 데이터를 다룰 경우, 아래 SQL 결과로 가장 적절한 것은?","SELECT TO_CHAR(TO_DATE('2015.01.10 10', 'YYYY,MM,DD HH24') + 1/24/(60/10), 'YYYY,MM,DD HH24:MI:SS') FROM DUAL;","2","2","2015.01.10.10:10:00"
"71","오라클환경에서 날찌형 데이터를 다룰 경우, 아래 SQL 결과로 가장 적절한 것은?","SELECT TO_CHAR(TO_DATE('2015.01.10 10', 'YYYY,MM,DD HH24') + 1/24/(60/10), 'YYYY,MM,DD HH24:MI:SS') FROM DUAL;","2","3","2015.01.10.10:05:00"
"71","오라클환경에서 날찌형 데이터를 다룰 경우, 아래 SQL 결과로 가장 적절한 것은?","SELECT TO_CHAR(TO_DATE('2015.01.10 10', 'YYYY,MM,DD HH24') + 1/24/(60/10), 'YYYY,MM,DD HH24:MI:SS') FROM DUAL;","2","4","2015.01.10.11:01:00"
"88","다음 중 아래에서 join에 대한 설명으로 가장 적절한 것은?","(가) 일반적으로 Join은 PK와 FK 값의 연관성에 의해 성립된다.
(나) DBMS 옵티마이져는 From 절에 나열된 테이블들을 임의로 3개 정도씩 묶어서 Join을 처리한다.
(다) EQUI Join은 Join에 관여하는 테이블 간의 컬럼 값들이 정확하게 일치하는 경우에 사용되는 방법이다.
(라) EQUI Join은 '=' 연산자에 의해서만 수행되며, 그 이외의 비교 연산자를 사용하는 경우에는 모두 Non EQUI Join이다.
(마) 대부분 Non EQUI Join을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.","1","1","가, 다, 라, 마"
"88","다음 중 아래에서 join에 대한 설명으로 가장 적절한 것은?","(가) 일반적으로 Join은 PK와 FK 값의 연관성에 의해 성립된다.
(나) DBMS 옵티마이져는 From 절에 나열된 테이블들을 임의로 3개 정도씩 묶어서 Join을 처리한다.
(다) EQUI Join은 Join에 관여하는 테이블 간의 컬럼 값들이 정확하게 일치하는 경우에 사용되는 방법이다.
(라) EQUI Join은 '=' 연산자에 의해서만 수행되며, 그 이외의 비교 연산자를 사용하는 경우에는 모두 Non EQUI Join이다.
(마) 대부분 Non EQUI Join을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.","1","2","가, 나, 다, 라"
"88","다음 중 아래에서 join에 대한 설명으로 가장 적절한 것은?","(가) 일반적으로 Join은 PK와 FK 값의 연관성에 의해 성립된다.
(나) DBMS 옵티마이져는 From 절에 나열된 테이블들을 임의로 3개 정도씩 묶어서 Join을 처리한다.
(다) EQUI Join은 Join에 관여하는 테이블 간의 컬럼 값들이 정확하게 일치하는 경우에 사용되는 방법이다.
(라) EQUI Join은 '=' 연산자에 의해서만 수행되며, 그 이외의 비교 연산자를 사용하는 경우에는 모두 Non EQUI Join이다.
(마) 대부분 Non EQUI Join을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.","1","3","가, 나, 다"
"88","다음 중 아래에서 join에 대한 설명으로 가장 적절한 것은?","(가) 일반적으로 Join은 PK와 FK 값의 연관성에 의해 성립된다.
(나) DBMS 옵티마이져는 From 절에 나열된 테이블들을 임의로 3개 정도씩 묶어서 Join을 처리한다.
(다) EQUI Join은 Join에 관여하는 테이블 간의 컬럼 값들이 정확하게 일치하는 경우에 사용되는 방법이다.
(라) EQUI Join은 '=' 연산자에 의해서만 수행되며, 그 이외의 비교 연산자를 사용하는 경우에는 모두 Non EQUI Join이다.
(마) 대부분 Non EQUI Join을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.","1","4","가, 다, 라"
"96","다음 중 아래 (1), (2), (3)의 SQL에서 실행결과가 같은 것은?","(1) SELECT A.ID, B.ID
 FROM TBL1 A FULL OUTER JOIN TBL2 B
ON A.ID = B.ID
(2)  SELECT A.ID, B.ID
 FROM TBL1 A LEFT OUTER JOIN TBL2 B
 ON A.ID = B.ID
 UNION
 SELECT A.ID, B.ID
 FROM TBL1 A RIGHT OUTER JOIN TBL2 B
 ON A.ID = B.ID
(3)  SELECT A.ID, B.ID
 FROM TBL1 A, TBL2 B
 WHERE A.ID = B.ID
 UNION ALL
 SELECT A. ID, NULL
 FROM TBL1 A
 WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID)
 UNION ALL
 SELECT NULL, B.ID
 FROM TBL2 B
 WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A.ID)","2","1","1,2,3"
"96","다음 중 아래 (1), (2), (3)의 SQL에서 실행결과가 같은 것은?","(1) SELECT A.ID, B.ID
 FROM TBL1 A FULL OUTER JOIN TBL2 B
ON A.ID = B.ID
(2)  SELECT A.ID, B.ID
 FROM TBL1 A LEFT OUTER JOIN TBL2 B
 ON A.ID = B.ID
 UNION
 SELECT A.ID, B.ID
 FROM TBL1 A RIGHT OUTER JOIN TBL2 B
 ON A.ID = B.ID
(3)  SELECT A.ID, B.ID
 FROM TBL1 A, TBL2 B
 WHERE A.ID = B.ID
 UNION ALL
 SELECT A. ID, NULL
 FROM TBL1 A
 WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID)
 UNION ALL
 SELECT NULL, B.ID
 FROM TBL2 B
 WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A.ID)","2","2","2,3"
"96","다음 중 아래 (1), (2), (3)의 SQL에서 실행결과가 같은 것은?","(1) SELECT A.ID, B.ID
 FROM TBL1 A FULL OUTER JOIN TBL2 B
ON A.ID = B.ID
(2)  SELECT A.ID, B.ID
 FROM TBL1 A LEFT OUTER JOIN TBL2 B
 ON A.ID = B.ID
 UNION
 SELECT A.ID, B.ID
 FROM TBL1 A RIGHT OUTER JOIN TBL2 B
 ON A.ID = B.ID
(3)  SELECT A.ID, B.ID
 FROM TBL1 A, TBL2 B
 WHERE A.ID = B.ID
 UNION ALL
 SELECT A. ID, NULL
 FROM TBL1 A
 WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID)
 UNION ALL
 SELECT NULL, B.ID
 FROM TBL2 B
 WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A.ID)","2","3","1,3"
"96","다음 중 아래 (1), (2), (3)의 SQL에서 실행결과가 같은 것은?","(1) SELECT A.ID, B.ID
 FROM TBL1 A FULL OUTER JOIN TBL2 B
ON A.ID = B.ID
(2)  SELECT A.ID, B.ID
 FROM TBL1 A LEFT OUTER JOIN TBL2 B
 ON A.ID = B.ID
 UNION
 SELECT A.ID, B.ID
 FROM TBL1 A RIGHT OUTER JOIN TBL2 B
 ON A.ID = B.ID
(3)  SELECT A.ID, B.ID
 FROM TBL1 A, TBL2 B
 WHERE A.ID = B.ID
 UNION ALL
 SELECT A. ID, NULL
 FROM TBL1 A
 WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID)
 UNION ALL
 SELECT NULL, B.ID
 FROM TBL2 B
 WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A.ID)","2","4","1,2"
"118","다음 중 서브쿼리에 대해 설명으로 가장 적절한 것은?","","3","1","서브 쿼리는 항상 메인쿼리에서 읽혀진 데이터에 대해 서브쿼리에서 해당 조건이 만족하는지를 확인하는 방식으로 수행된다."
"118","다음 중 서브쿼리에 대해 설명으로 가장 적절한 것은?","","3","2","연관 서브쿼리는 주로 메인쿼리에 값을 제공하기 위한 목적으로 사용한다."
"118","다음 중 서브쿼리에 대해 설명으로 가장 적절한 것은?","","3","3","다중 행 서브쿼리 비교 연산자는 단일 행 서브쿼리의 비교 연산자로도 사용할 수 있다."
"118","다음 중 서브쿼리에 대해 설명으로 가장 적절한 것은?","","3","4","단일 행 서브쿼리는 서브쿼리의 실행 결과가 항상 한 건 이하의 서브쿼리로서 IN, ALL 등의 비교 연산자를 사용하여야 한다."
"143","데이터 모델링의 세 가지 중요개념에 속하지 않는 것은?","","2","1","업무가 관여하는 어떤 것의 관계"
"143","데이터 모델링의 세 가지 중요개념에 속하지 않는 것은?","","2","2","업무가 관여하는 어떤 것의 행위"
"143","데이터 모델링의 세 가지 중요개념에 속하지 않는 것은?","","2","3","업무가 관여하는 어떤 것의 성격"
"143","데이터 모델링의 세 가지 중요개념에 속하지 않는 것은?","","2","4","업무가 관여하는 어떤 것"
"144","발생 시점에 따라 구분할 수 있는 엔터티의 유형이 아닌 것은?","","1","1","개념 엔터티"
"144","발생 시점에 따라 구분할 수 있는 엔터티의 유형이 아닌 것은?","","1","2","기본 엔터티"
"144","발생 시점에 따라 구분할 수 있는 엔터티의 유형이 아닌 것은?","","1","3","중심 엔터티"
"144","발생 시점에 따라 구분할 수 있는 엔터티의 유형이 아닌 것은?","","1","4","행위 엔터티"
"167","분산 데이터베이스의 특징 중 저장 장소 명시가 불필요하다는 특성은 무엇인가?","","3","1","분할 투명성"
"167","분산 데이터베이스의 특징 중 저장 장소 명시가 불필요하다는 특성은 무엇인가?","","3","2","병행 투명성"
"167","분산 데이터베이스의 특징 중 저장 장소 명시가 불필요하다는 특성은 무엇인가?","","3","3","위치 투명성"
"167","분산 데이터베이스의 특징 중 저장 장소 명시가 불필요하다는 특성은 무엇인가?","","3","4","지역 사상 투명성"
"171","다음은 ERD 작성 순서이다. 올바른 것을 고르시오.","가)엔터티를 그린다.
나)엔터티를 적절하게 배치한다.
다)엔터티 간에 관계를 설정한다.
라)관계명을 기술한다.
마)관계의 참여도를 기술한다.
바)관계의 필수 여부를 기술한다.","3","1","가->나->다->마->바->라"
"171","다음은 ERD 작성 순서이다. 올바른 것을 고르시오.","가)엔터티를 그린다.
나)엔터티를 적절하게 배치한다.
다)엔터티 간에 관계를 설정한다.
라)관계명을 기술한다.
마)관계의 참여도를 기술한다.
바)관계의 필수 여부를 기술한다.","3","2","가->나->라->다->마->바"
"171","다음은 ERD 작성 순서이다. 올바른 것을 고르시오.","가)엔터티를 그린다.
나)엔터티를 적절하게 배치한다.
다)엔터티 간에 관계를 설정한다.
라)관계명을 기술한다.
마)관계의 참여도를 기술한다.
바)관계의 필수 여부를 기술한다.","3","3","가->나->다->라->마->바"
"171","다음은 ERD 작성 순서이다. 올바른 것을 고르시오.","가)엔터티를 그린다.
나)엔터티를 적절하게 배치한다.
다)엔터티 간에 관계를 설정한다.
라)관계명을 기술한다.
마)관계의 참여도를 기술한다.
바)관계의 필수 여부를 기술한다.","3","4","나->가->다->라->마->바"
"174","다음 중 테이블명으로 가능한 것은 무엇인가?","","2","1","100_EMP"
"174","다음 중 테이블명으로 가능한 것은 무엇인가?","","2","2","EMP100"
"174","다음 중 테이블명으로 가능한 것은 무엇인가?","","2","3","100EMP"
"174","다음 중 테이블명으로 가능한 것은 무엇인가?","","2","4","EMP-100"
"190","SELECT문의 처리 순서로 올바른 것은?","SELECT deptno,sum(sal)
FROM dept
WHERE deptno > 10
GROUP BY deptno
ORDER BY deptno;","3","1","ORDER BY, SELECT, WHERE, GROUP BY, FROM"
"190","SELECT문의 처리 순서로 올바른 것은?","SELECT deptno,sum(sal)
FROM dept
WHERE deptno > 10
GROUP BY deptno
ORDER BY deptno;","3","2","SELECT, FROM, WHERE, GROUP BY, ORDER BY"
"190","SELECT문의 처리 순서로 올바른 것은?","SELECT deptno,sum(sal)
FROM dept
WHERE deptno > 10
GROUP BY deptno
ORDER BY deptno;","3","3","FROM, WHERE, GROUP BY, SELECT, ORDER BY"
"190","SELECT문의 처리 순서로 올바른 것은?","SELECT deptno,sum(sal)
FROM dept
WHERE deptno > 10
GROUP BY deptno
ORDER BY deptno;","3","4","WHERE, GROUP BY, ORDER BY, FROM, SELECT"
"192","데이터베이스 사용자 AAA에 CREATE TABLE 권한이 부여되었다. ( ) 에 들어가야 하는 것은 무엇인가?","( ) CREATE TABLE TO AAA","4","1","COMMIT"
"192","데이터베이스 사용자 AAA에 CREATE TABLE 권한이 부여되었다. ( ) 에 들어가야 하는 것은 무엇인가?","( ) CREATE TABLE TO AAA","4","2","INSERT"
"192","데이터베이스 사용자 AAA에 CREATE TABLE 권한이 부여되었다. ( ) 에 들어가야 하는 것은 무엇인가?","( ) CREATE TABLE TO AAA","4","3","REVOKE"
"192","데이터베이스 사용자 AAA에 CREATE TABLE 권한이 부여되었다. ( ) 에 들어가야 하는 것은 무엇인가?","( ) CREATE TABLE TO AAA","4","4","GRANT"
"194","다음 주어진 그룹 함수와 동일한 결괏값을 반환하는 그룹 함수를 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","1","1","GROUP BY GROUPING SETS(DEPTNO, JOB, (DEPTNO, JOB),());"
"194","다음 주어진 그룹 함수와 동일한 결괏값을 반환하는 그룹 함수를 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","1","2","GROUP BY DEPTNO UNION ALL GROUP BY JOB UNION ALL GROUP BY (DEPTNO, JOB);"
"194","다음 주어진 그룹 함수와 동일한 결괏값을 반환하는 그룹 함수를 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","1","3","GROUP BY (DEPTNO, JOB, (DEPTNO, JOB),());"
"194","다음 주어진 그룹 함수와 동일한 결괏값을 반환하는 그룹 함수를 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","1","4","GROUP BY ROLLUP(DEPTNO,JOB);"
"270","데이터베이스 정규화 중에서 기본키를 제외하고 칼럼 간에 종속성이 발생하면 테이블을 분할하는 것은?","","2","1","제4정규화"
"270","데이터베이스 정규화 중에서 기본키를 제외하고 칼럼 간에 종속성이 발생하면 테이블을 분할하는 것은?","","2","2","제3정규화"
"270","데이터베이스 정규화 중에서 기본키를 제외하고 칼럼 간에 종속성이 발생하면 테이블을 분할하는 것은?","","2","3","제2정규화"
"270","데이터베이스 정규화 중에서 기본키를 제외하고 칼럼 간에 종속성이 발생하면 테이블을 분할하는 것은?","","2","4","제1정규화"
"278","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","2","1","CONNECT_BY_ISLEAF에서 해당 데이터가 리프 데이터면 1, 그렇지 않으면 0을 반환한다."
"278","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","2","2","CONNECT BY는 부모 자식을 설명하는 것이다."
"278","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","2","3","계층형 쿼리는 계층형 형태로 데이터를 질의할 때 사용된다."
"278","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","2","4","PRIOR 자식 = 부모 형태를 사용하면 계층 구조에서 순방향 전개를 수행한다."
"285","분산 데이터베이스의 투명성과 관련이 없는 것은?","","1","1","이행 투명성"
"285","분산 데이터베이스의 투명성과 관련이 없는 것은?","","1","2","지역사상 투명성"
"285","분산 데이터베이스의 투명성과 관련이 없는 것은?","","1","3","위치 투명성"
"285","분산 데이터베이스의 투명성과 관련이 없는 것은?","","1","4","분할 투명성"
"306","다음 보기에서 설명하고 있는 데이터베이스 키의 종류는 무엇인가?","데이터베이스 키의 종류 중에서 유일성과 최소성을 만족한다.","2","1","외래키"
"306","다음 보기에서 설명하고 있는 데이터베이스 키의 종류는 무엇인가?","데이터베이스 키의 종류 중에서 유일성과 최소성을 만족한다.","2","2","후보키"
"306","다음 보기에서 설명하고 있는 데이터베이스 키의 종류는 무엇인가?","데이터베이스 키의 종류 중에서 유일성과 최소성을 만족한다.","2","3","수퍼키"
"306","다음 보기에서 설명하고 있는 데이터베이스 키의 종류는 무엇인가?","데이터베이스 키의 종류 중에서 유일성과 최소성을 만족한다.","2","4","인조키"
"322","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","1","1","서브쿼리에서 메인쿼리의 칼럼을 사용할 수 있고 메인쿼리에서도 서브쿼리의 칼럼을 사용할 수 있다."
"322","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","1","2","FROM구에 사용되면 인라인 뷰이고 WHERE절에 사용되면 서브쿼리이다."
"322","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","1","3","서브쿼리에서 여러 개의 행이 반환되면 IN, ANY, ALL과 같은 다중행 서브쿼리 함수를 사용해야 한다."
"322","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","1","4","서브쿼리에는 Order by구를 사용할 수 없다."
"335","다음 주어진 SQL문을 수행하였을 때 최종적으로 반영되는 값은 무엇인가?","INSERT INTO Mytest VALUES(1);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET CO1=8 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE COL1=8;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(9);
ROLLBACK TO SV2;
COMMIT;","1","1","1,8,9"
"335","다음 주어진 SQL문을 수행하였을 때 최종적으로 반영되는 값은 무엇인가?","INSERT INTO Mytest VALUES(1);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET CO1=8 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE COL1=8;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(9);
ROLLBACK TO SV2;
COMMIT;","1","2","1,8,11,8"
"335","다음 주어진 SQL문을 수행하였을 때 최종적으로 반영되는 값은 무엇인가?","INSERT INTO Mytest VALUES(1);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET CO1=8 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE COL1=8;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(9);
ROLLBACK TO SV2;
COMMIT;","1","3","1,8,11"
"335","다음 주어진 SQL문을 수행하였을 때 최종적으로 반영되는 값은 무엇인가?","INSERT INTO Mytest VALUES(1);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET CO1=8 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE COL1=8;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(9);
ROLLBACK TO SV2;
COMMIT;","1","4","1,2"
"338","다음 중 CUBE 함수에 대한 설명으로 올바르지 않은 것은?","","1","1","ROLLUP에 비해서 시스템 연산이 적은 장점이 있다."
"338","다음 중 CUBE 함수에 대한 설명으로 올바르지 않은 것은?","","1","2","CUBE 함수를 사용해서 계층별 집계를 구할 수 있다."
"338","다음 중 CUBE 함수에 대한 설명으로 올바르지 않은 것은?","","1","3","CUBE는 ORDER BY를 사용해서 정렬할 수 있다."
"338","다음 중 CUBE 함수에 대한 설명으로 올바르지 않은 것은?","","1","4","CUBE는 칼럼에서 결합이 가능한 모든 다차원 집계를 생성한다."
"368","다음 중 속성에 대한 특징으로 알맞은 것은?","","3","1","서술식 속성명을 사용할 수 있다."
"368","다음 중 속성에 대한 특징으로 알맞은 것은?","","3","2","하나의 속성은 여러 개의 속성명을 가질 수 있다."
"368","다음 중 속성에 대한 특징으로 알맞은 것은?","","3","3","엔터티를 설명하고 인스턴스의 구성요소가 된다."
"368","다음 중 속성에 대한 특징으로 알맞은 것은?","","3","4","한 개의 엔터티는 한 개의 속성만 가질 수 있다."
"376","다음 중 GROUP 함수에 대한 설명으로 올바른 것은?","","4","1","ROLLUP은 CUBE에 비해서 시스템에 부하를 많이 발생시키므로 반드시 튜닝해야 한다."
"376","다음 중 GROUP 함수에 대한 설명으로 올바른 것은?","","4","2","ROLLUP, CUBE, GROUPING SETS은 정렬이 가능하지만, 하나의 칼럼에 대해서만 사용할 수 있다."
"376","다음 중 GROUP 함수에 대한 설명으로 올바른 것은?","","4","3","ROLLUP은 전체합계만을 구하고 싶을 때 사용한다."
"376","다음 중 GROUP 함수에 대한 설명으로 올바른 것은?","","4","4","CUBE는 결합 가능한 모든 값에 대하여 다차원 집계를 생성하는 것이 특징이다."
"382","동일한 순위에 대해서 동일한 순위를 부여하고 다음 순위를 건너뛰지 않는 것은?","","3","1","RATIO.....TO REPORT"
"382","동일한 순위에 대해서 동일한 순위를 부여하고 다음 순위를 건너뛰지 않는 것은?","","3","2","ROW_NUMBER"
"382","동일한 순위에 대해서 동일한 순위를 부여하고 다음 순위를 건너뛰지 않는 것은?","","3","3","DENSE_RANK"
"382","동일한 순위에 대해서 동일한 순위를 부여하고 다음 순위를 건너뛰지 않는 것은?","","3","4","RANK"
"387","아래의 SQL문에 대한 설명으로 올바른 것은?","SELECT * FROM EMP
WHERE EMP_NAME LIKE 'K%';","3","1","테이블의 EMP_NAME이 A 또는 a로 끝나는 모든 행이 검색된다."
"387","아래의 SQL문에 대한 설명으로 올바른 것은?","SELECT * FROM EMP
WHERE EMP_NAME LIKE 'K%';","3","2","테이블의 EMP_NAME이 K로 끝나는 모든 행이 검색된다."
"387","아래의 SQL문에 대한 설명으로 올바른 것은?","SELECT * FROM EMP
WHERE EMP_NAME LIKE 'K%';","3","3","테이블의 EMP_NAME이 K로 시작하는 모든 행이 검색된다."
"387","아래의 SQL문에 대한 설명으로 올바른 것은?","SELECT * FROM EMP
WHERE EMP_NAME LIKE 'K%';","3","4","테이블의 EMP_NAME이 K 또는 k로 시작하는 모든 행이 검색된다."
"398","SELECT UPPER('sqldeveloper') FROM DUAL; 의 결과를 적으시오.","","3","1","SqlDeveloper"
"398","SELECT UPPER('sqldeveloper') FROM DUAL; 의 결과를 적으시오.","","3","2","sqldeveloper"
"398","SELECT UPPER('sqldeveloper') FROM DUAL; 의 결과를 적으시오.","","3","3","SQLDEVELOPER"
"398","SELECT UPPER('sqldeveloper') FROM DUAL; 의 결과를 적으시오.","","3","4","SQLDeveloper"
"400","다음의 SQL 실행 결과는 무엇인가?","SELECT sysdate + NULL FROM DUAL;","1","1","NULL"
"400","다음의 SQL 실행 결과는 무엇인가?","SELECT sysdate + NULL FROM DUAL;","1","2","내일 날짜가 조회된다."
"400","다음의 SQL 실행 결과는 무엇인가?","SELECT sysdate + NULL FROM DUAL;","1","3","오늘 날짜가 조회된다."
"400","다음의 SQL 실행 결과는 무엇인가?","SELECT sysdate + NULL FROM DUAL;","1","4","0"
"412","A 사용자가 ""홍길동"" 데이터를 입력하고 아직 COMMIT 되지 않은 데이터에 대한 설명으로 잘못된 것은?","","1","1","B 사용자는 홍길동 데이터를 수정할 수 있다."
"412","A 사용자가 ""홍길동"" 데이터를 입력하고 아직 COMMIT 되지 않은 데이터에 대한 설명으로 잘못된 것은?","","1","2","A 사용자는 홍길동 데이터를 수정할 수 있다."
"412","A 사용자가 ""홍길동"" 데이터를 입력하고 아직 COMMIT 되지 않은 데이터에 대한 설명으로 잘못된 것은?","","1","3","B 사용자는 홍길동 데이터가 조회되지 않는다."
"412","A 사용자가 ""홍길동"" 데이터를 입력하고 아직 COMMIT 되지 않은 데이터에 대한 설명으로 잘못된 것은?","","1","4","A 사용자는 홍길동 데이터를 조회할 수 있다."
"413","다음 중 COL100에 NULL이 없는 데이터를 찾는 SQL로 올바른 것은?","","2","1","SELECT COL1 FROM T1 WHERE COL100 NOT IN (NULL)"
"413","다음 중 COL100에 NULL이 없는 데이터를 찾는 SQL로 올바른 것은?","","2","2","SELECT COL1 FROM T1 WHERE COL100 IS NOT NULL"
"413","다음 중 COL100에 NULL이 없는 데이터를 찾는 SQL로 올바른 것은?","","2","3","SELECT COL1 FROM T1 WHERE COL100 != ''"
"413","다음 중 COL100에 NULL이 없는 데이터를 찾는 SQL로 올바른 것은?","","2","4","SELECT COL1 FROM T1 WHERE COL100 <> 'NULL'"
"426","다음 중 아래 SQL문의 결괏값으로 올바른 것은?","SELECT SUBSTR('123456789123456789', -4,2) FROM DUAL;","1","1","67"
"426","다음 중 아래 SQL문의 결괏값으로 올바른 것은?","SELECT SUBSTR('123456789123456789', -4,2) FROM DUAL;","1","2","65"
"426","다음 중 아래 SQL문의 결괏값으로 올바른 것은?","SELECT SUBSTR('123456789123456789', -4,2) FROM DUAL;","1","3","43"
"426","다음 중 아래 SQL문의 결괏값으로 올바른 것은?","SELECT SUBSTR('123456789123456789', -4,2) FROM DUAL;","1","4","45"
"428","다음 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","1","고유키로 지정되면 모든 칼럼들은 NULL 값을 가질 수 없다."
"428","다음 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","2","외래키는 테이블 간의 관계를 정의하고 참조 무결성을 준수하게 한다."
"428","다음 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","3","Check 조건은 테이블에 데이터를 입력 하기 전에 검사를 수행한다."
"428","다음 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","4","기본키는 테이블당 하나의 제약만을 정의할 수 있다."
"471","다음 보기 중 WHERE에서 사용되는 서브쿼리에 대한 설명으로 옳지 않은 것은?","","3","1","EXISTS는 TRUE와 FALSE만 되돌린다."
"471","다음 보기 중 WHERE에서 사용되는 서브쿼리에 대한 설명으로 옳지 않은 것은?","","3","2","여러 개의 행을 되돌리는 서브쿼리는 다중 행 연산자를 사용해야 한다."
"471","다음 보기 중 WHERE에서 사용되는 서브쿼리에 대한 설명으로 옳지 않은 것은?","","3","3","메인쿼리를 작성할 때 서브쿼리에 있는 칼럼을 자유롭게 사용할 수 있으면 편리하다."
"471","다음 보기 중 WHERE에서 사용되는 서브쿼리에 대한 설명으로 옳지 않은 것은?","","3","4","서브쿼리에서는 정렬을 수행하기 위해서 내부에 ORDER BY를 사용하지 못한다."
"492","테이블에 대한 권한을 부여하는 DCL 명령어는?","","3","1","ROLLBACK"
"492","테이블에 대한 권한을 부여하는 DCL 명령어는?","","3","2","REVOKE"
"492","테이블에 대한 권한을 부여하는 DCL 명령어는?","","3","3","GRANT"
"492","테이블에 대한 권한을 부여하는 DCL 명령어는?","","3","4","COMMIT"
"500","아래의 WINDOW FUNCTION을 사용한 SQL 중 가장 올바르지 않은 것은?","","1","1","SUM(SAL) OVER(PARTITION BY JOB ORDER BY EMPNO RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED PRECEDING)  SAL3"
"500","아래의 WINDOW FUNCTION을 사용한 SQL 중 가장 올바르지 않은 것은?","","1","2","SUM(SAL) OVER(PARTITION BY JOB ORDER BY JOB RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)  SAL2"
"500","아래의 WINDOW FUNCTION을 사용한 SQL 중 가장 올바르지 않은 것은?","","1","3","SUM(SAL) OVER(PARTITION BY JOB ORDER BY EMPNO RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)  SAL1"
"500","아래의 WINDOW FUNCTION을 사용한 SQL 중 가장 올바르지 않은 것은?","","1","4","SUM(SAL) OVER()"
"502","주어진 SQL문을 수행한 결과로 올바른 것은?","INSERT INTO test24 VALUES (1);
INSERT INTO test24 VALUES (2);
COMMIT;
INSERT INTO test24 VALUES (3);
SAVEPOINT SP;
INSERT INTO test24 VALUES (4);
ROLLBACK to SP;
SELECT COUNT(*) FROM test24;","3","1","6"
"502","주어진 SQL문을 수행한 결과로 올바른 것은?","INSERT INTO test24 VALUES (1);
INSERT INTO test24 VALUES (2);
COMMIT;
INSERT INTO test24 VALUES (3);
SAVEPOINT SP;
INSERT INTO test24 VALUES (4);
ROLLBACK to SP;
SELECT COUNT(*) FROM test24;","3","2","5"
"502","주어진 SQL문을 수행한 결과로 올바른 것은?","INSERT INTO test24 VALUES (1);
INSERT INTO test24 VALUES (2);
COMMIT;
INSERT INTO test24 VALUES (3);
SAVEPOINT SP;
INSERT INTO test24 VALUES (4);
ROLLBACK to SP;
SELECT COUNT(*) FROM test24;","3","3","3"
"502","주어진 SQL문을 수행한 결과로 올바른 것은?","INSERT INTO test24 VALUES (1);
INSERT INTO test24 VALUES (2);
COMMIT;
INSERT INTO test24 VALUES (3);
SAVEPOINT SP;
INSERT INTO test24 VALUES (4);
ROLLBACK to SP;
SELECT COUNT(*) FROM test24;","3","4","2"
"523","다음 중 도메인 대한 특징으로 옳지 않은 것은?","","1","1","하나의 릴레이션과 관계된 다른 릴레이션의 FK 제약조건이다."
"523","다음 중 도메인 대한 특징으로 옳지 않은 것은?","","1","2","속성에 값을 입력할 때 CHECK 기능을 사용해서 입력값을 검사한다."
"523","다음 중 도메인 대한 특징으로 옳지 않은 것은?","","1","3","속성에 대해서 NOT NULL 제약사항을 설정하여 NULL 값을 허용하지 않는다."
"523","다음 중 도메인 대한 특징으로 옳지 않은 것은?","","1","4","릴레이션의 속성에 대한 데이터 타입과 크기이다."
"524","다음 중 데이터베이스 모델링에 대한 특징으로 올바르지 않은 것은?","","4","1","명확화"
"524","다음 중 데이터베이스 모델링에 대한 특징으로 올바르지 않은 것은?","","4","2","단순화"
"524","다음 중 데이터베이스 모델링에 대한 특징으로 올바르지 않은 것은?","","4","3","추상화"
"524","다음 중 데이터베이스 모델링에 대한 특징으로 올바르지 않은 것은?","","4","4","내부화"
"553","파티션별 윈도우에서 가장 먼저 나온 값을 구하는 WINDOW FUNCTION은 무엇인가?","","4","1","LEAD"
"553","파티션별 윈도우에서 가장 먼저 나온 값을 구하는 WINDOW FUNCTION은 무엇인가?","","4","2","LAST_VALUE"
"553","파티션별 윈도우에서 가장 먼저 나온 값을 구하는 WINDOW FUNCTION은 무엇인가?","","4","3","LAG"
"553","파티션별 윈도우에서 가장 먼저 나온 값을 구하는 WINDOW FUNCTION은 무엇인가?","","4","4","FIRST_VALUE"
"580","다음 식별자에 대한 설명으로 가장 적절한 것은?","엔터티 내의 여러 인스턴스 중 하나를 유일하게 구분할 수 있으나, 대표성을 가지지 못하는 식별자","4","1","복합식별자"
"580","다음 식별자에 대한 설명으로 가장 적절한 것은?","엔터티 내의 여러 인스턴스 중 하나를 유일하게 구분할 수 있으나, 대표성을 가지지 못하는 식별자","4","2","본질식별자"
"580","다음 식별자에 대한 설명으로 가장 적절한 것은?","엔터티 내의 여러 인스턴스 중 하나를 유일하게 구분할 수 있으나, 대표성을 가지지 못하는 식별자","4","3","인조식별자"
"580","다음 식별자에 대한 설명으로 가장 적절한 것은?","엔터티 내의 여러 인스턴스 중 하나를 유일하게 구분할 수 있으나, 대표성을 가지지 못하는 식별자","4","4","보조식별자"
"620","유저와 권한 중 권한에 대한 설명 중 가장 올바르지 않은 것은?","","3","1","권한 부여를 편리하게 관리하기 위해 만들어진 권한의 집합인 ROLE 이 있다"
"620","유저와 권한 중 권한에 대한 설명 중 가장 올바르지 않은 것은?","","3","2","테이블의 소유자는 해당 테이블의 DML 권한을 다른 유저에게 부여 할 수 있다."
"620","유저와 권한 중 권한에 대한 설명 중 가장 올바르지 않은 것은?","","3","3","DBA 권한을 가진 유저만이 권한을 부여 할 수 있다"
"620","유저와 권한 중 권한에 대한 설명 중 가장 올바르지 않은 것은?","","3","4","사용자가 실행하는 모든 DDL 문장은 그에 해당하는 적절한 권한이 있어야만 문장을 실행 할 수 있다."
"626","데이터 모델링의 정규화에 대한 설명으로 가장 적절하지 않은 것은?","","3","1","제3정규형을 만족하는 엔터티의 일반속성은 주식별자 전체에 종속적이다."
"626","데이터 모델링의 정규화에 대한 설명으로 가장 적절하지 않은 것은?","","3","2","제1정규형은 모든 인스턴스가 반드시 하나의 값을 가져야 함을 의미한다."
"626","데이터 모델링의 정규화에 대한 설명으로 가장 적절하지 않은 것은?","","3","3","개념 모델링 단계에서의 엔터티를 상세화 하는 과정이다."
"626","데이터 모델링의 정규화에 대한 설명으로 가장 적절하지 않은 것은?","","3","4","정규화는 모델의 일관성을 확보하고 중복을 제거하여 모델의 독립성을 확보하는 과정이다."
"631","다음 SQL 중 항상 오류가 발생하는 구문으로 가장 적절한 것은? ","","1","1","SELECT T.COL1 C1, T.COL2 AS ""C1"" FROM TABLE1 T WHERE T.COL2 IN ('A', 'B') ORDER BY 1, ""C1"";"
"631","다음 SQL 중 항상 오류가 발생하는 구문으로 가장 적절한 것은? ","","1","2","SELECT T.COL1 C1, TABLE1.COL2 AS C2 FROM TABLE1 T WHERE TABLE1.COL2 = 'A' ORDER BY 1, 2;"
"631","다음 SQL 중 항상 오류가 발생하는 구문으로 가장 적절한 것은? ","","1","3","SELECT TABLE1.COL1, SUM(TABLE1.COL2) FROM TABLE1 GROUP BY TABLE1.COL1 ORDER BY COL1;"
"631","다음 SQL 중 항상 오류가 발생하는 구문으로 가장 적절한 것은? ","","1","4","SELECT T.COL1 C1, T.COL2 AS C2 FROM TABLE1 T WHERE T.COL1 = 4;"
"677","다음이 설명하는 관계로 가장 적절한 것은? ","두 엔터티나 두 속성 간에 동시에 발생할 수 없는 관계를 의미합니다. 즉, 하나의 엔터티나 속성이 특정한 경우 다른 엔터티나 속성은 해당 경우가 될 수 없음을 나타냅니다.","2","1","상호일관적"
"677","다음이 설명하는 관계로 가장 적절한 것은? ","두 엔터티나 두 속성 간에 동시에 발생할 수 없는 관계를 의미합니다. 즉, 하나의 엔터티나 속성이 특정한 경우 다른 엔터티나 속성은 해당 경우가 될 수 없음을 나타냅니다.","2","2","상호배타적"
"677","다음이 설명하는 관계로 가장 적절한 것은? ","두 엔터티나 두 속성 간에 동시에 발생할 수 없는 관계를 의미합니다. 즉, 하나의 엔터티나 속성이 특정한 경우 다른 엔터티나 속성은 해당 경우가 될 수 없음을 나타냅니다.","2","3","상호포괄적"
"677","다음이 설명하는 관계로 가장 적절한 것은? ","두 엔터티나 두 속성 간에 동시에 발생할 수 없는 관계를 의미합니다. 즉, 하나의 엔터티나 속성이 특정한 경우 다른 엔터티나 속성은 해당 경우가 될 수 없음을 나타냅니다.","2","4","상호종속적"
"686","다음 함수 사용시 결과값이 올바르지 않은 것은? ","","4","1","SIGN(0) = 0"
"686","다음 함수 사용시 결과값이 올바르지 않은 것은? ","","4","2","MOD(8,3) = 2"
"686","다음 함수 사용시 결과값이 올바르지 않은 것은? ","","4","3","FLOOR(-12.345) = -13"
"686","다음 함수 사용시 결과값이 올바르지 않은 것은? ","","4","4","CEIL(-12.345) = -13"
"689","다음 중 정상적으로 실행되지 않는 문장은? (단, DBMS는 오라클)","","1","1","SELECT NVL(100, 'NULL') FROM DUAL;"
"689","다음 중 정상적으로 실행되지 않는 문장은? (단, DBMS는 오라클)","","1","2","SELECT TO_DATE('11', 'DD') + 10 FROM DUAL;"
"689","다음 중 정상적으로 실행되지 않는 문장은? (단, DBMS는 오라클)","","1","3","SELECT TO_DATE('20240101', 'YYYYMMDD') - 10 FROM DUAL;"
"689","다음 중 정상적으로 실행되지 않는 문장은? (단, DBMS는 오라클)","","1","4","SELECT 100 + '1' FROM DUAL;"
"724","다음 중 관계를 구성하는 요소가 아닌 것은?","","1","1","관계정의"
"724","다음 중 관계를 구성하는 요소가 아닌 것은?","","1","2","선택성(Optionality)"
"724","다음 중 관계를 구성하는 요소가 아닌 것은?","","1","3","차수(Cardinality)"
"724","다음 중 관계를 구성하는 요소가 아닌 것은?","","1","4","관계명"
"747","서브쿼리에 대한 설명으로 가장 적절한 것은?","","1","1","연관 서브쿼리는 메인쿼리가 먼저 수행된 후에 서브쿼리에서 조건이 맞는지 확인할 때 주로 사용한다."
"747","서브쿼리에 대한 설명으로 가장 적절한 것은?","","1","2","서브쿼리가 메인쿼리 컬럼을 가지고 있을 경우 비연관 서브쿼리라고 한다."
"747","서브쿼리에 대한 설명으로 가장 적절한 것은?","","1","3","단일행 서브쿼리는 비교 연산자 사용이 불가하다."
"747","서브쿼리에 대한 설명으로 가장 적절한 것은?","","1","4","FROM 절에 사용하는 서브쿼리를 스칼라 서브쿼리라고 한다."
"763","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_REPLACE('031-234-4567', '\d+', 'XXX', 1, 2) FROM DUAL;","2","1","031-234-XXX"
"763","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_REPLACE('031-234-4567', '\d+', 'XXX', 1, 2) FROM DUAL;","2","2","031-XXX-4567"
"763","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_REPLACE('031-234-4567', '\d+', 'XXX', 1, 2) FROM DUAL;","2","3","XX1-234-4567"
"763","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_REPLACE('031-234-4567', '\d+', 'XXX', 1, 2) FROM DUAL;","2","4","031-234-4567"
"766","다음 설명 중 가장 적절하지 않은 것은?","","1","1","SAVEPOINT 지점이 COMMIT 이전일때 해당 SAVEPOINT까지 ROLLBACK 시도 시 COMMIT이후 까지만 ROLLBACK 된다."
"766","다음 설명 중 가장 적절하지 않은 것은?","","1","2","ROLLBACK을 한 명령을 다시 ROLLBACK으로 취소할 수 없다."
"766","다음 설명 중 가장 적절하지 않은 것은?","","1","3","INSERT 한 이후 컬럼 추가 시 INSERT 값은 자동 저장되어 ROLLBACK 할 수 없다."
"766","다음 설명 중 가장 적절하지 않은 것은?","","1","4","COMMIT을 한 이후에는 ROLLBACK을 수행해도 이전 값으로 돌아갈 수 없다."
"767","테이블 생성 시 주의 사항으로 옳지 않은 것은?","","3","1","컬럼에 대한 제약조건을 추가하는 경우 CONSTRAINT를 사용한다."
"767","테이블 생성 시 주의 사항으로 옳지 않은 것은?","","3","2","날짜 유형은 별도로 크기를 지정하지 않아도 된다."
"767","테이블 생성 시 주의 사항으로 옳지 않은 것은?","","3","3","문자 데이터 유형은 별도로 크기를 지정하지 않아도 된다."
"767","테이블 생성 시 주의 사항으로 옳지 않은 것은?","","3","4","테이블 생성시 대소문자 구분은 하지 않아도 된다."
"772","엔터티에 대한 설명으로 가장 적절한 것은?","","3","1","주로 약어를 사용하여 엔터티 이름을 정한다."
"772","엔터티에 대한 설명으로 가장 적절한 것은?","","3","2","다른 엔터티와 관계를 꼭 갖지 않아도 된다."
"772","엔터티에 대한 설명으로 가장 적절한 것은?","","3","3","사용되지 않는 고립 엔터티는 제거를 고려한다."
"772","엔터티에 대한 설명으로 가장 적절한 것은?","","3","4","누락된 프로세스의 경우 이후 추가하거나 수정할 수 없다."
"777","관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","1","관계는 존재에 의한 관계와 행위에 의한 관계로 분류한다."
"777","관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","2","관계를 맺는다는 의미는 자식의 식별자를 부모에 상속하는 일이다."
"777","관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","3","학생과 수업 간의 관계는 등록이라는 행위를 통해 형성되므로 행위 관계를 갖는다."
"777","관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","4","주문항목은 반드시 주문이 있어야만 존재할 수 있으므로 존재 관계를 갖는다."
"778","트랜잭션의 특성 그 의미와 맞는 것은?","","2","1","연관성 : 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다."
"778","트랜잭션의 특성 그 의미와 맞는 것은?","","2","2","고립성 : 트랜잭션이 실행되는 도중 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안 된다"
"778","트랜잭션의 특성 그 의미와 맞는 것은?","","2","3","원자성 : 트랜잭션이 실행되기 전 데이터의 내용이 잘못되면 실행 이후에도 내용이 잘못 되어 있지 않다."
"778","트랜잭션의 특성 그 의미와 맞는 것은?","","2","4","일관성 : 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다."
"780","다음 식별자에 대한 설명으로 가장 적절하지 않은 것은?","","2","1","인조식별자를 사용하면 중복 데이터 발생 가능성이 있어 데이터 품질이 저하된다."
"780","다음 식별자에 대한 설명으로 가장 적절하지 않은 것은?","","2","2","본질식별자가 단순한 구성을 가질 때 주로 인조식별자를 생성한다."
"780","다음 식별자에 대한 설명으로 가장 적절하지 않은 것은?","","2","3","꼭 필요하지 않지만 관리의 편이성 등의 이유로 인위적으로 만들어지는 식별자를 인조식별자라 한다."
"780","다음 식별자에 대한 설명으로 가장 적절하지 않은 것은?","","2","4","업무에 의해 만들어지는 식별자를 본질식별자라고 한다."
"781","다음이 설명하는 데이터 무결성의 종류는?","테이블의 기본키를 구성하는 컬럼은 NULL 값이나 중복값을 가질 수 없다.","4","1","NULL 무결성"
"781","다음이 설명하는 데이터 무결성의 종류는?","테이블의 기본키를 구성하는 컬럼은 NULL 값이나 중복값을 가질 수 없다.","4","2","도메인 무결성"
"781","다음이 설명하는 데이터 무결성의 종류는?","테이블의 기본키를 구성하는 컬럼은 NULL 값이나 중복값을 가질 수 없다.","4","3","참조 무결성"
"781","다음이 설명하는 데이터 무결성의 종류는?","테이블의 기본키를 구성하는 컬럼은 NULL 값이나 중복값을 가질 수 없다.","4","4","개체 무결성"
"792","다음 GROUP BY에 대한 설명 중 가장 적절하지 않은 것은?","","3","1","GROUP BY 절에 사용하지 않은 컬럼은 SUM과 같은 집계함수와 함께 SELECT절에 사용 가능하다."
"792","다음 GROUP BY에 대한 설명 중 가장 적절하지 않은 것은?","","3","2","GROUP BY 뒤의 첫 번째 값이 UNIQUE한 경우 뒤에 어떤 컬럼을 추가적으로 명시해도 그룹의 수는 변화없다."
"792","다음 GROUP BY에 대한 설명 중 가장 적절하지 않은 것은?","","3","3","GROUP BY 뒤의 컬럼 순서에 따라 출력되는 그룹의 수가 달라진다."
"792","다음 GROUP BY에 대한 설명 중 가장 적절하지 않은 것은?","","3","4","GROUP BY 절에는 컬럼 별칭을 사용할 수 없다."
"798","5개의 테이블 조인 시 조인 조건의 최소 개수는?","","1","1","4"
"798","5개의 테이블 조인 시 조인 조건의 최소 개수는?","","1","2","3"
"798","5개의 테이블 조인 시 조인 조건의 최소 개수는?","","1","3","2"
"798","5개의 테이블 조인 시 조인 조건의 최소 개수는?","","1","4","1"
"253","서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","1","서브쿼리는 SELECT, FROM, WHERE 등에서 사용이 가능하다."
"253","서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","2","메인쿼리는 스칼라 서브쿼리의 칼럼을 쓸 수 없다."
"253","서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","3","서브쿼리는 비교 연산자와 함께 사용이 가능하다."
"253","서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","4","서브쿼리는 괄호를 사용해서 SELECT문을 감싸서 사용하는 것이다."
"254","""TEST"" 테이블에 있는 NUM2 칼럼의 총 행은 10개이고 2개의 NULL 값이 있다. 다음의 SQL문을 실행할 경우 결괏값은?","ㄱ : SELECT COUNT(*) FROM TEST;
ㄴ : SELECT COUNT(NUM2) FROM TEST;","3","1","ㄱ:8, ㄴ:8"
"254","""TEST"" 테이블에 있는 NUM2 칼럼의 총 행은 10개이고 2개의 NULL 값이 있다. 다음의 SQL문을 실행할 경우 결괏값은?","ㄱ : SELECT COUNT(*) FROM TEST;
ㄴ : SELECT COUNT(NUM2) FROM TEST;","3","2","ㄱ:8, ㄴ:10"
"254","""TEST"" 테이블에 있는 NUM2 칼럼의 총 행은 10개이고 2개의 NULL 값이 있다. 다음의 SQL문을 실행할 경우 결괏값은?","ㄱ : SELECT COUNT(*) FROM TEST;
ㄴ : SELECT COUNT(NUM2) FROM TEST;","3","3","ㄱ:10, ㄴ:8"
"254","""TEST"" 테이블에 있는 NUM2 칼럼의 총 행은 10개이고 2개의 NULL 값이 있다. 다음의 SQL문을 실행할 경우 결괏값은?","ㄱ : SELECT COUNT(*) FROM TEST;
ㄴ : SELECT COUNT(NUM2) FROM TEST;","3","4","ㄱ:10, ㄴ:10"
"268","데이터베이스 3층 스키마에 해당 되지 않는 것은?","","3","1","내부 단계"
"268","데이터베이스 3층 스키마에 해당 되지 않는 것은?","","3","2","개념 단계"
"268","데이터베이스 3층 스키마에 해당 되지 않는 것은?","","3","3","사용 단계"
"268","데이터베이스 3층 스키마에 해당 되지 않는 것은?","","3","4","외부 단계"
"803","논리적 데이터 모델링 단계에서 수행하는 주요 작업은 무엇인가?","","1","1","속성 정제 및 도메인 정의"
"803","논리적 데이터 모델링 단계에서 수행하는 주요 작업은 무엇인가?","","1","2","테이블 생성"
"803","논리적 데이터 모델링 단계에서 수행하는 주요 작업은 무엇인가?","","1","3","화면 설계"
"803","논리적 데이터 모델링 단계에서 수행하는 주요 작업은 무엇인가?","","1","4","하드웨어 구조 분석"
"808","약한 엔터티(Weak Entity)의 특징은?","","3","1","기본 키가 있음"
"808","약한 엔터티(Weak Entity)의 특징은?","","3","2","독립적으로 존재 가능"
"808","약한 엔터티(Weak Entity)의 특징은?","","3","3","강한 엔터티에 의존"
"808","약한 엔터티(Weak Entity)의 특징은?","","3","4","항상 1:1 관계"
"809","식별자 관계에 대한 설명으로 옳은 것은?","","3","1","부모 엔터티의 키를 참조하지 않는다"
"809","식별자 관계에 대한 설명으로 옳은 것은?","","3","2","자식 엔터티가 부모 없이 독립 가능하다"
"809","식별자 관계에 대한 설명으로 옳은 것은?","","3","3","자식의 기본키에 부모의 키가 포함된다"
"809","식별자 관계에 대한 설명으로 옳은 것은?","","3","4","비식별 관계보다 느슨한 관계이다"
"812","정규형(Normal Form)의 올바른 순서는?","","2","1","2NF → 1NF → 3NF"
"812","정규형(Normal Form)의 올바른 순서는?","","2","2","1NF → 2NF → 3NF"
"812","정규형(Normal Form)의 올바른 순서는?","","2","3","3NF → 2NF → 1NF"
"812","정규형(Normal Form)의 올바른 순서는?","","2","4","1NF → 3NF → 2NF"
"12","다음 중 다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지며 사원, 부서, 고객, 상품, 자재 등이 예가 될 수 있는 엔터티로 가장 적절한 것은?","","4","1","개념 엔터티"
"12","다음 중 다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지며 사원, 부서, 고객, 상품, 자재 등이 예가 될 수 있는 엔터티로 가장 적절한 것은?","","4","2","행위 엔터티"
"12","다음 중 다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지며 사원, 부서, 고객, 상품, 자재 등이 예가 될 수 있는 엔터티로 가장 적절한 것은?","","4","3","중심 엔터티(메인엔터티)"
"12","다음 중 다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지며 사원, 부서, 고객, 상품, 자재 등이 예가 될 수 있는 엔터티로 가장 적절한 것은?","","4","4","기본 엔터티(키엔터티)"
"38","다음 중 데이터 제어어(DCL)에 해당하는 명령어는?","","1","1","REVOKE"
"38","다음 중 데이터 제어어(DCL)에 해당하는 명령어는?","","1","2","COMMIT"
"38","다음 중 데이터 제어어(DCL)에 해당하는 명령어는?","","1","3","RENAME"
"38","다음 중 데이터 제어어(DCL)에 해당하는 명령어는?","","1","4","INSERT"
"56","개발 프로젝트의 표준은 모든 삭제 데이터에 대한 로그를남가는것을 원칙으로 하고, 테이블 삭제의 경우는 허가된 인력만이 정기적으로 수행 가능하도록 정하고 있다. 개발팀에서 사용 용도가 없다고 판단한 STADIUM 테이블의 데이터를 삭제하는 가장 좋은 방법은 무엇인가?","","4","1","DROP TABLE STADIUM;"
"56","개발 프로젝트의 표준은 모든 삭제 데이터에 대한 로그를남가는것을 원칙으로 하고, 테이블 삭제의 경우는 허가된 인력만이 정기적으로 수행 가능하도록 정하고 있다. 개발팀에서 사용 용도가 없다고 판단한 STADIUM 테이블의 데이터를 삭제하는 가장 좋은 방법은 무엇인가?","","4","2","TRUNCATE TABLE STADIUM;"
"56","개발 프로젝트의 표준은 모든 삭제 데이터에 대한 로그를남가는것을 원칙으로 하고, 테이블 삭제의 경우는 허가된 인력만이 정기적으로 수행 가능하도록 정하고 있다. 개발팀에서 사용 용도가 없다고 판단한 STADIUM 테이블의 데이터를 삭제하는 가장 좋은 방법은 무엇인가?","","4","3","DELETE * FROM STADIUM;"
"56","개발 프로젝트의 표준은 모든 삭제 데이터에 대한 로그를남가는것을 원칙으로 하고, 테이블 삭제의 경우는 허가된 인력만이 정기적으로 수행 가능하도록 정하고 있다. 개발팀에서 사용 용도가 없다고 판단한 STADIUM 테이블의 데이터를 삭제하는 가장 좋은 방법은 무엇인가?","","4","4","DELETE FROM STADIUM;"
"58","다음 중 DELETE 와 TRUNCATE, DROP 명령어에 대해 비교한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,4","1","DROP은 Auto Commit 되고, DELETE와 TRUNCATE는 사용자 Commit으로 수행된다."
"58","다음 중 DELETE 와 TRUNCATE, DROP 명령어에 대해 비교한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,4","2","TRUNCATE 명령어는 UNDO를 위한 데이터를 생성하지 않기 때문에 동일 데이터량 삭제시 DELETE보다 빠르다."
"58","다음 중 DELETE 와 TRUNCATE, DROP 명령어에 대해 비교한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,4","3","DROP 명령어는 테이블 정의 자체를 삭제하고, TRUNCATE 명령어는 테이블을 초기상태로 만든다."
"58","다음 중 DELETE 와 TRUNCATE, DROP 명령어에 대해 비교한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,4","4","특정 테이블에 대하여 WHERE 조건절이 없는 DELETE 명령을 수행하면 DROP TABLE 명령을 수행했을 때와 똑같은 결과를 얻을 수 있다."
"59","데이터베이스 트랜잭션에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,3","1","지속성(durability) : 트랜잭션이 실행 되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다."
"59","데이터베이스 트랜잭션에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,3","2","고립성(isolation) ： 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다."
"59","데이터베이스 트랜잭션에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,3","3","일관성(consistency) ： 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다."
"59","데이터베이스 트랜잭션에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,3","4","원자성(atomicity) ： 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다."
"82","다음 SQL 중 오류가 발생하는 것은?","","2","1","SELECT 지역, SUM(매출금액) AS 매출금액 FROM 지역별매출 GROUP BY 지역 HAVING SUM(매출금액) > 1000 ORDER BY COUNT(*) ASC;"
"82","다음 SQL 중 오류가 발생하는 것은?","","2","2","SELECT 지역, SUM(매출금액) AS 매출금액 FROM 지역별매출 GROUP BY 지역 ORDER BY 년 DESC;"
"82","다음 SQL 중 오류가 발생하는 것은?","","2","3","SELECT 지역, 매출금액 FROM 지역별매출 ORDER BY 년 ASC;"
"82","다음 SQL 중 오류가 발생하는 것은?","","2","4","SELECT 지역, SUM(매출금액) AS 매출금액 FROM 지역별매출 GROUP BY 지역 ORDER BY 매출금액 DESC;"
"115","아래 테이블은 어느 회사의 사원들과 이들이 부양하는 가족에 대한 것으로 밑줄 친 칼럼은 기본키(Primary Key)를 표시한 것이다. 다음 중 '현재 부양하는 가족들이 없는 사원들의 이름을 구하라'는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 내용으로 가장 적절한 것은?","[테이블]
사원 (사번, 이름, 나이)
가족 (이름, 나이, 부양사번)
* 가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래키(Foreign Key) 이다.
[SQL 문장]
SELECT 이름
FROM 사원
WHERE (ㄱ) (SELECT * FROM 가족 WHERE (ㄴ))","2","1","(ㄱ) : NOT EXISTS (ㄴ) : 사번 <> 부양사번"
"115","아래 테이블은 어느 회사의 사원들과 이들이 부양하는 가족에 대한 것으로 밑줄 친 칼럼은 기본키(Primary Key)를 표시한 것이다. 다음 중 '현재 부양하는 가족들이 없는 사원들의 이름을 구하라'는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 내용으로 가장 적절한 것은?","[테이블]
사원 (사번, 이름, 나이)
가족 (이름, 나이, 부양사번)
* 가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래키(Foreign Key) 이다.
[SQL 문장]
SELECT 이름
FROM 사원
WHERE (ㄱ) (SELECT * FROM 가족 WHERE (ㄴ))","2","2","(ㄱ) : NOT EXISTS (ㄴ) : 사번 = 부양사번"
"115","아래 테이블은 어느 회사의 사원들과 이들이 부양하는 가족에 대한 것으로 밑줄 친 칼럼은 기본키(Primary Key)를 표시한 것이다. 다음 중 '현재 부양하는 가족들이 없는 사원들의 이름을 구하라'는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 내용으로 가장 적절한 것은?","[테이블]
사원 (사번, 이름, 나이)
가족 (이름, 나이, 부양사번)
* 가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래키(Foreign Key) 이다.
[SQL 문장]
SELECT 이름
FROM 사원
WHERE (ㄱ) (SELECT * FROM 가족 WHERE (ㄴ))","2","3","(ㄱ) : EXISTS (ㄴ) : 사번 <> 부양사번"
"115","아래 테이블은 어느 회사의 사원들과 이들이 부양하는 가족에 대한 것으로 밑줄 친 칼럼은 기본키(Primary Key)를 표시한 것이다. 다음 중 '현재 부양하는 가족들이 없는 사원들의 이름을 구하라'는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 내용으로 가장 적절한 것은?","[테이블]
사원 (사번, 이름, 나이)
가족 (이름, 나이, 부양사번)
* 가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래키(Foreign Key) 이다.
[SQL 문장]
SELECT 이름
FROM 사원
WHERE (ㄱ) (SELECT * FROM 가족 WHERE (ㄴ))","2","4","(ㄱ) : EXISTS (ㄴ) : 사번 = 부양사번"
"130","다음 중 윈도우 함수 (Window Function, Analytic Function)에 대한 설명으로 가장 부적절한 것은?","","2","1","윈도우 함수 적용 범위는 Partition을 넘을 수 없다."
"130","다음 중 윈도우 함수 (Window Function, Analytic Function)에 대한 설명으로 가장 부적절한 것은?","","2","2","윈도우 함수 처리로 인해 결과 건수가 줄어든다."
"130","다음 중 윈도우 함수 (Window Function, Analytic Function)에 대한 설명으로 가장 부적절한 것은?","","2","3","Partition 구문이 없으면 전체 집합을 하나의 Partition으로 정의한 것과 동일하다."
"130","다음 중 윈도우 함수 (Window Function, Analytic Function)에 대한 설명으로 가장 부적절한 것은?","","2","4","Partition과 Group By 구문은 의미적으로 유사하다."
"137","다음 중 B_User가 아래의 직업을 수행할 수있도록 권한을 부여하는 DCL로 가장 적절한 것은?","UPDATE A_User.TB_A 
SET col1='AAA' 
WHERE col2=3","1","1","GRANT SELECT, UPDATE ON A_User.TB_A TO B_User;"
"137","다음 중 B_User가 아래의 직업을 수행할 수있도록 권한을 부여하는 DCL로 가장 적절한 것은?","UPDATE A_User.TB_A 
SET col1='AAA' 
WHERE col2=3","1","2","DENY UPDATE ON A_User.TB_A TO B_User;"
"137","다음 중 B_User가 아래의 직업을 수행할 수있도록 권한을 부여하는 DCL로 가장 적절한 것은?","UPDATE A_User.TB_A 
SET col1='AAA' 
WHERE col2=3","1","3","REVOKE SELECT ON A_User.TB_A FROM B_User;"
"137","다음 중 B_User가 아래의 직업을 수행할 수있도록 권한을 부여하는 DCL로 가장 적절한 것은?","UPDATE A_User.TB_A 
SET col1='AAA' 
WHERE col2=3","1","4","GRANT SELECT, UPDATE TO B_User;"
"138","사용자 Lee가 릴레이션 R을 생성한 후,이래와 같은 권한부여 SQL문들을 실행하였다. 그 이후에 가능이 실행 가능한 SQL을 2개 고르시오. (단, A, B의 데이터 타입은 정수형이다)","Lee :GRANT SELECT, INSERT, DELETE ON R TO Kim WITH
 GRANT OPTION;
kim :GRANT SELECT, INSERT, DELETE ON R TO Park；
Lee: REVOKE DELETE ON R FROM Kim;
Lee:REVOKE INSERT ON R FROM Kim CASCADE;","2,4","1","Kim : INSERT INTO R VALUES(500, 600);"
"138","사용자 Lee가 릴레이션 R을 생성한 후,이래와 같은 권한부여 SQL문들을 실행하였다. 그 이후에 가능이 실행 가능한 SQL을 2개 고르시오. (단, A, B의 데이터 타입은 정수형이다)","Lee :GRANT SELECT, INSERT, DELETE ON R TO Kim WITH
 GRANT OPTION;
kim :GRANT SELECT, INSERT, DELETE ON R TO Park；
Lee: REVOKE DELETE ON R FROM Kim;
Lee:REVOKE INSERT ON R FROM Kim CASCADE;","2,4","2","Park : DELETE FROM R WHERE B = 800;"
"138","사용자 Lee가 릴레이션 R을 생성한 후,이래와 같은 권한부여 SQL문들을 실행하였다. 그 이후에 가능이 실행 가능한 SQL을 2개 고르시오. (단, A, B의 데이터 타입은 정수형이다)","Lee :GRANT SELECT, INSERT, DELETE ON R TO Kim WITH
 GRANT OPTION;
kim :GRANT SELECT, INSERT, DELETE ON R TO Park；
Lee: REVOKE DELETE ON R FROM Kim;
Lee:REVOKE INSERT ON R FROM Kim CASCADE;","2,4","3","Park : INSERT INTO R VALUES(400, 600);"
"138","사용자 Lee가 릴레이션 R을 생성한 후,이래와 같은 권한부여 SQL문들을 실행하였다. 그 이후에 가능이 실행 가능한 SQL을 2개 고르시오. (단, A, B의 데이터 타입은 정수형이다)","Lee :GRANT SELECT, INSERT, DELETE ON R TO Kim WITH
 GRANT OPTION;
kim :GRANT SELECT, INSERT, DELETE ON R TO Park；
Lee: REVOKE DELETE ON R FROM Kim;
Lee:REVOKE INSERT ON R FROM Kim CASCADE;","2,4","4","Park : SELECT * FROM R WHERE A = 400;"
"146","다음 중 엔터티의 특징에 포함되지 않는 것은?","","2","1","엔터티는 업무 프로세스에 의해 이용되어야 한다."
"146","다음 중 엔터티의 특징에 포함되지 않는 것은?","","2","2","엔터티는 속성이 없어도 된다."
"146","다음 중 엔터티의 특징에 포함되지 않는 것은?","","2","3","유일한 식별자에 의해 식별이 가능해야 한다."
"146","다음 중 엔터티의 특징에 포함되지 않는 것은?","","2","4","반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다."
"150","식별자의 대체 여부에 따라 분류하는 방식은?","","4","1","단일 식별자 - 복합 식별자"
"150","식별자의 대체 여부에 따라 분류하는 방식은?","","4","2","주식별자 - 보조 식별자"
"150","식별자의 대체 여부에 따라 분류하는 방식은?","","4","3","내부 식별자 - 외부 식별자"
"150","식별자의 대체 여부에 따라 분류하는 방식은?","","4","4","본질 식별자 - 인조 식별자"
"169","데이터 모델링이 최종적으로 완료된 상태라고 정의할 수 있는, 즉 물리적인 스키마 설계를 하기 전 단계를 가리키는 말은?","","3","1","개념적 데이터 모델링"
"169","데이터 모델링이 최종적으로 완료된 상태라고 정의할 수 있는, 즉 물리적인 스키마 설계를 하기 전 단계를 가리키는 말은?","","3","2","개괄 데이터 모델링"
"169","데이터 모델링이 최종적으로 완료된 상태라고 정의할 수 있는, 즉 물리적인 스키마 설계를 하기 전 단계를 가리키는 말은?","","3","3","논리적 데이터 모델링"
"169","데이터 모델링이 최종적으로 완료된 상태라고 정의할 수 있는, 즉 물리적인 스키마 설계를 하기 전 단계를 가리키는 말은?","","3","4","물리적 데이터 모델링"
"186","일반적으로 FROM절에 정의된 후 먼저 수행되어 SQL 문장 내에서 절차성을 주는 효과를 볼 수 있는 것은 어떤 유형의 서브쿼리 문장인가?","","3","1","NESTED SUBQUERY"
"186","일반적으로 FROM절에 정의된 후 먼저 수행되어 SQL 문장 내에서 절차성을 주는 효과를 볼 수 있는 것은 어떤 유형의 서브쿼리 문장인가?","","3","2","CORRELATED SUBQUERY"
"186","일반적으로 FROM절에 정의된 후 먼저 수행되어 SQL 문장 내에서 절차성을 주는 효과를 볼 수 있는 것은 어떤 유형의 서브쿼리 문장인가?","","3","3","INLINE VIEW"
"186","일반적으로 FROM절에 정의된 후 먼저 수행되어 SQL 문장 내에서 절차성을 주는 효과를 볼 수 있는 것은 어떤 유형의 서브쿼리 문장인가?","","3","4","SCALAR SUBQUERY"
"188","소계, 중계, 합계처럼 계층적 분류를 포함하고 있는 데이터의 집계에 적합한 GROUP 함수 두 가지는 무엇인가?","","2","1","CUBE, SUM"
"188","소계, 중계, 합계처럼 계층적 분류를 포함하고 있는 데이터의 집계에 적합한 GROUP 함수 두 가지는 무엇인가?","","2","2","ROLLUP, CUBE"
"188","소계, 중계, 합계처럼 계층적 분류를 포함하고 있는 데이터의 집계에 적합한 GROUP 함수 두 가지는 무엇인가?","","2","3","GROUPING, SUM"
"188","소계, 중계, 합계처럼 계층적 분류를 포함하고 있는 데이터의 집계에 적합한 GROUP 함수 두 가지는 무엇인가?","","2","4","ROLLUP, SUM"
"232","ANSI/ISO 표준 SQL에서 두 테이블 간에 동일한 칼럼 이름을 가지는 것을 모두 출력하는 조인 방식은 무엇인가?","","2","1","Using"
"232","ANSI/ISO 표준 SQL에서 두 테이블 간에 동일한 칼럼 이름을 가지는 것을 모두 출력하는 조인 방식은 무엇인가?","","2","2","Natural Join"
"232","ANSI/ISO 표준 SQL에서 두 테이블 간에 동일한 칼럼 이름을 가지는 것을 모두 출력하는 조인 방식은 무엇인가?","","2","3","Cross Join"
"232","ANSI/ISO 표준 SQL에서 두 테이블 간에 동일한 칼럼 이름을 가지는 것을 모두 출력하는 조인 방식은 무엇인가?","","2","4","Inner Join"
"281","다음 중 계층형 쿼리문의 내장 함수가 아닌 것은 무엇인가?","","3","1","CONNECT_BY_ROOT"
"281","다음 중 계층형 쿼리문의 내장 함수가 아닌 것은 무엇인가?","","3","2","SYS_CONNECT_BY_PATH"
"281","다음 중 계층형 쿼리문의 내장 함수가 아닌 것은 무엇인가?","","3","3","TRIM"
"281","다음 중 계층형 쿼리문의 내장 함수가 아닌 것은 무엇인가?","","3","4","LEVEL"
"316","정규화를 수행하지 않고 엔터티에 데이터를 입력할 때 불필요한 데이터를 같이 입력하거나 삭제하면 다른 데이터까지 같이 삭제되는 문제는?","","2","1","연결 함정"
"316","정규화를 수행하지 않고 엔터티에 데이터를 입력할 때 불필요한 데이터를 같이 입력하거나 삭제하면 다른 데이터까지 같이 삭제되는 문제는?","","2","2","이상현상"
"316","정규화를 수행하지 않고 엔터티에 데이터를 입력할 때 불필요한 데이터를 같이 입력하거나 삭제하면 다른 데이터까지 같이 삭제되는 문제는?","","2","3","제2정규화"
"316","정규화를 수행하지 않고 엔터티에 데이터를 입력할 때 불필요한 데이터를 같이 입력하거나 삭제하면 다른 데이터까지 같이 삭제되는 문제는?","","2","4","제3정규화"
"317","다음 중 3차 정규화에 대한 설명으로 가장 올바른 것은?","","1","1","이행함수 종속성을 제거"
"317","다음 중 3차 정규화에 대한 설명으로 가장 올바른 것은?","","1","2","다치종속성을 제거"
"317","다음 중 3차 정규화에 대한 설명으로 가장 올바른 것은?","","1","3","복합 속성으로 구성된 식별자에 대해 부분적인 속성으로도 식별이 되는 부분 종속성을 제거"
"317","다음 중 3차 정규화에 대한 설명으로 가장 올바른 것은?","","1","4","속성의 원자값 제거"
"319","데이터베이스 파티션 기법 중 날짜 및 숫자처럼 연속된 값을 기준으로 만드는 파티션 기법은?","","4","1","Composite Partition"
"319","데이터베이스 파티션 기법 중 날짜 및 숫자처럼 연속된 값을 기준으로 만드는 파티션 기법은?","","4","2","Hash Partition"
"319","데이터베이스 파티션 기법 중 날짜 및 숫자처럼 연속된 값을 기준으로 만드는 파티션 기법은?","","4","3","List Partition"
"319","데이터베이스 파티션 기법 중 날짜 및 숫자처럼 연속된 값을 기준으로 만드는 파티션 기법은?","","4","4","Range Partition"
"320","다음은 데이터베이스 모델링 단계에 대한 설명이다. 올바르지 않은 것은?","","4","1","개념적 모델링 이후에 구체적인 업무 중심의 모델링과 정규화를 수행하는 단계가 논리적 모델링 단계이다."
"320","다음은 데이터베이스 모델링 단계에 대한 설명이다. 올바르지 않은 것은?","","4","2","데이터베이스 모델링 단계는 개념적, 논리적, 물리적 단계로 수행하고 개념적 단계부터 물리적 모델링 진행될수록 상세화된다."
"320","다음은 데이터베이스 모델링 단계에 대한 설명이다. 올바르지 않은 것은?","","4","3","성능, 데이터 저장 방법 등을 고려하는 모델링은 물리적 모델링이다."
"320","다음은 데이터베이스 모델링 단계에 대한 설명이다. 올바르지 않은 것은?","","4","4","개념적 데이터베이스 모델링은 추상화 수준이 낮고 재사용성이 매우 높은 모델링 방법이다."
"325","다음 중 SQL문의 실행 순서로 올바른 것은?","","3","1","FROM -> WHERE -> GROUP BY -> SELECT -> HAVING -> ORDER BY"
"325","다음 중 SQL문의 실행 순서로 올바른 것은?","","3","2","FROM -> WHERE -> HAVING -> GROUP BY -> ORDER BY -> SELECT"
"325","다음 중 SQL문의 실행 순서로 올바른 것은?","","3","3","FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY"
"325","다음 중 SQL문의 실행 순서로 올바른 것은?","","3","4","FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> SELECT"
"330","다음 중 LIKE문에서 세 번째 문자가 'K'인 문자열을 조회하는 것으로 가장 올바른 것은?","","1","1","SELECT * FROM EMP WHERE like '_ _K%'"
"330","다음 중 LIKE문에서 세 번째 문자가 'K'인 문자열을 조회하는 것으로 가장 올바른 것은?","","1","2","SELECT * FROM EMP WHERE like '[_ _K]%'"
"330","다음 중 LIKE문에서 세 번째 문자가 'K'인 문자열을 조회하는 것으로 가장 올바른 것은?","","1","3","SELECT * FROM EMP WHERE like '%K%'"
"330","다음 중 LIKE문에서 세 번째 문자가 'K'인 문자열을 조회하는 것으로 가장 올바른 것은?","","1","4","SELECT * FROM EMP WHERE like 'K%'"
"332","다음 중 세 번째 문자가 'N'인 문자열을 검색하는  조건으로 적절한 것은?","","1","1","SELECT * FROM 테이블명 WHERE like '_ _N%'"
"332","다음 중 세 번째 문자가 'N'인 문자열을 검색하는  조건으로 적절한 것은?","","1","2","SELECT * FROM 테이블명 WHERE like '[_ _N]%'"
"332","다음 중 세 번째 문자가 'N'인 문자열을 검색하는  조건으로 적절한 것은?","","1","3","SELECT * FROM 테이블명 WHERE like '%N%'"
"332","다음 중 세 번째 문자가 'N'인 문자열을 검색하는  조건으로 적절한 것은?","","1","4","SELECT * FROM 테이블명 WHERE like '_N%'"
"340","SQL문을 ANSI 표준 SQL문으로 변환한 것으로 올바른 것은?","SELECT *
FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNMAE ='KIM'","1","1","SELECT * FROM SCOTT.EMP A INNER JOIN SCOTT.DEPT B
ON A.DEPTNO = B.DEPTNO WHERE 1=1
AND B.DNAME = 'KIM';"
"340","SQL문을 ANSI 표준 SQL문으로 변환한 것으로 올바른 것은?","SELECT *
FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNMAE ='KIM'","1","2","SELECT * FROM SCOTT.EMP A INNER JOIN SCOTT.DEPT B
ON (A.DEPTNO = B.DEPTNO 
AND B.DNAME = 'KIM') WHERE 1=1;"
"340","SQL문을 ANSI 표준 SQL문으로 변환한 것으로 올바른 것은?","SELECT *
FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNMAE ='KIM'","1","3","SELECT * FROM SCOTT.EMP A RIGHT OUTER JOIN SCOTT.DEPT B
ON (A.DEPTNO = B.DEPTNO 
AND B.DNAME = 'KIM') WHERE 1=1;"
"340","SQL문을 ANSI 표준 SQL문으로 변환한 것으로 올바른 것은?","SELECT *
FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNMAE ='KIM'","1","4","SELECT * FROM SCOTT.EMP A LEFT OUTER JOIN SCOTT.DEPT B
ON (A.DEPTNO = B.DEPTNO 
AND B.DNAME = 'KIM') ;"
"348","다음은 테이블 생성 시 사용하는 제약조건에 대한 설명이다. 가장 올바르지 않은 것은?","","4","1","NOT NULL : 칼럼에 NULL 값을 입력할 수 없도록 한다. 기본키의 경우 별도로 지정하지 않아도 된다."
"348","다음은 테이블 생성 시 사용하는 제약조건에 대한 설명이다. 가장 올바르지 않은 것은?","","4","2","FOREIGN KEY : 다른 테이블의 기본키를 참조한다."
"348","다음은 테이블 생성 시 사용하는 제약조건에 대한 설명이다. 가장 올바르지 않은 것은?","","4","3","PRIMARY KEY : 기본키로 테이블당 한 개만 생성이 가능하고 자동으로 인덱스가 생성된다."
"348","다음은 테이블 생성 시 사용하는 제약조건에 대한 설명이다. 가장 올바르지 않은 것은?","","4","4","UNIQUE : 칼럼에 중복된 값이 없을 때도 NULL 값은 입력되지 않는다."
"370","아래의 SQL문을 수행한 후 보기의 쿼리문을 실행할 때 잘못된 것은?","CREATE TABLE MYTEST (N1 NUMBER(20), N2 NUMBER(20) );
INSERT INTO MYTEST VALUES(1,100);
INSERT INTO MYTEST VALUES(2,200);
COMMIT;","1","1","SELECT N1 FROM (SELECT * FROM MYTEST) ORDER BY 2;"
"370","아래의 SQL문을 수행한 후 보기의 쿼리문을 실행할 때 잘못된 것은?","CREATE TABLE MYTEST (N1 NUMBER(20), N2 NUMBER(20) );
INSERT INTO MYTEST VALUES(1,100);
INSERT INTO MYTEST VALUES(2,200);
COMMIT;","1","2","SELECT N1 FROM (SELECT * FROM MYTEST) ORDER BY N2;"
"370","아래의 SQL문을 수행한 후 보기의 쿼리문을 실행할 때 잘못된 것은?","CREATE TABLE MYTEST (N1 NUMBER(20), N2 NUMBER(20) );
INSERT INTO MYTEST VALUES(1,100);
INSERT INTO MYTEST VALUES(2,200);
COMMIT;","1","3","SELECT * FROM MYTEST ORDER BY 2;"
"370","아래의 SQL문을 수행한 후 보기의 쿼리문을 실행할 때 잘못된 것은?","CREATE TABLE MYTEST (N1 NUMBER(20), N2 NUMBER(20) );
INSERT INTO MYTEST VALUES(1,100);
INSERT INTO MYTEST VALUES(2,200);
COMMIT;","1","4","SELECT N1 FROM MYTEST ORDER BY N2;"
"395","다음 중 Window Function에 대한 설명으로 알맞은 것은?","","3","1","GROUP BY와 Window Function은 병행하여 사용할 수 있다."
"395","다음 중 Window Function에 대한 설명으로 알맞은 것은?","","3","2","Window Function 처리로 인해 결과 건수가 줄어들 수 있어 성능이 빠르다."
"395","다음 중 Window Function에 대한 설명으로 알맞은 것은?","","3","3","sum, min, max 등과 같은 집계 Window Function을 사용할 때 window 절과 함께 사용하면 집계의 대상이 되는 레코드 범위를 지정할 수 있다."
"395","다음 중 Window Function에 대한 설명으로 알맞은 것은?","","3","4","Window Function은 내부적으로 자동 튜닝을 실시한다."
"416","다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?","","2","1","intersect"
"416","다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?","","2","2","except"
"416","다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?","","2","3","union all"
"416","다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?","","2","4","union"
"423","다음의 SQL문의 실행 결과로 올바른 것은?(단,오늘의 날짜는 2022년 4월 30일이고 시간은 무시)","SELECT SYSDATE,
TO_DATE(SYSDATE,'YYYY')
FROM DUAL;","1","1","에러가 발생한다."
"423","다음의 SQL문의 실행 결과로 올바른 것은?(단,오늘의 날짜는 2022년 4월 30일이고 시간은 무시)","SELECT SYSDATE,
TO_DATE(SYSDATE,'YYYY')
FROM DUAL;","1","2","22 - 04 - 30 00 : 00 : 00 2022"
"423","다음의 SQL문의 실행 결과로 올바른 것은?(단,오늘의 날짜는 2022년 4월 30일이고 시간은 무시)","SELECT SYSDATE,
TO_DATE(SYSDATE,'YYYY')
FROM DUAL;","1","3","2022/04/30 00 : 00 : 00 2022"
"423","다음의 SQL문의 실행 결과로 올바른 것은?(단,오늘의 날짜는 2022년 4월 30일이고 시간은 무시)","SELECT SYSDATE,
TO_DATE(SYSDATE,'YYYY')
FROM DUAL;","1","4","2022 - 04 - 30 00 : 00 : 00 2022"
"424","다음 SQL문 중에서 결괏값이 다른 하나는?","","3","1","SELECT CONCAT('0', '5') FROM DUAL"
"424","다음 SQL문 중에서 결괏값이 다른 하나는?","","3","2","SELECT TRIM('05') FROM DUAL"
"424","다음 SQL문 중에서 결괏값이 다른 하나는?","","3","3","SELECT EXTRACT(MONTH FROM DATE '2022 - 05 - 01') FROM DUAL;"
"424","다음 SQL문 중에서 결괏값이 다른 하나는?","","3","4","SELECT SUBSTR(TO_CHAR ('20220504'), 5,2) FROM DUAL"
"433","다음 보기와 동일한 SQL문은?","SELECT * FROM MYTEST WHERE COL1 BETWEEN :A AND :B","4","1","SELECT * FROM MYTEST
WHERE COL1 <= :A
OR COL1 >= B"
"433","다음 보기와 동일한 SQL문은?","SELECT * FROM MYTEST WHERE COL1 BETWEEN :A AND :B","4","2","SELECT * FROM MYTEST
WHERE COL1 >= :A
OR COL1 <= :B"
"433","다음 보기와 동일한 SQL문은?","SELECT * FROM MYTEST WHERE COL1 BETWEEN :A AND :B","4","3","SELECT * FROM MYTEST
WHERE COL1 <= :A
AND COL1 >= :B"
"433","다음 보기와 동일한 SQL문은?","SELECT * FROM MYTEST WHERE COL1 BETWEEN :A AND :B","4","4","SELECT * FROM MYTEST
WHERE COL1 >= :A
AND COL1 <= :B"
"441","다음의 SQL문을 실행하면 조회되는 칼럼의 헤더명은 무엇인가?","SELECT EMPNO, deptno, SALARY AS ""salary""
FROM Mytest
WHERE EMPNO < 1000;","4","1","EMP, DEPT, SALARY"
"441","다음의 SQL문을 실행하면 조회되는 칼럼의 헤더명은 무엇인가?","SELECT EMPNO, deptno, SALARY AS ""salary""
FROM Mytest
WHERE EMPNO < 1000;","4","2","EMPNO, DEPTNO, SALARY"
"441","다음의 SQL문을 실행하면 조회되는 칼럼의 헤더명은 무엇인가?","SELECT EMPNO, deptno, SALARY AS ""salary""
FROM Mytest
WHERE EMPNO < 1000;","4","3","EMP, DEPT, SAL"
"441","다음의 SQL문을 실행하면 조회되는 칼럼의 헤더명은 무엇인가?","SELECT EMPNO, deptno, SALARY AS ""salary""
FROM Mytest
WHERE EMPNO < 1000;","4","4","EMPNO, DEPTNO, salary"
"483","다음 중 데이터베이스 논리 모델에 대한 설명으로 올바르지 않은 것은?","","2","1","데이터가 물리적으로 저장되는 방법을 정의하는 것이 물리적 모델이다."
"483","다음 중 데이터베이스 논리 모델에 대한 설명으로 올바르지 않은 것은?","","2","2","논리 모델은 데이터베이스 구축을 위해서만 사용되는 것이다."
"483","다음 중 데이터베이스 논리 모델에 대한 설명으로 올바르지 않은 것은?","","2","3","논리 데이터 모델은 M:N 관계형 식별자 확정, 정규화, 무결성 정의 등을 수행한다."
"483","다음 중 데이터베이스 논리 모델에 대한 설명으로 올바르지 않은 것은?","","2","4","개념 데이터 모델은 사용자 관점에서 데이터 요구사항을 식별한다."
"511","주어진 테이블 test32에는 COL1과 COL2칼럼이 있다. 아래의 SQL문을 실행한 결과로 올바른 것은? (ㄱ은 COUNT(COL1)의 결괏값을, ㄴ과 ㄷ은 출력되는 결과의 행의 수를 고르시오.)","insert into test32 values (null,10);
insert into test32 values (12,null);
insert into test32 values (null,null);
insert into test32 values (10,12);

ㄱ. SELECT COUNT(COL1) FROM test32;
ㄴ. SELECT * FROM test32 WHERE COL1 IN (12,10,null);
ㄷ. SELECT COL1, COUNT(*) FROM test32 GROUP BY COL1;","2","1","4,2,3"
"511","주어진 테이블 test32에는 COL1과 COL2칼럼이 있다. 아래의 SQL문을 실행한 결과로 올바른 것은? (ㄱ은 COUNT(COL1)의 결괏값을, ㄴ과 ㄷ은 출력되는 결과의 행의 수를 고르시오.)","insert into test32 values (null,10);
insert into test32 values (12,null);
insert into test32 values (null,null);
insert into test32 values (10,12);

ㄱ. SELECT COUNT(COL1) FROM test32;
ㄴ. SELECT * FROM test32 WHERE COL1 IN (12,10,null);
ㄷ. SELECT COL1, COUNT(*) FROM test32 GROUP BY COL1;","2","2","2,2,3"
"511","주어진 테이블 test32에는 COL1과 COL2칼럼이 있다. 아래의 SQL문을 실행한 결과로 올바른 것은? (ㄱ은 COUNT(COL1)의 결괏값을, ㄴ과 ㄷ은 출력되는 결과의 행의 수를 고르시오.)","insert into test32 values (null,10);
insert into test32 values (12,null);
insert into test32 values (null,null);
insert into test32 values (10,12);

ㄱ. SELECT COUNT(COL1) FROM test32;
ㄴ. SELECT * FROM test32 WHERE COL1 IN (12,10,null);
ㄷ. SELECT COL1, COUNT(*) FROM test32 GROUP BY COL1;","2","3","2,1,3"
"511","주어진 테이블 test32에는 COL1과 COL2칼럼이 있다. 아래의 SQL문을 실행한 결과로 올바른 것은? (ㄱ은 COUNT(COL1)의 결괏값을, ㄴ과 ㄷ은 출력되는 결과의 행의 수를 고르시오.)","insert into test32 values (null,10);
insert into test32 values (12,null);
insert into test32 values (null,null);
insert into test32 values (10,12);

ㄱ. SELECT COUNT(COL1) FROM test32;
ㄴ. SELECT * FROM test32 WHERE COL1 IN (12,10,null);
ㄷ. SELECT COL1, COUNT(*) FROM test32 GROUP BY COL1;","2","4","2,3,4"
"514","다음 중 NUMERIC(숫자) 형이 아닌 하나는?","","3","1","DECIMAL"
"514","다음 중 NUMERIC(숫자) 형이 아닌 하나는?","","3","2","FLOAT"
"514","다음 중 NUMERIC(숫자) 형이 아닌 하나는?","","3","3","CHAR"
"514","다음 중 NUMERIC(숫자) 형이 아닌 하나는?","","3","4","INT"
"530","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로 가장 적절한 것은?","가. 쇼핑몰 사이트에서는 회원번호가 쇼핑몰 사이트를 운영할 때 자주 이용되는 속성이므로 주식별자로 지정한다.
나. 엔터티 내에서 고객 리스트, 상품 리스트 등과 같은 것을 주식별자로 지정한다.
다. 주식별자로 지정할 때 자주 변경되는 속성을 지정한다.
라. 여러 개의 속성으로 구성된 복합 속성의 경우 주식별자에 너무 많은 속성이 포함되지 않게 한다.","3","1","가,다"
"530","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로 가장 적절한 것은?","가. 쇼핑몰 사이트에서는 회원번호가 쇼핑몰 사이트를 운영할 때 자주 이용되는 속성이므로 주식별자로 지정한다.
나. 엔터티 내에서 고객 리스트, 상품 리스트 등과 같은 것을 주식별자로 지정한다.
다. 주식별자로 지정할 때 자주 변경되는 속성을 지정한다.
라. 여러 개의 속성으로 구성된 복합 속성의 경우 주식별자에 너무 많은 속성이 포함되지 않게 한다.","3","2","나,라"
"530","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로 가장 적절한 것은?","가. 쇼핑몰 사이트에서는 회원번호가 쇼핑몰 사이트를 운영할 때 자주 이용되는 속성이므로 주식별자로 지정한다.
나. 엔터티 내에서 고객 리스트, 상품 리스트 등과 같은 것을 주식별자로 지정한다.
다. 주식별자로 지정할 때 자주 변경되는 속성을 지정한다.
라. 여러 개의 속성으로 구성된 복합 속성의 경우 주식별자에 너무 많은 속성이 포함되지 않게 한다.","3","3","가,라"
"530","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로 가장 적절한 것은?","가. 쇼핑몰 사이트에서는 회원번호가 쇼핑몰 사이트를 운영할 때 자주 이용되는 속성이므로 주식별자로 지정한다.
나. 엔터티 내에서 고객 리스트, 상품 리스트 등과 같은 것을 주식별자로 지정한다.
다. 주식별자로 지정할 때 자주 변경되는 속성을 지정한다.
라. 여러 개의 속성으로 구성된 복합 속성의 경우 주식별자에 너무 많은 속성이 포함되지 않게 한다.","3","4","가,나"
"554","주어진 SQL문에서 ORDER BY로 사용할 수 없는 것은?","SELECT JOB, COUNT(*) AS ROWCNT
FROM TEST40
GROUP BY JOB;","1","1","ORDER BY 3"
"554","주어진 SQL문에서 ORDER BY로 사용할 수 없는 것은?","SELECT JOB, COUNT(*) AS ROWCNT
FROM TEST40
GROUP BY JOB;","1","2","ORDER BY COUNT(*)"
"554","주어진 SQL문에서 ORDER BY로 사용할 수 없는 것은?","SELECT JOB, COUNT(*) AS ROWCNT
FROM TEST40
GROUP BY JOB;","1","3","ORDER BY CNT DESC"
"554","주어진 SQL문에서 ORDER BY로 사용할 수 없는 것은?","SELECT JOB, COUNT(*) AS ROWCNT
FROM TEST40
GROUP BY JOB;","1","4","ORDER BY JOB"
"566","VIew의 개념 및 정의 중 틀린 것을 고르시오.","","3","1","뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다."
"566","VIew의 개념 및 정의 중 틀린 것을 고르시오.","","3","2","뷰는 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주된다."
"566","VIew의 개념 및 정의 중 틀린 것을 고르시오.","","3","3","뷰는 데이터 보정작업, 처리과정 시험 등 영구적인 작업을 위한 용도로 활용된다."
"566","VIew의 개념 및 정의 중 틀린 것을 고르시오.","","3","4","뷰는 조인문의 사용 최소화로 사용상의 편의성을 최대화 한다."
"571","다음은 어떤 데이터 모델링에 대한 설명인가?","추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링","1","1","개념적 데이터 모델링"
"571","다음은 어떤 데이터 모델링에 대한 설명인가?","추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링","1","2","개괄적 데이터 모델링"
"571","다음은 어떤 데이터 모델링에 대한 설명인가?","추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링","1","3","물리적 데이터 모델링"
"571","다음은 어떤 데이터 모델링에 대한 설명인가?","추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링","1","4","논리적 데이터 모델링"
"577","관계에 대한 설명으로 가장 적절하지 않은 것은?","회원은 반드시 개인회원 또는 법인회원으로 회원가입을 한다. 
회원 가입 후 개인회원 또는 법인회원으로 로그인하여 서비스를 이용할 수 있다. ","1","1","개인회원 또는 법인회원 둘 중 하나로 주문 가능할 경우 고객과 주문 엔터티는 상호포함적 관계이다."
"577","관계에 대한 설명으로 가장 적절하지 않은 것은?","회원은 반드시 개인회원 또는 법인회원으로 회원가입을 한다. 
회원 가입 후 개인회원 또는 법인회원으로 로그인하여 서비스를 이용할 수 있다. ","1","2","고객과 주문내역 엔터티 간의 '주문' 관계는 행위에 의한 관계이다. "
"577","관계에 대한 설명으로 가장 적절하지 않은 것은?","회원은 반드시 개인회원 또는 법인회원으로 회원가입을 한다. 
회원 가입 후 개인회원 또는 법인회원으로 로그인하여 서비스를 이용할 수 있다. ","1","3","부서와 사원 엔터티 간의 '소속' 관계는 존재적 관계이다"
"577","관계에 대한 설명으로 가장 적절하지 않은 것은?","회원은 반드시 개인회원 또는 법인회원으로 회원가입을 한다. 
회원 가입 후 개인회원 또는 법인회원으로 로그인하여 서비스를 이용할 수 있다. ","1","4","관계는 존재적 관계와 행위에 의한 관계로 나누어 볼 수 있다. "
"581","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","2","1","SELECT절에 DISTINCT는 항상 SELECT 바로 뒤에 위치한다."
"581","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","2","2","FROM 절은 모든 DBMS에서 생략 가능하다. "
"581","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","2","3","ORDER BY절은 문법 순서도 맨 마지막에 위치하며, 실행 순서 역시 마지막이다. "
"581","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","2","4","오라클에서는 GROUP BY절 위에 HAVING절을 명시할 수 있다."
"614","다음 출력 결과로 가장 알맞은 것은? ","SELECT REGEXP_COUNT('abc1004 zz1234', '\d{2}+') AS C1, REGEXP_COUNT('abc1004-zz1234-100', '\d{2,}+') AS C2 
 FROM DUAL;","3","1","8,3"
"614","다음 출력 결과로 가장 알맞은 것은? ","SELECT REGEXP_COUNT('abc1004 zz1234', '\d{2}+') AS C1, REGEXP_COUNT('abc1004-zz1234-100', '\d{2,}+') AS C2 
 FROM DUAL;","3","2","8,1"
"614","다음 출력 결과로 가장 알맞은 것은? ","SELECT REGEXP_COUNT('abc1004 zz1234', '\d{2}+') AS C1, REGEXP_COUNT('abc1004-zz1234-100', '\d{2,}+') AS C2 
 FROM DUAL;","3","3","2,3"
"614","다음 출력 결과로 가장 알맞은 것은? ","SELECT REGEXP_COUNT('abc1004 zz1234', '\d{2}+') AS C1, REGEXP_COUNT('abc1004-zz1234-100', '\d{2,}+') AS C2 
 FROM DUAL;","3","4","2,1"
"623","속성에 대한 설명으로 가장 적절하지 않은 것은?","","2","1","속성은 정해진 주식별자에 함수적 종속성을 가져야 한다."
"623","속성에 대한 설명으로 가장 적절하지 않은 것은?","","2","2","하나의 인스턴스에서 각각의 속성은 하나 이상의 속성값을 가질 수 있다."
"623","속성에 대한 설명으로 가장 적절하지 않은 것은?","","2","3","하나의 엔터티는 두 개 이상의 속성을 갖는다."
"623","속성에 대한 설명으로 가장 적절하지 않은 것은?","","2","4","업무상 인스턴스로 관리하고자 하는 더 이상 분리되지 않는 최소 데이터 단위를 나타낸다."
"658","부서내에서의 급여의 비율을 출력하는 구문으로 가장 적절하지 않은 것은? ","","1","1","SELECT ENAME, SAL, DEPTNO, 
         ROUND(PERCENT_RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL) * 100, 2) AS SAL_RATIO 
    FROM EMP E1 
   ORDER BY DEPTNO, SAL DESC;"
"658","부서내에서의 급여의 비율을 출력하는 구문으로 가장 적절하지 않은 것은? ","","1","2","SELECT E1.ENAME, E1.SAL, E1.DEPTNO, 
         ROUND(E1.SAL/I.SUM_SAL * 100, 2) AS SAL_RATIO 
    FROM EMP E1, (SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
                    FROM EMP  
                   GROUP BY DEPTNO) I 
   WHERE E1.DEPTNO = I.DEPTNO                 
   ORDER BY DEPTNO, SAL DESC;"
"658","부서내에서의 급여의 비율을 출력하는 구문으로 가장 적절하지 않은 것은? ","","1","3","SELECT ENAME, SAL, DEPTNO, 
         ROUND(RATIO_TO_REPORT(SAL) OVER(PARTITION BY DEPTNO) * 100, 2) AS SAL_RATIO 
    FROM EMP E1 
   ORDER BY DEPTNO, SAL DESC;"
"658","부서내에서의 급여의 비율을 출력하는 구문으로 가장 적절하지 않은 것은? ","","1","4","SELECT ENAME, SAL, DEPTNO, 
           ROUND(SAL/(SELECT SUM(SAL)  
FROM EMP E2  
WHERE E1.DEPTNO = E2.DEPTNO) * 100, 2) AS SAL_RATIO 
    FROM EMP E1 
   ORDER BY DEPTNO, SAL DESC;"
"665","다음 SQL중 입력오류가 발생할 문장으로 가장 적절한 것은?","CREATE TABLE TAB1( 
COL1    VARCHAR(10) PRIMARY KEY, 
COL2 NUMBER NOT NULL,    
COL3 CHAR(10) NOT NULL,     
COL4   DATE NOT NULL);  ","1","1","INSERT INTO TAB1 VALUES('0003', 40, 'CCC', '2024/01/01');"
"665","다음 SQL중 입력오류가 발생할 문장으로 가장 적절한 것은?","CREATE TABLE TAB1( 
COL1    VARCHAR(10) PRIMARY KEY, 
COL2 NUMBER NOT NULL,    
COL3 CHAR(10) NOT NULL,     
COL4   DATE NOT NULL);  ","1","2","INSERT INTO TAB1 VALUES('0002', '30', '1000', CURRENT_DATE);"
"665","다음 SQL중 입력오류가 발생할 문장으로 가장 적절한 것은?","CREATE TABLE TAB1( 
COL1    VARCHAR(10) PRIMARY KEY, 
COL2 NUMBER NOT NULL,    
COL3 CHAR(10) NOT NULL,     
COL4   DATE NOT NULL);  ","1","3","INSERT INTO TAB1 VALUES('0001', '20', 'BBB', SYSTIMESTAMP);"
"665","다음 SQL중 입력오류가 발생할 문장으로 가장 적절한 것은?","CREATE TABLE TAB1( 
COL1    VARCHAR(10) PRIMARY KEY, 
COL2 NUMBER NOT NULL,    
COL3 CHAR(10) NOT NULL,     
COL4   DATE NOT NULL);  ","1","4","INSERT INTO TAB1 VALUES(1, 10, 'AAA', SYSDATE);"
"688","다음 SQL중 실행 결과가 다른 하나는?","","3","1","SELECT CASE DEPTNO WHEN 10 THEN CASE WHEN JOB = 'CLERK' THEN 'A' ELSE 'B' END 
                          WHEN 20 THEN 'C' ELSE 'D'  
            END FROM EMP;"
"688","다음 SQL중 실행 결과가 다른 하나는?","","3","2","SELECT CASE WHEN DEPTNO = 10 THEN CASE WHEN JOB = 'CLERK' THEN 'A' ELSE 'B' END 
                 WHEN DEPTNO = 20 THEN 'C' ELSE 'D'  
            END FROM EMP; "
"688","다음 SQL중 실행 결과가 다른 하나는?","","3","3","SELECT CASE WHEN (DEPTNO = 10 AND JOB = 'CLERK') THEN 'A' ELSE 'B' 
                 WHEN DEPTNO = 20 THEN 'C' ELSE 'D'  
            END FROM EMP;"
"688","다음 SQL중 실행 결과가 다른 하나는?","","3","4","SELECT DECODE(DEPTNO, 10, DECODE(JOB, 'CLERK', 'A', 'B'), 20, 'C', 'D') 
    FROM EMP;"
"704","다음 집합 연산자에 대한 설명 중 틀린 것은 무엇인가? (단, DBMS는 오라클)  ","","3","1","MINUS 연산자는 조회 결과에 대한 차집합을 의미한다."
"704","다음 집합 연산자에 대한 설명 중 틀린 것은 무엇인가? (단, DBMS는 오라클)  ","","3","2","INTERSECT 연산자는 조회 결과에 대한 교집합을 의미한다. "
"704","다음 집합 연산자에 대한 설명 중 틀린 것은 무엇인가? (단, DBMS는 오라클)  ","","3","3","UNION ALL 연산자는 조회 결과를 정렬하고 중복되는 데이터를 한 번만 표현한다."
"704","다음 집합 연산자에 대한 설명 중 틀린 것은 무엇인가? (단, DBMS는 오라클)  ","","3","4","UNION 연산자는 조회 결과에 대한 합집합을 나타내며 정렬된 결과를 출력해준다."
"705","아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은? ","SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY DEPTNO 
UNION ALL 
SELECT NULL DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP; 
SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY _______________; ","4","1","ROLLUP(DEPTNO, ())"
"705","아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은? ","SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY DEPTNO 
UNION ALL 
SELECT NULL DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP; 
SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY _______________; ","4","2","ROLLUP(DEPTNO, SAL)"
"705","아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은? ","SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY DEPTNO 
UNION ALL 
SELECT NULL DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP; 
SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY _______________; ","4","3","ROLLUP(SAL)"
"705","아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은? ","SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY DEPTNO 
UNION ALL 
SELECT NULL DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP; 
SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY _______________; ","4","4","ROLLUP(DEPTNO)"
"727","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?","","3","1","행위 관계는 엔터티 간의 어떤 행위가 있는 것을 의미한다."
"727","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?","","3","2","관계를 맺는 엔터티를 다시 연결하는 과정을 조인이라고 한다."
"727","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?","","3","3","정규화를 거쳐 분리된 엔터티는 서로 관계를 맺지 않아도 된다."
"727","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?","","3","4","관계란 엔터티의 인스턴스 사이의 논리적인 연관성을 의미한다."
"754","아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은?","","2","1","CUBE(DEPTNO, JOB)"
"754","아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은?","","2","2","GROUPING SETS(DEPTNO, JOB, NULL)"
"754","아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은?","","2","3","GROUPING SETS(DEPTNO, JOB)"
"754","아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은?","","2","4","ROLLUP(DEPTNO, JOB)"
"773","다음 중 단일 속성이 아닌 것은?","","1","1","주소"
"773","다음 중 단일 속성이 아닌 것은?","","1","2","핸드폰번호"
"773","다음 중 단일 속성이 아닌 것은?","","1","3","성별"
"773","다음 중 단일 속성이 아닌 것은?","","1","4","이름"
"775","다음 중 주식별자의 특징이 아닌 것은?","","1","1","종속성"
"775","다음 중 주식별자의 특징이 아닌 것은?","","1","2","불변성"
"775","다음 중 주식별자의 특징이 아닌 것은?","","1","3","최소성"
"775","다음 중 주식별자의 특징이 아닌 것은?","","1","4","유일성"
"779","다음 중 NULL만으로 구성된 컬럼을 계산하여 NULL이 리턴되지 않는 함수는?","","4","1","MIN"
"779","다음 중 NULL만으로 구성된 컬럼을 계산하여 NULL이 리턴되지 않는 함수는?","","4","2","AVG"
"779","다음 중 NULL만으로 구성된 컬럼을 계산하여 NULL이 리턴되지 않는 함수는?","","4","3","SUM"
"779","다음 중 NULL만으로 구성된 컬럼을 계산하여 NULL이 리턴되지 않는 함수는?","","4","4","COUNT"
"783","다음 중 SQL 분류로 적절하지 않은 것은?","","2","1","DML - UPDATE "
"783","다음 중 SQL 분류로 적절하지 않은 것은?","","2","2","DCL - COMMIT"
"783","다음 중 SQL 분류로 적절하지 않은 것은?","","2","3","TCL - ROLLBACK"
"783","다음 중 SQL 분류로 적절하지 않은 것은?","","2","4","DDL - ALTER"
"793","ORDER BY에 대한 설명으로 가장 적절한 것은?","","4","1","ORDER BY 절에는 컬럼명과 숫자를 동시에 사용할 수 없다."
"793","ORDER BY에 대한 설명으로 가장 적절한 것은?","","4","2","ORDER BY 절에는 컬럼 별칭을 사용할 수 없다."
"793","ORDER BY에 대한 설명으로 가장 적절한 것은?","","4","3","ORDER BY 절의 기본 정렬 순서는 내림차순이다."
"793","ORDER BY에 대한 설명으로 가장 적절한 것은?","","4","4","ORDER BY 절을 사용하지 않으면 입력된 데이터의 순서대로 출력된다."
"245","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","SELECT JOB, ENAME, SAL,
RANK() OVER(ORDER BY SAL DESC)
ALL_RANK,
RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK 
FROM EMP;","2","1","PARTITION문을 사용해서 해당 파티션 내에서 순위를 계산한다."
"245","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","SELECT JOB, ENAME, SAL,
RANK() OVER(ORDER BY SAL DESC)
ALL_RANK,
RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK 
FROM EMP;","2","2","RANK() 함수를 사용했으므로 급여가 동일한 사람이 있다면, 조회 순서에 따라서 1등과 2등으로 표시된다."
"245","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","SELECT JOB, ENAME, SAL,
RANK() OVER(ORDER BY SAL DESC)
ALL_RANK,
RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK 
FROM EMP;","2","3","JOB별로 SAL이 큰 등수가 조회된다."
"245","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","SELECT JOB, ENAME, SAL,
RANK() OVER(ORDER BY SAL DESC)
ALL_RANK,
RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK 
FROM EMP;","2","4","SAL칼럼은 급여가 큰 순으로 조회된다."
"246","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","SELECT ENAME,SAL, NTILE(4) OVER (ORDER BY SAL DESC) as DATA
FROM EMP;","4","1","SAL의 마지막 행은 급여가 가장 작은 사람이다."
"246","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","SELECT ENAME,SAL, NTILE(4) OVER (ORDER BY SAL DESC) as DATA
FROM EMP;","4","2","SAL의 값에 따라서 데이터를 4등분으로 분류해서 DATA 필드로 조회된다."
"246","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","SELECT ENAME,SAL, NTILE(4) OVER (ORDER BY SAL DESC) as DATA
FROM EMP;","4","3","SAL이 큰 순으로 조회된다."
"246","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","SELECT ENAME,SAL, NTILE(4) OVER (ORDER BY SAL DESC) as DATA
FROM EMP;","4","4","DATA 필드가 가질 수 있는 값의 범위는 0~3까지이다."
"251","도서(도서번호, 도서제목, 출판사명, 발행연도) 테이블에서, 2000년 이후에 10권 이상의 책을 발행한 출판사의 이름을 중복 없이 출력하는 SQL문으로 옳은 것은?(단, 출판사명이 동일한 출판사는 존재하지 않는 것으로 가정한다. 도서번호는 도서 테이블의 기본키이다)","","1","1","SELECT 출판사명 FROM 도서
WHERE 발행연도 >= 2000
GROUP BY 출판사명
HAVING  COUNT(도서번호) >= 10;"
"251","도서(도서번호, 도서제목, 출판사명, 발행연도) 테이블에서, 2000년 이후에 10권 이상의 책을 발행한 출판사의 이름을 중복 없이 출력하는 SQL문으로 옳은 것은?(단, 출판사명이 동일한 출판사는 존재하지 않는 것으로 가정한다. 도서번호는 도서 테이블의 기본키이다)","","1","2","SELECT 출판사명 FROM 도서
WHERE COUNT(도서번호) >= 10
GROUP BY 출판사명
HAVING  발행연도 >= 2000;"
"251","도서(도서번호, 도서제목, 출판사명, 발행연도) 테이블에서, 2000년 이후에 10권 이상의 책을 발행한 출판사의 이름을 중복 없이 출력하는 SQL문으로 옳은 것은?(단, 출판사명이 동일한 출판사는 존재하지 않는 것으로 가정한다. 도서번호는 도서 테이블의 기본키이다)","","1","3","SELECT 출판사명 FROM 도서
WHERE 발행연도 >= 2000
AND  COUNT(도서번호) >= 10
GROUP BY 출판사명;"
"251","도서(도서번호, 도서제목, 출판사명, 발행연도) 테이블에서, 2000년 이후에 10권 이상의 책을 발행한 출판사의 이름을 중복 없이 출력하는 SQL문으로 옳은 것은?(단, 출판사명이 동일한 출판사는 존재하지 않는 것으로 가정한다. 도서번호는 도서 테이블의 기본키이다)","","1","4","SELECT 출판사명 FROM 도서
WHERE 발행연도 >= 2000
ORDER BY  COUNT(도서번호) >= 10;"
"252","다음의 NOT EXISTS 구문을 동일한 결과가 출력되게 SQL문을 변경하시오.","SELECT ... FROM 급여이력 S
WHERE NOT EXISTS
(SELECT 'X' FROM 사원 P
WHERE P.사원번호 = S.사원번호)

[SQL문]
SELECT .... FROM 급여이력 S
LEFT OUTER JOIN 사원 P
ON(S.사원번호=P.사원번호) WHERE (         );","1","1","P.사원번호 IS NULL"
"252","다음의 NOT EXISTS 구문을 동일한 결과가 출력되게 SQL문을 변경하시오.","SELECT ... FROM 급여이력 S
WHERE NOT EXISTS
(SELECT 'X' FROM 사원 P
WHERE P.사원번호 = S.사원번호)

[SQL문]
SELECT .... FROM 급여이력 S
LEFT OUTER JOIN 사원 P
ON(S.사원번호=P.사원번호) WHERE (         );","1","2","P.사원번호 IS NOT NULL"
"252","다음의 NOT EXISTS 구문을 동일한 결과가 출력되게 SQL문을 변경하시오.","SELECT ... FROM 급여이력 S
WHERE NOT EXISTS
(SELECT 'X' FROM 사원 P
WHERE P.사원번호 = S.사원번호)

[SQL문]
SELECT .... FROM 급여이력 S
LEFT OUTER JOIN 사원 P
ON(S.사원번호=P.사원번호) WHERE (         );","1","3","P.사원번호 > 0"
"252","다음의 NOT EXISTS 구문을 동일한 결과가 출력되게 SQL문을 변경하시오.","SELECT ... FROM 급여이력 S
WHERE NOT EXISTS
(SELECT 'X' FROM 사원 P
WHERE P.사원번호 = S.사원번호)

[SQL문]
SELECT .... FROM 급여이력 S
LEFT OUTER JOIN 사원 P
ON(S.사원번호=P.사원번호) WHERE (         );","1","4","P.사원번호 = NULL"
"259","학생(STUDENT) 테이블에 영문학과 학생 50명, 법학과 학생 100명, 수학과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과 튜플 수는 각각 얼마인가? (단, DEPT필드는 학과명, NAME필드는 이름을 의미한다)","ㄱ : SELECT DEPT FROM SUDENT;
ㄴ : SELECT DISTINCT DEPT
       FROM STUDENT;
ㄷ : SELECT NAME FROM STUDENT 
       WHERE DEPT = '영문학과';","2","1","ㄱ:200, ㄴ:200, ㄷ:50"
"259","학생(STUDENT) 테이블에 영문학과 학생 50명, 법학과 학생 100명, 수학과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과 튜플 수는 각각 얼마인가? (단, DEPT필드는 학과명, NAME필드는 이름을 의미한다)","ㄱ : SELECT DEPT FROM SUDENT;
ㄴ : SELECT DISTINCT DEPT
       FROM STUDENT;
ㄷ : SELECT NAME FROM STUDENT 
       WHERE DEPT = '영문학과';","2","2","ㄱ:200, ㄴ:3, ㄷ:50"
"259","학생(STUDENT) 테이블에 영문학과 학생 50명, 법학과 학생 100명, 수학과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과 튜플 수는 각각 얼마인가? (단, DEPT필드는 학과명, NAME필드는 이름을 의미한다)","ㄱ : SELECT DEPT FROM SUDENT;
ㄴ : SELECT DISTINCT DEPT
       FROM STUDENT;
ㄷ : SELECT NAME FROM STUDENT 
       WHERE DEPT = '영문학과';","2","3","ㄱ:200, ㄴ:3, ㄷ:1"
"259","학생(STUDENT) 테이블에 영문학과 학생 50명, 법학과 학생 100명, 수학과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과 튜플 수는 각각 얼마인가? (단, DEPT필드는 학과명, NAME필드는 이름을 의미한다)","ㄱ : SELECT DEPT FROM SUDENT;
ㄴ : SELECT DISTINCT DEPT
       FROM STUDENT;
ㄷ : SELECT NAME FROM STUDENT 
       WHERE DEPT = '영문학과';","2","4","ㄱ:3, ㄴ:3, ㄷ:1"
"265","다음은 분리되어 네트워크로 연결된 분산 데이터베이스에 대한 설명이다. 올바르지 않은 것은?","","2","1","장애 시에 다른 데이터베이스가 서비스하게 하여 가용성이 좋아진다."
"265","다음은 분리되어 네트워크로 연결된 분산 데이터베이스에 대한 설명이다. 올바르지 않은 것은?","","2","2","보안 통제가 쉽고 비용이 절감된다."
"265","다음은 분리되어 네트워크로 연결된 분산 데이터베이스에 대한 설명이다. 올바르지 않은 것은?","","2","3","여러 개의 데이터베이스가 존재하므로 관리하기가 어렵다. "
"265","다음은 분리되어 네트워크로 연결된 분산 데이터베이스에 대한 설명이다. 올바르지 않은 것은?","","2","4","지역 데이터베이스에서 사용자 Query를 실행하고 빠르게 응답할 수 있다."
"802","개념적 데이터 모델링에서 주로 사용되는 모델은 무엇인가?","","2","1","관계형 모델"
"802","개념적 데이터 모델링에서 주로 사용되는 모델은 무엇인가?","","2","2","ER 모델"
"802","개념적 데이터 모델링에서 주로 사용되는 모델은 무엇인가?","","2","3","계층형 모델"
"802","개념적 데이터 모델링에서 주로 사용되는 모델은 무엇인가?","","2","4","네트워크 모델"
"817","비즈니스 룰(Business Rule)의 역할은?","","3","1","하드웨어 선택 기준 제공"
"817","비즈니스 룰(Business Rule)의 역할은?","","3","2","UI 설계 기준"
"817","비즈니스 룰(Business Rule)의 역할은?","","3","3","데이터 모델 작성 기준 제공"
"817","비즈니스 룰(Business Rule)의 역할은?","","3","4","서버 트래픽 분석"
"8","다음 중 ERD에 대한 설명으로 가장 부적절한 것은?","","1","1","가장 중요한 엔터티를 오른쪽 상단에 배치하고 추가 발생되는 엔터티들을 왼쪽 편과 하단에 배치하는 것이 원칙이다."
"8","다음 중 ERD에 대한 설명으로 가장 부적절한 것은?","","1","2","관계의 명칭은 관계 표현에 있어서 매우 중요한 부분에 해당한다."
"8","다음 중 ERD에 대한 설명으로 가장 부적절한 것은?","","1","3","일반적으로 ERD를 작성하는 방법은 엔터티 도출 -> 엔터티 배치 -> 관계 설정 -> 관계명 기술의 흐름으로 작업을 진행한다."
"8","다음 중 ERD에 대한 설명으로 가장 부적절한 것은?","","1","4","1976년 피터첸(Peter Chen)에 의해 Entity-Relationship Model(E-R Model) 이라는 표기법이 만들어졌다."
"15","다음 중 아래와 같은 사례에서 속성에 대한 설명으로 가장 부적절한 것은?","우리은행은 예금분류(일반예금, 특별예금 등)의 원금, 예치기간, 이자율을 관리할 필요가 있다. 또한 원금에 대한 이자율을 적용하여 계산된 이자에 대해서도 속성으로 관리하고자 한다. 예를 들어 원금이 1000원이고 예치기간이 5개월이며 이자율이 5.0%라는 속성을 관리하고 계산된 이자도 관리한다. 일반예금이나 특별예금 등에 대해서는 코드를 부여(예. 01-일반예금, 02-특별예금 등)하여 관리한다.","2","1","예금분류는 설계(DESIGNED)속성이다."
"15","다음 중 아래와 같은 사례에서 속성에 대한 설명으로 가장 부적절한 것은?","우리은행은 예금분류(일반예금, 특별예금 등)의 원금, 예치기간, 이자율을 관리할 필요가 있다. 또한 원금에 대한 이자율을 적용하여 계산된 이자에 대해서도 속성으로 관리하고자 한다. 예를 들어 원금이 1000원이고 예치기간이 5개월이며 이자율이 5.0%라는 속성을 관리하고 계산된 이자도 관리한다. 일반예금이나 특별예금 등에 대해서는 코드를 부여(예. 01-일반예금, 02-특별예금 등)하여 관리한다.","2","2","이자와 이자율은 파생(DERIVED)속성이다."
"15","다음 중 아래와 같은 사례에서 속성에 대한 설명으로 가장 부적절한 것은?","우리은행은 예금분류(일반예금, 특별예금 등)의 원금, 예치기간, 이자율을 관리할 필요가 있다. 또한 원금에 대한 이자율을 적용하여 계산된 이자에 대해서도 속성으로 관리하고자 한다. 예를 들어 원금이 1000원이고 예치기간이 5개월이며 이자율이 5.0%라는 속성을 관리하고 계산된 이자도 관리한다. 일반예금이나 특별예금 등에 대해서는 코드를 부여(예. 01-일반예금, 02-특별예금 등)하여 관리한다.","2","3","원금, 예치기간은 기본(BASIC)속성이다."
"15","다음 중 아래와 같은 사례에서 속성에 대한 설명으로 가장 부적절한 것은?","우리은행은 예금분류(일반예금, 특별예금 등)의 원금, 예치기간, 이자율을 관리할 필요가 있다. 또한 원금에 대한 이자율을 적용하여 계산된 이자에 대해서도 속성으로 관리하고자 한다. 예를 들어 원금이 1000원이고 예치기간이 5개월이며 이자율이 5.0%라는 속성을 관리하고 계산된 이자도 관리한다. 일반예금이나 특별예금 등에 대해서는 코드를 부여(예. 01-일반예금, 02-특별예금 등)하여 관리한다.","2","4","일반예금은 코드 엔터티를 별도로 구분하고 값에는 코드값만 포함한다."
"19","다음 중 데이터모델링의 관계에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1|2","1","UML(Unified Modeling Language)에는 클래스다이어그램의 관계 중 연관관계(Association)와 의존관계(Dependency)가 있고 있으나 구분 하지 않고 단일화된 표기법을 사용한다."
"19","다음 중 데이터모델링의 관계에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1|2","2","관계는 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있고 ERD 에서는 관계를 연결할 때, 존재와 행위를 구분하여 실선과 점선의 표기법으로 다르게 표현한다."
"19","다음 중 데이터모델링의 관계에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1|2","3","UML(Unified Modeling Language)에는 클래스다이어그램의 관계 중 연관관계(Association)와 의존관계(Dependency)가 있고 이것은 실선과 점선의 표기법으로 다르게 표현이 된다."
"19","다음 중 데이터모델링의 관계에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1|2","4","관계는 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있으나 ERD에서는 관계를 연결할 때, 존재와 행위를 구분하지 않고 단일화된 표기법을 사용한다."
"22","다음 중 두 개의 엔터티 사이에 정의한 관계를 체크 할 사항으로 가장 부적절한 것은?","","2","1","업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?"
"22","다음 중 두 개의 엔터티 사이에 정의한 관계를 체크 할 사항으로 가장 부적절한 것은?","","2","2","업무기술서, 장표에 관계연결을 가능하게 하는 명사(Noun)가 있는가?"
"22","다음 중 두 개의 엔터티 사이에 정의한 관계를 체크 할 사항으로 가장 부적절한 것은?","","2","3","두 개의 엔터티 사이에 정보의 조합이 발생되는가?"
"22","다음 중 두 개의 엔터티 사이에 정의한 관계를 체크 할 사항으로 가장 부적절한 것은?","","2","4","두 개의 엔터티 사이에 관심 있는 연관규칙이 존재하는가?"
"24","다음 중 아래어서 주식별자를 자정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한것은?","가. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.
나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.","1","1","가,나,다,라"
"24","다음 중 아래어서 주식별자를 자정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한것은?","가. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.
나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.","1","2","나,다,라"
"24","다음 중 아래어서 주식별자를 자정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한것은?","가. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.
나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.","1","3","가,나,라"
"24","다음 중 아래어서 주식별자를 자정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한것은?","가. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.
나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.","1","4","가,나,다"
"39","다음 중 아래 내용의 범주에 해당하는 SQL 명령어로 옳지 않은 것은?","테이블의 구조를 생성, 변경, 삭제하는 등 데이터 구조를 정의하는데 사용되는 명령어이다.","3","1","DROP"
"39","다음 중 아래 내용의 범주에 해당하는 SQL 명령어로 옳지 않은 것은?","테이블의 구조를 생성, 변경, 삭제하는 등 데이터 구조를 정의하는데 사용되는 명령어이다.","3","2","ALTER"
"39","다음 중 아래 내용의 범주에 해당하는 SQL 명령어로 옳지 않은 것은?","테이블의 구조를 생성, 변경, 삭제하는 등 데이터 구조를 정의하는데 사용되는 명령어이다.","3","3","GRANT"
"39","다음 중 아래 내용의 범주에 해당하는 SQL 명령어로 옳지 않은 것은?","테이블의 구조를 생성, 변경, 삭제하는 등 데이터 구조를 정의하는데 사용되는 명령어이다.","3","4","CREATE"
"46","다음 중 테이블 생성시 칼럼별 생성할 수 있는 제익조건(Constraints)에 대한 설명으로 가장 부적절한 것은?","","4","1","NOT NULL : 명시적으로 NULL 입력을 방지한다."
"46","다음 중 테이블 생성시 칼럼별 생성할 수 있는 제익조건(Constraints)에 대한 설명으로 가장 부적절한 것은?","","4","2","FK  : 외래키로 테이블당 여러 개 생성이 가능하다."
"46","다음 중 테이블 생성시 칼럼별 생성할 수 있는 제익조건(Constraints)에 대한 설명으로 가장 부적절한 것은?","","4","3","PK  : 주키로 테이블당 1개만 생성이 가능하다."
"46","다음 중 테이블 생성시 칼럼별 생성할 수 있는 제익조건(Constraints)에 대한 설명으로 가장 부적절한 것은?","","4","4","UNIQUE : 테이블 내에서 중복되는 값이 없으며 NULL 입력이 불가능 하다."
"47","다음 중 물리적 테이블 명으로 가장 적절한 것은?","","4","1","100_EMP"
"47","다음 중 물리적 테이블 명으로 가장 적절한 것은?","","4","2","EMP-100"
"47","다음 중 물리적 테이블 명으로 가장 적절한 것은?","","4","3","100-EMP"
"47","다음 중 물리적 테이블 명으로 가장 적절한 것은?","","4","4","EMP_10"
"60","데이터베이스 트랜잭션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점으로 가장 부적절한 것을 2개 고르시오.","","1,4","1","isolation : 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다."
"60","데이터베이스 트랜잭션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점으로 가장 부적절한 것을 2개 고르시오.","","1,4","2","Phantom Read : 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫번째 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상을 말한다."
"60","데이터베이스 트랜잭션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점으로 가장 부적절한 것을 2개 고르시오.","","1,4","3","Non-Repeatable Read ： 한 트랜잭션 내에서 같은 쿼리를 두 번 수행 했는데, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상을 말한다."
"60","데이터베이스 트랜잭션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점으로 가장 부적절한 것을 2개 고르시오.","","1,4","4","Dirty Read : 다른 트랜잭션에 의해 수정되었고 이미 커밋된 데이터를 읽는 것을 말한다."
"70","다음 중 아래와 같은 2건의 데이터상황어서 SQL의 수행 결과로 가장 적절한 것은? (단, 이해를 돕기 위해 ↓ 는 줄바꿈을 의미 → 실제 저장값이 아님, CHR(10) ： ASCII 값 → 줄바꿈을 의미)","","2","1","6"
"70","다음 중 아래와 같은 2건의 데이터상황어서 SQL의 수행 결과로 가장 적절한 것은? (단, 이해를 돕기 위해 ↓ 는 줄바꿈을 의미 → 실제 저장값이 아님, CHR(10) ： ASCII 값 → 줄바꿈을 의미)","","2","2","5"
"70","다음 중 아래와 같은 2건의 데이터상황어서 SQL의 수행 결과로 가장 적절한 것은? (단, 이해를 돕기 위해 ↓ 는 줄바꿈을 의미 → 실제 저장값이 아님, CHR(10) ： ASCII 값 → 줄바꿈을 의미)","","2","3","3"
"70","다음 중 아래와 같은 2건의 데이터상황어서 SQL의 수행 결과로 가장 적절한 것은? (단, 이해를 돕기 위해 ↓ 는 줄바꿈을 의미 → 실제 저장값이 아님, CHR(10) ： ASCII 값 → 줄바꿈을 의미)","","2","4","2"
"83","다음 중 ORDER BY 절에 대한 설명으로 가장 부적절한 것은?","","2","1","GROUP BY 절을 시용하는 경우 ORDER BY 절에 집계 함수를 사용할 수도 있다."
"83","다음 중 ORDER BY 절에 대한 설명으로 가장 부적절한 것은?","","2","2","ORDER BY 절에서 컬럼명 대신 Alias 명이나 컬럼 순서를 나타내는 정수도 사용이 가능하나, 이들을 혼용하여 사용할 수 없다."
"83","다음 중 ORDER BY 절에 대한 설명으로 가장 부적절한 것은?","","2","3","DBMS마다 NULL 값에 대한 정렬 순서가 다를 수 있으므로 주의하여야 한다."
"83","다음 중 ORDER BY 절에 대한 설명으로 가장 부적절한 것은?","","2","4","SQL 문장으로 조회된 데이터들을 다양한 목적에 맞게 특정 컬럼을 기준으로 정렬하는데 사용한다."
"102","SET OPERATOR 중에서 수학의 교집합과 같은 가능을 하는 연산자로 가장 적절한 것은?","","3","1","EXCEPT"
"102","SET OPERATOR 중에서 수학의 교집합과 같은 가능을 하는 연산자로 가장 적절한 것은?","","3","2","MINUS"
"102","SET OPERATOR 중에서 수학의 교집합과 같은 가능을 하는 연산자로 가장 적절한 것은?","","3","3","INTERSECT"
"102","SET OPERATOR 중에서 수학의 교집합과 같은 가능을 하는 연산자로 가장 적절한 것은?","","3","4","UNION"
"106","다음 중 아래와 같은 집합이 존재 할 때, 집합 A와 B에 대하여 집합연산을 수행한 결과 집합 C가 돠는 경우 이용돠는 데이터베이스 집합연산은?","집합 A = {가, 나, 다, 라},
집합 B = {다, 라, 마, 바},
집합 C = {다, 라}","2","1","Product"
"106","다음 중 아래와 같은 집합이 존재 할 때, 집합 A와 B에 대하여 집합연산을 수행한 결과 집합 C가 돠는 경우 이용돠는 데이터베이스 집합연산은?","집합 A = {가, 나, 다, 라},
집합 B = {다, 라, 마, 바},
집합 C = {다, 라}","2","2","Intersection"
"106","다음 중 아래와 같은 집합이 존재 할 때, 집합 A와 B에 대하여 집합연산을 수행한 결과 집합 C가 돠는 경우 이용돠는 데이터베이스 집합연산은?","집합 A = {가, 나, 다, 라},
집합 B = {다, 라, 마, 바},
집합 C = {다, 라}","2","3","Difference"
"106","다음 중 아래와 같은 집합이 존재 할 때, 집합 A와 B에 대하여 집합연산을 수행한 결과 집합 C가 돠는 경우 이용돠는 데이터베이스 집합연산은?","집합 A = {가, 나, 다, 라},
집합 B = {다, 라, 마, 바},
집합 C = {다, 라}","2","4","Union"
"111","다음 중 SELF JOIN을 수행해야 할 경우로 가장 적절한 것은?","","4","1","한 테이블 내에서 연관된 칼럼은 없으나 JOIN을 해야 한다."
"111","다음 중 SELF JOIN을 수행해야 할 경우로 가장 적절한 것은?","","4","2","두 테이블에 공통 칼럼이 존재하고 두 테이블이 연관 관계가 있다."
"111","다음 중 SELF JOIN을 수행해야 할 경우로 가장 적절한 것은?","","4","3","두 테이블에 연관된 칼럼은 없으나 JOIN을 해야 한다."
"111","다음 중 SELF JOIN을 수행해야 할 경우로 가장 적절한 것은?","","4","4","한 테이블 내에서 두 칼럼이 연관 관계가 있다."
"114","아래는 서브쿼리에 대한 설명이다. 다음 중 올바른 것끼리 묶인 것은?","가) 서브쿼리는 단일 행(Single Row) 또는 복수 행 (Multi Row) 비교연산자와 함께 사용할 수 있다.
나) 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절 등에서 사용이 가능하다.
다) 서브쿼리의 결과가 복수 행(Multi Row) 결과를 반환하는 경우에는
'=', '<=', '=〉' 등의 연산자와 함께 사용이 가능하다.
라) 연관(Correlated) 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다.
마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미하며 Oracle 및 SQL Server 등의 DBMS에서 사용 할 수 있다.","3","1","가,나,마"
"114","아래는 서브쿼리에 대한 설명이다. 다음 중 올바른 것끼리 묶인 것은?","가) 서브쿼리는 단일 행(Single Row) 또는 복수 행 (Multi Row) 비교연산자와 함께 사용할 수 있다.
나) 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절 등에서 사용이 가능하다.
다) 서브쿼리의 결과가 복수 행(Multi Row) 결과를 반환하는 경우에는
'=', '<=', '=〉' 등의 연산자와 함께 사용이 가능하다.
라) 연관(Correlated) 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다.
마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미하며 Oracle 및 SQL Server 등의 DBMS에서 사용 할 수 있다.","3","2","나,다,라"
"114","아래는 서브쿼리에 대한 설명이다. 다음 중 올바른 것끼리 묶인 것은?","가) 서브쿼리는 단일 행(Single Row) 또는 복수 행 (Multi Row) 비교연산자와 함께 사용할 수 있다.
나) 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절 등에서 사용이 가능하다.
다) 서브쿼리의 결과가 복수 행(Multi Row) 결과를 반환하는 경우에는
'=', '<=', '=〉' 등의 연산자와 함께 사용이 가능하다.
라) 연관(Correlated) 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다.
마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미하며 Oracle 및 SQL Server 등의 DBMS에서 사용 할 수 있다.","3","3","가,나,라"
"114","아래는 서브쿼리에 대한 설명이다. 다음 중 올바른 것끼리 묶인 것은?","가) 서브쿼리는 단일 행(Single Row) 또는 복수 행 (Multi Row) 비교연산자와 함께 사용할 수 있다.
나) 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절 등에서 사용이 가능하다.
다) 서브쿼리의 결과가 복수 행(Multi Row) 결과를 반환하는 경우에는
'=', '<=', '=〉' 등의 연산자와 함께 사용이 가능하다.
라) 연관(Correlated) 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다.
마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미하며 Oracle 및 SQL Server 등의 DBMS에서 사용 할 수 있다.","3","4","나,라,마"
"181","다음 SQL 문장에서 틀린 부분은 어디인가?","","1","1","SELECT PLAYER, PLAYER_NAME
선수명, TEAM, TEAM_NAME 팀명"
"181","다음 SQL 문장에서 틀린 부분은 어디인가?","","1","2","FROM PLAYER P, TEAM T"
"181","다음 SQL 문장에서 틀린 부분은 어디인가?","","1","3","WHERE P.TEAM_ID = T.TEAM_ID"
"181","다음 SQL 문장에서 틀린 부분은 어디인가?","","1","4","ORDER BY 선수명;"
"219","다음의 SQL문 실행 결과는 무엇인가?","SELECT * FROM dual WHERE NULL = NULL;","1","1","공집합"
"219","다음의 SQL문 실행 결과는 무엇인가?","SELECT * FROM dual WHERE NULL = NULL;","1","2","X"
"219","다음의 SQL문 실행 결과는 무엇인가?","SELECT * FROM dual WHERE NULL = NULL;","1","3","1"
"219","다음의 SQL문 실행 결과는 무엇인가?","SELECT * FROM dual WHERE NULL = NULL;","1","4","NULL"
"229","다음의 내용 중에서 ROWNUM을 올바르게 사용하지 않은 것은?","","2","1","SELECT DEPTNO FROM EMP
WHERE ROWNUM < 10;"
"229","다음의 내용 중에서 ROWNUM을 올바르게 사용하지 않은 것은?","","2","2","SELECT ENAME FROM EMP
WHERE ROWNUM = 2;"
"229","다음의 내용 중에서 ROWNUM을 올바르게 사용하지 않은 것은?","","2","3","SELECT EMPNO FROM EMP
WHERE ROWNUM = 1;"
"229","다음의 내용 중에서 ROWNUM을 올바르게 사용하지 않은 것은?","","2","4","SELECT ROWNUM, ENAME FROM EMP
WHERE ROWNUM = 2;"
"287","다음 중 SQL에 대한 설명으로 올바르지 않은 것은?","","3","1","TCL : 트랜잭션을 제어하면 Commit 과 Rollback이 있다."
"287","다음 중 SQL에 대한 설명으로 올바르지 않은 것은?","","3","2","DML : 테이블에 데이터를 입력하거나 변경, 삭제한다."
"287","다음 중 SQL에 대한 설명으로 올바르지 않은 것은?","","3","3","DCL : 데이터베이스의 테이블에 있는 데이터를 변경한다."
"287","다음 중 SQL에 대한 설명으로 올바르지 않은 것은?","","3","4","DDL : 테이블과 같은 데이터 구조를 정의하거나 변경한다."
"318","키 엔터티라고도 하며 발생 시점에 따라서 엔터티를 분류할 때 독립적으로 생성되는 엔터티는 무엇인가?","","4","1","종결 엔터티"
"318","키 엔터티라고도 하며 발생 시점에 따라서 엔터티를 분류할 때 독립적으로 생성되는 엔터티는 무엇인가?","","4","2","행위 엔터티"
"318","키 엔터티라고도 하며 발생 시점에 따라서 엔터티를 분류할 때 독립적으로 생성되는 엔터티는 무엇인가?","","4","3","중심 엔터티"
"318","키 엔터티라고도 하며 발생 시점에 따라서 엔터티를 분류할 때 독립적으로 생성되는 엔터티는 무엇인가?","","4","4","기본 엔터티"
"333","다음 SQL문과 동일한 결과를 반환하는 SQL문은?","select * from Mytest
where (COL1 = 1 and COL2 = 3) or (COL1 = 1 and COL2 = 4);","4","1","select * from Mytest where COL1 = 1 or (COL2 = 3 or COL2 = 4);"
"333","다음 SQL문과 동일한 결과를 반환하는 SQL문은?","select * from Mytest
where (COL1 = 1 and COL2 = 3) or (COL1 = 1 and COL2 = 4);","4","2","select * from Mytest where COL1 in (1,3)  or COL2 in (1,4);"
"333","다음 SQL문과 동일한 결과를 반환하는 SQL문은?","select * from Mytest
where (COL1 = 1 and COL2 = 3) or (COL1 = 1 and COL2 = 4);","4","3","select * from Mytest where COL1 in (1,3)  and COL2 in (1,4);"
"333","다음 SQL문과 동일한 결과를 반환하는 SQL문은?","select * from Mytest
where (COL1 = 1 and COL2 = 3) or (COL1 = 1 and COL2 = 4);","4","4","select * from Mytest where COL1 = 1 and  (COL2 = 3 or COL2 = 4);"
"355","다음 SQL문의 실행 결과는?","SELECT COALESCE(nullif(1,1),200,300) as data from dual;","3","1","400"
"355","다음 SQL문의 실행 결과는?","SELECT COALESCE(nullif(1,1),200,300) as data from dual;","3","2","300"
"355","다음 SQL문의 실행 결과는?","SELECT COALESCE(nullif(1,1),200,300) as data from dual;","3","3","200"
"355","다음 SQL문의 실행 결과는?","SELECT COALESCE(nullif(1,1),200,300) as data from dual;","3","4","100"
"362","다음은 주식별자에 대한 설명이다. 올바르지 않은 것은?","","1","1","자주 변경되는 값을 주식별자로 지정해야 한다."
"362","다음은 주식별자에 대한 설명이다. 올바르지 않은 것은?","","1","2","계좌번호와 고객번호를 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 한다."
"362","다음은 주식별자에 대한 설명이다. 올바르지 않은 것은?","","1","3","명칭, 내역 등과 같이 이름으로 기술되는 것들은 주식별자로 지정하지 않는다."
"362","다음은 주식별자에 대한 설명이다. 올바르지 않은 것은?","","1","4","어떤 업무에서 자주 이용되는 것을 주식별자로 한다."
"371","야구선수 테이블에서 선수명과 팀명은 오름차순, 연봉은 내림차순으로 정렬하는 결괏값을 반환하는 SQL문은?(단, 야구선수 테이블은 칼럼이 선수명, 팀명, 연봉 순으로 구성)","","4","1","SELECT * FROM 야구선수 ORDER BY 선수명, 팀명, DESC, 연봉 ASC"
"371","야구선수 테이블에서 선수명과 팀명은 오름차순, 연봉은 내림차순으로 정렬하는 결괏값을 반환하는 SQL문은?(단, 야구선수 테이블은 칼럼이 선수명, 팀명, 연봉 순으로 구성)","","4","2","SELECT * FROM 야구선수 ORDER BY 선수명 ASC, 팀명, ASC, 연봉 ASC"
"371","야구선수 테이블에서 선수명과 팀명은 오름차순, 연봉은 내림차순으로 정렬하는 결괏값을 반환하는 SQL문은?(단, 야구선수 테이블은 칼럼이 선수명, 팀명, 연봉 순으로 구성)","","4","3","SELECT * FROM 야구선수 ORDER BY 선수명 DESC, 팀명, DESC, 연봉 ASC"
"371","야구선수 테이블에서 선수명과 팀명은 오름차순, 연봉은 내림차순으로 정렬하는 결괏값을 반환하는 SQL문은?(단, 야구선수 테이블은 칼럼이 선수명, 팀명, 연봉 순으로 구성)","","4","4","SELECT * FROM 야구선수 ORDER BY 선수명 ASC, 팀명, 3 DESC"
"373","다음 중 NULL 값을 반환하는 쿼리는 어떤 것인가?","","3","1","SELECT NVL(null,'B') FROM DUAL"
"373","다음 중 NULL 값을 반환하는 쿼리는 어떤 것인가?","","3","2","SELECT NVL(null,0)+10 FROM DUAL"
"373","다음 중 NULL 값을 반환하는 쿼리는 어떤 것인가?","","3","3","SELECT NULLIF('B','B') FROM DUAL"
"373","다음 중 NULL 값을 반환하는 쿼리는 어떤 것인가?","","3","4","SELECT COALESCE(NULL,'20') FROM DUAL"
"378","트랜잭션이 가지는 특징에 해당되지 않는 것은?","","1","1","통합성"
"378","트랜잭션이 가지는 특징에 해당되지 않는 것은?","","1","2","고립성"
"378","트랜잭션이 가지는 특징에 해당되지 않는 것은?","","1","3","일관성"
"378","트랜잭션이 가지는 특징에 해당되지 않는 것은?","","1","4","원자성"
"389","다음 중 반올림을 수행하는 함수는?","","4","1","NULLIF"
"389","다음 중 반올림을 수행하는 함수는?","","4","2","TRUNC"
"389","다음 중 반올림을 수행하는 함수는?","","4","3","CEIL"
"389","다음 중 반올림을 수행하는 함수는?","","4","4","ROUND"
"391","다음 중 ORDER BY에 대한 특징으로 옳지 않은 것은?","","1","1","ORDER BY 칼럼명에서 정렬 옵션을 주지 않은 경우에 내림차순이 된다."
"391","다음 중 ORDER BY에 대한 특징으로 옳지 않은 것은?","","1","2","ORACLE은 NULL을 가장 큰 값으로 취급하고 SQL SERVER는 가장 작은 값으로 취급한다."
"391","다음 중 ORDER BY에 대한 특징으로 옳지 않은 것은?","","1","3","SELECT 구문에 사용되지 않은 칼럼에도 ORDER BY 구문에서 사용할 수 있다."
"391","다음 중 ORDER BY에 대한 특징으로 옳지 않은 것은?","","1","4","ORDER BY 속성에 숫자와 칼럼을 혼용하여 사용할 수 있다."
"425","다음 SQL문 중에서 결괏값이 다른 하나는?","","3","1","SELECT CONCAT('AB', 'CD') FROM DUAL;"
"425","다음 SQL문 중에서 결괏값이 다른 하나는?","","3","2","SELECT SUBSTR('ABCABCDED', 4, 4) FROM DUAL;"
"425","다음 SQL문 중에서 결괏값이 다른 하나는?","","3","3","SELECT RTRIM(' ABCD') FROM DUAL;"
"425","다음 SQL문 중에서 결괏값이 다른 하나는?","","3","4","SELECT UPPER('abcd') FROM DUAL;"
"442","다음 중 3차 정규화에 대한 설명으로 올바른 것은?","","1","1","이행함수 종속성을 제거한다."
"442","다음 중 3차 정규화에 대한 설명으로 올바른 것은?","","1","2","조인으로 발생하는 종속성을 제거한다."
"442","다음 중 3차 정규화에 대한 설명으로 올바른 것은?","","1","3","기본키가 하나 이상의 키로 되어 있는 경우에 부분함수 종속성을 제거한다."
"442","다음 중 3차 정규화에 대한 설명으로 올바른 것은?","","1","4","해당 릴레이션에 기본키를 식별한다."
"453","다음의 설명에 해당하는 join은?","조인되는 N개의 테이블을 모두 정렬한 후에 조인을 수행한다.","3","1","INNER JOIN"
"453","다음의 설명에 해당하는 join은?","조인되는 N개의 테이블을 모두 정렬한 후에 조인을 수행한다.","3","2","NESTED LOOP JOIN"
"453","다음의 설명에 해당하는 join은?","조인되는 N개의 테이블을 모두 정렬한 후에 조인을 수행한다.","3","3","SORT MERGE JOIN"
"453","다음의 설명에 해당하는 join은?","조인되는 N개의 테이블을 모두 정렬한 후에 조인을 수행한다.","3","4","HASH JOIN"
"465","다음 보기의 Sub Query 유형은 무엇인가?","SELECT A.EMPNO, A.ENAME
FROM EMP A
WHERE A.EMPNO=(SELECT 1 FROM EMP_T B WHERE A.EMPNO = B.EMPNO);","2","1","Looping Sub Query"
"465","다음 보기의 Sub Query 유형은 무엇인가?","SELECT A.EMPNO, A.ENAME
FROM EMP A
WHERE A.EMPNO=(SELECT 1 FROM EMP_T B WHERE A.EMPNO = B.EMPNO);","2","2","Correlated Sub Query"
"465","다음 보기의 Sub Query 유형은 무엇인가?","SELECT A.EMPNO, A.ENAME
FROM EMP A
WHERE A.EMPNO=(SELECT 1 FROM EMP_T B WHERE A.EMPNO = B.EMPNO);","2","3","Early Filter형 Sub Query"
"465","다음 보기의 Sub Query 유형은 무엇인가?","SELECT A.EMPNO, A.ENAME
FROM EMP A
WHERE A.EMPNO=(SELECT 1 FROM EMP_T B WHERE A.EMPNO = B.EMPNO);","2","4","Service Sub Query"
"468","다음은 NULL 값에 대한 설명이다. 올바른 것은?","","1","1","NULL 값은 아직 알려지지 않은 미지의 값이다."
"468","다음은 NULL 값에 대한 설명이다. 올바른 것은?","","1","2","ORACLE에서 NULL은 TRUE 혹은 FALSE의 의미이다."
"468","다음은 NULL 값에 대한 설명이다. 올바른 것은?","","1","3","MS-SQL에서 NULL 값은 0이다."
"468","다음은 NULL 값에 대한 설명이다. 올바른 것은?","","1","4","데이터베이스의 NULL 값의 의미는 DBMS 종류별로 다르게 해석한다."
"525","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","한림대학교 성심병원은 상급종합병원이고 국내에는 약 43개의 상급종합병원이 있다. 상급종합병원에서 진료를 받기 위해서는 예약을 해야 한다. 예약을 하기 위해서 환자로 등록해야 하는데, 환자 등록을 위해서는 환자이름, 주소, 전화번호, 나이, 최근 병력 등의 정보를 한림대학교 성심병원 웹사이트에 접속해서 입력해야 한다.","3","1","주소"
"525","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","한림대학교 성심병원은 상급종합병원이고 국내에는 약 43개의 상급종합병원이 있다. 상급종합병원에서 진료를 받기 위해서는 예약을 해야 한다. 예약을 하기 위해서 환자로 등록해야 하는데, 환자 등록을 위해서는 환자이름, 주소, 전화번호, 나이, 최근 병력 등의 정보를 한림대학교 성심병원 웹사이트에 접속해서 입력해야 한다.","3","2","이름"
"525","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","한림대학교 성심병원은 상급종합병원이고 국내에는 약 43개의 상급종합병원이 있다. 상급종합병원에서 진료를 받기 위해서는 예약을 해야 한다. 예약을 하기 위해서 환자로 등록해야 하는데, 환자 등록을 위해서는 환자이름, 주소, 전화번호, 나이, 최근 병력 등의 정보를 한림대학교 성심병원 웹사이트에 접속해서 입력해야 한다.","3","3","환자"
"525","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","한림대학교 성심병원은 상급종합병원이고 국내에는 약 43개의 상급종합병원이 있다. 상급종합병원에서 진료를 받기 위해서는 예약을 해야 한다. 예약을 하기 위해서 환자로 등록해야 하는데, 환자 등록을 위해서는 환자이름, 주소, 전화번호, 나이, 최근 병력 등의 정보를 한림대학교 성심병원 웹사이트에 접속해서 입력해야 한다.","3","4","나이"
"529","다음은 데이터베이스 모델링 시에 성능을 고려한 모델링 활동이다. 성능을 고려한 데이터베이스 모델링 단계에서 가장 처음으로 수행해야 할 것과 가장 마지막으로 수행해야 할 것은? ","가. 데이터베이스 모델링 시에 정규화를 수행한다.
나. 테이블에서 보관하는 데이터 용량과 트랜잭션의 유형에 따라서 반정규화를 한다.
다. 트랜잭션의 유형을 분석한다.
라. 데이터베이스 전체 용량을 산정해야 한다.
마. 성능관점에서 데이터 모델을 검증하고 확인한다.
바. 기본키와 외래키를 조정하거나, 슈퍼타입과 서브타입을 조정한다.","1","1","가,마"
"529","다음은 데이터베이스 모델링 시에 성능을 고려한 모델링 활동이다. 성능을 고려한 데이터베이스 모델링 단계에서 가장 처음으로 수행해야 할 것과 가장 마지막으로 수행해야 할 것은? ","가. 데이터베이스 모델링 시에 정규화를 수행한다.
나. 테이블에서 보관하는 데이터 용량과 트랜잭션의 유형에 따라서 반정규화를 한다.
다. 트랜잭션의 유형을 분석한다.
라. 데이터베이스 전체 용량을 산정해야 한다.
마. 성능관점에서 데이터 모델을 검증하고 확인한다.
바. 기본키와 외래키를 조정하거나, 슈퍼타입과 서브타입을 조정한다.","1","2","다,라"
"529","다음은 데이터베이스 모델링 시에 성능을 고려한 모델링 활동이다. 성능을 고려한 데이터베이스 모델링 단계에서 가장 처음으로 수행해야 할 것과 가장 마지막으로 수행해야 할 것은? ","가. 데이터베이스 모델링 시에 정규화를 수행한다.
나. 테이블에서 보관하는 데이터 용량과 트랜잭션의 유형에 따라서 반정규화를 한다.
다. 트랜잭션의 유형을 분석한다.
라. 데이터베이스 전체 용량을 산정해야 한다.
마. 성능관점에서 데이터 모델을 검증하고 확인한다.
바. 기본키와 외래키를 조정하거나, 슈퍼타입과 서브타입을 조정한다.","1","3","다,마"
"529","다음은 데이터베이스 모델링 시에 성능을 고려한 모델링 활동이다. 성능을 고려한 데이터베이스 모델링 단계에서 가장 처음으로 수행해야 할 것과 가장 마지막으로 수행해야 할 것은? ","가. 데이터베이스 모델링 시에 정규화를 수행한다.
나. 테이블에서 보관하는 데이터 용량과 트랜잭션의 유형에 따라서 반정규화를 한다.
다. 트랜잭션의 유형을 분석한다.
라. 데이터베이스 전체 용량을 산정해야 한다.
마. 성능관점에서 데이터 모델을 검증하고 확인한다.
바. 기본키와 외래키를 조정하거나, 슈퍼타입과 서브타입을 조정한다.","1","4","가,나"
"549","다음 중 TEST 사용자가 아래의 작업을 수행할 수 있도록 권한을 부여하는 DCL로 올바른 것은?","UPDATE A_User.TB_A
SET col1='TEST'
WHERE col2=100;","1","1","GRANT SELECT, UPDATE ON A_User, TB_A TO TEST;"
"549","다음 중 TEST 사용자가 아래의 작업을 수행할 수 있도록 권한을 부여하는 DCL로 올바른 것은?","UPDATE A_User.TB_A
SET col1='TEST'
WHERE col2=100;","1","2","REVOKE UPDATE ON A_User, TB_A TO TEST;"
"549","다음 중 TEST 사용자가 아래의 작업을 수행할 수 있도록 권한을 부여하는 DCL로 올바른 것은?","UPDATE A_User.TB_A
SET col1='TEST'
WHERE col2=100;","1","3","REVOKE SELECT ON A_User, TB_A FROM TEST;"
"549","다음 중 TEST 사용자가 아래의 작업을 수행할 수 있도록 권한을 부여하는 DCL로 올바른 것은?","UPDATE A_User.TB_A
SET col1='TEST'
WHERE col2=100;","1","4","GRANT UPDATE TO TEST;"
"569","3층 스키마의 데이터베이스를 보는 관점이 아닌 사람은?","","2","1","사용자"
"569","3층 스키마의 데이터베이스를 보는 관점이 아닌 사람은?","","2","2","구조자"
"569","3층 스키마의 데이터베이스를 보는 관점이 아닌 사람은?","","2","3","설계자"
"569","3층 스키마의 데이터베이스를 보는 관점이 아닌 사람은?","","2","4","개발자"
"578","트랜잭션의 특징 중 보기는 무엇을 설명하고 있는가?","트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.","3","1","지속성"
"578","트랜잭션의 특징 중 보기는 무엇을 설명하고 있는가?","트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.","3","2","고립성"
"578","트랜잭션의 특징 중 보기는 무엇을 설명하고 있는가?","트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.","3","3","일관성"
"578","트랜잭션의 특징 중 보기는 무엇을 설명하고 있는가?","트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.","3","4","원자성"
"625","데이터 모델링에서 식별자 관계에 대한 설명 중 가장 적절하지 않은 것은? ","","2","1","자식 엔터티의 식별자가 부모 엔터티의 주식별자를 상속받아 생성하는 것보다 별도의 주식별자를 생성하는 것 이 더 유리하다고 판단되는 경우 비식별자 관계로 연결해야 한다."
"625","데이터 모델링에서 식별자 관계에 대한 설명 중 가장 적절하지 않은 것은? ","","2","2","비식별 관계는 부모 엔터티가 소멸하면 자식 엔터티도 종속적으로 삭제되는 관계이다."
"625","데이터 모델링에서 식별자 관계에 대한 설명 중 가장 적절하지 않은 것은? ","","2","3","IE 표기법에서는 식별 관계는 실선으로, 비식별 관계는 점선으로 표시한다."
"625","데이터 모델링에서 식별자 관계에 대한 설명 중 가장 적절하지 않은 것은? ","","2","4","식별 관계는 하나의 엔터티의 기본키를 다른 엔터티가 기본키의 하나로 공유하는 관계이다."
"661","계층형 질의에서 CONNECT BY 절에 사용되며, 현재 읽은 컬럼을 지정하는 구문은 무엇인가?","","3","1","ORDER SIBLINGS BY"
"661","계층형 질의에서 CONNECT BY 절에 사용되며, 현재 읽은 컬럼을 지정하는 구문은 무엇인가?","","3","2","NOCYCLE"
"661","계층형 질의에서 CONNECT BY 절에 사용되며, 현재 읽은 컬럼을 지정하는 구문은 무엇인가?","","3","3","PRIOR"
"661","계층형 질의에서 CONNECT BY 절에 사용되며, 현재 읽은 컬럼을 지정하는 구문은 무엇인가?","","3","4","START WITH"
"673","속성에 대한 설명으로 가장 적절하지 않은 것은?","","1","1","엔터티에 속한 속성은 엔터티에 대한 추상적인 값을 갖는다."
"673","속성에 대한 설명으로 가장 적절하지 않은 것은?","","1","2","업무상 인스턴스로 관리하고자 하는 더 이상 분리되지 않는 최소의 데이터 단위를 말한다."
"673","속성에 대한 설명으로 가장 적절하지 않은 것은?","","1","3","정해진 주식별자에 함수적 종속성을 가져야 한다."
"673","속성에 대한 설명으로 가장 적절하지 않은 것은?","","1","4","하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 엔터티를 이용하여 분리한다."
"693","다음 중 에러가 나지 않는 문장은? (단, DBMS는 오라클)","","1","1","SELECT COL1 AS 컬럼1, AVG(COL2) AS 평균 
    FROM TAB1 
   GROUP BY COL1 
   HAVING AVG(COL2) >= 100;"
"693","다음 중 에러가 나지 않는 문장은? (단, DBMS는 오라클)","","1","2","SELECT COL1 AS 컬럼1, AVG(COL2) AS 평균 
    FROM TAB1 
   WHERE AVG(COL2) >= 100 
   GROUP BY 컬럼1;"
"693","다음 중 에러가 나지 않는 문장은? (단, DBMS는 오라클)","","1","3","SELECT COL1 컬럼1, AVG(COL2) 평균 
    FROM TAB1 
   GROUP BY COL2;"
"693","다음 중 에러가 나지 않는 문장은? (단, DBMS는 오라클)","","1","4","SELECT COL1 컬럼1, AVG(COL2) 평 균 
    FROM TAB1;"
"716","제약조건의 설명 중 가장 적절하지 않은 것은?  ","","2","1","NOT NULL 은 NULL 값의 삽입을 금지한다."
"716","제약조건의 설명 중 가장 적절하지 않은 것은?  ","","2","2","기본키는 고유키와 외래키 제약을 합쳐놓은 것이다."
"716","제약조건의 설명 중 가장 적절하지 않은 것은?  ","","2","3","테이블에 저장된 행 데이터를 고유하게 식별하기 위해 고유키를 정의한다."
"716","제약조건의 설명 중 가장 적절하지 않은 것은?  ","","2","4","기본키는 테이블에 저장된 행 데이터를 고유하게 식별하기 위한 키이다."
"731","테이블에 대한 설명 중 가장 적절한 것은?","","3","1","테이블 생성 시 각 컬럼의 데이터 유형을 정의할 수 있고, 생성 이후에는 변경이 불가하다."
"731","테이블에 대한 설명 중 가장 적절한 것은?","","3","2","하나의 행의 하나의 컬럼에는 둘 이상의 값이 삽입될 수 있다."
"731","테이블에 대한 설명 중 가장 적절한 것은?","","3","3","테이블명은 중복될 수 없지만, 소유자가 다른 경우 같은 이름으로 생성 가능하다."
"731","테이블에 대한 설명 중 가장 적절한 것은?","","3","4","같은 테이블을 동시에 두 계정으로 소유할 수 있다."
"733","다음 중 SELECT문에 대한 설명으로 가장 적절하지 않은 것은? (단, DBMS는 오라클)","","2","1","일반적으로 SELECT 절에서는 * 와 컬럼명을 동시에 사용할 수 없다."
"733","다음 중 SELECT문에 대한 설명으로 가장 적절하지 않은 것은? (단, DBMS는 오라클)","","2","2","GROUP BY 절은 NULL 그룹을 출력하지 않는다."
"733","다음 중 SELECT문에 대한 설명으로 가장 적절하지 않은 것은? (단, DBMS는 오라클)","","2","3","FROM 절은 생략 불가하다."
"733","다음 중 SELECT문에 대한 설명으로 가장 적절하지 않은 것은? (단, DBMS는 오라클)","","2","4","실행 순서는 FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY 순 이다."
"738","다음 SQL의 실행 결과에 대한 해석으로 가장 적절한 것은?","SELECT NEXT_DAY(ADD_MONTHS(HIREDATE, 6),'월요일') FROM EMP;","2","1","각 직원의 입사날짜로부터 6개월 후 두 번째 월요일에 해당하는 날짜"
"738","다음 SQL의 실행 결과에 대한 해석으로 가장 적절한 것은?","SELECT NEXT_DAY(ADD_MONTHS(HIREDATE, 6),'월요일') FROM EMP;","2","2","각 직원의 입사날짜로부터 6개월 후 첫 번째 월요일에 해당하는 날짜"
"738","다음 SQL의 실행 결과에 대한 해석으로 가장 적절한 것은?","SELECT NEXT_DAY(ADD_MONTHS(HIREDATE, 6),'월요일') FROM EMP;","2","3","각 직원의 입사날짜로부터 6일 후 두 번째 월요일에 해당하는 날짜"
"738","다음 SQL의 실행 결과에 대한 해석으로 가장 적절한 것은?","SELECT NEXT_DAY(ADD_MONTHS(HIREDATE, 6),'월요일') FROM EMP;","2","4","각 직원의 입사날짜로부터 6일 후 첫 번째 월요일에 해당하는 날짜"
"242","다음 설명 중 옳지 않은 것은?","","4","1","서브쿼리는 Order by절에 사용할 수 있다."
"242","다음 설명 중 옳지 않은 것은?","","4","2","View는 실제 데이터를 가지고 있지 않는다."
"242","다음 설명 중 옳지 않은 것은?","","4","3","Natural Join에 해당하는 칼럼은 테이블의 칼럼명이 동일하다."
"242","다음 설명 중 옳지 않은 것은?","","4","4","Union 과 Union ALL은 성능 차이가 없다."
"258","다음의 SQL문을 CASE문을 사용해서 변경하시오.","SELECT DECODE(EMPNO, 1, 'A', 'B') FROM EMP;","3","1","SELECT CASE EMPNO WHEN 'A' ELSE 'B' END FROM EMP;"
"258","다음의 SQL문을 CASE문을 사용해서 변경하시오.","SELECT DECODE(EMPNO, 1, 'A', 'B') FROM EMP;","3","2","SELECT CASE EMPNO WHEN 1 THEN 'B' ELSE 'A' END FROM EMP;"
"258","다음의 SQL문을 CASE문을 사용해서 변경하시오.","SELECT DECODE(EMPNO, 1, 'A', 'B') FROM EMP;","3","3","SELECT CASE EMPNO WHEN 1 THEN 'A' ELSE 'B' END FROM EMP;"
"258","다음의 SQL문을 CASE문을 사용해서 변경하시오.","SELECT DECODE(EMPNO, 1, 'A', 'B') FROM EMP;","3","4","SELECT CASE EMPNO WHEN 'A' THEN 'B' END FROM EMP;"
"269","다음 중 카디널리티를 계산하는 식으로 올바른 것은?","","2","1","Blevel * 전체 레코드 수"
"269","다음 중 카디널리티를 계산하는 식으로 올바른 것은?","","2","2","선택도 * 전체 레코드 수"
"269","다음 중 카디널리티를 계산하는 식으로 올바른 것은?","","2","3","0.5 * 전체 레코드 수"
"269","다음 중 카디널리티를 계산하는 식으로 올바른 것은?","","2","4","2 * 전체 레코드 수"
"535","다음 보기에서 SELECT 결과가 NULL이 아닌 경우는?","","4","1","SELECT NULLIF('A','A') FROM DUAL;"
"535","다음 보기에서 SELECT 결과가 NULL이 아닌 경우는?","","4","2","SELECT DECODE('A','B','C',NULL) FROM DUAL;"
"535","다음 보기에서 SELECT 결과가 NULL이 아닌 경우는?","","4","3","SELECT CASE 0 WHEN 1 THEN 2 ELSE NULL END FROM DUAL;"
"535","다음 보기에서 SELECT 결과가 NULL이 아닌 경우는?","","4","4","SELECT COLAESCE(1,2,3) FROM DUAL;"
"801","다음 중 데이터 모델링의 가장 주요한 목적은 무엇인가?","","3","1","데이터를 시각화하는 것"
"801","다음 중 데이터 모델링의 가장 주요한 목적은 무엇인가?","","3","2","데이터를 저장하는 것"
"801","다음 중 데이터 모델링의 가장 주요한 목적은 무엇인가?","","3","3","업무를 분석하고 시스템 구조를 설계하는 것"
"801","다음 중 데이터 모델링의 가장 주요한 목적은 무엇인가?","","3","4","데이터를 암호화하는 것"
"810","비식별 관계에서 자식 엔터티의 기본키 구성은?","","4","1","부모 엔터티의 키만으로 구성"
"810","비식별 관계에서 자식 엔터티의 기본키 구성은?","","4","2","자식 고유 키만 사용"
"810","비식별 관계에서 자식 엔터티의 기본키 구성은?","","4","3","부모와 무관한 외래 키"
"810","비식별 관계에서 자식 엔터티의 기본키 구성은?","","4","4","외래 키는 포함하지만 기본키에는 포함되지 않음"
"814","제2정규형(2NF)에서 제거해야 하는 종속성은?","","1","1","부분 함수 종속"
"814","제2정규형(2NF)에서 제거해야 하는 종속성은?","","1","2","중복 레코드"
"814","제2정규형(2NF)에서 제거해야 하는 종속성은?","","1","3","이행적 종속"
"814","제2정규형(2NF)에서 제거해야 하는 종속성은?","","1","4","기본키"
"11","다음 중 엔터티의 일반적인 특징으로 가장 부적절한 것은?","","4","1","엔터티는 반드시 속성을 포함해야 한다."
"11","다음 중 엔터티의 일반적인 특징으로 가장 부적절한 것은?","","4","2","엔터티는 업무 프로세스에 의해 이용되어야 한다."
"11","다음 중 엔터티의 일반적인 특징으로 가장 부적절한 것은?","","4","3","유일한 식별자에 의해 식별이 가능해야 한다."
"11","다음 중 엔터티의 일반적인 특징으로 가장 부적절한 것은?","","4","4","다른 엔터티와의 관계를 가지지 않는다."
"17","다음 중 아래 설명이 나타내는 데이터모델의 개념으로 가장 적절한 것은?","주문이라는 엔터티가 있을 때 단가라는 속성 값의 범위는 100에서 10,000 사이의 실수 값이며 제품명이라는 속성은 길이가 20자리 이내의 문자열로 정의할 수 있다.","1","1","도메인(Domain)"
"17","다음 중 아래 설명이 나타내는 데이터모델의 개념으로 가장 적절한 것은?","주문이라는 엔터티가 있을 때 단가라는 속성 값의 범위는 100에서 10,000 사이의 실수 값이며 제품명이라는 속성은 길이가 20자리 이내의 문자열로 정의할 수 있다.","1","2","속성사전(Attribute Dictionary)"
"17","다음 중 아래 설명이 나타내는 데이터모델의 개념으로 가장 적절한 것은?","주문이라는 엔터티가 있을 때 단가라는 속성 값의 범위는 100에서 10,000 사이의 실수 값이며 제품명이라는 속성은 길이가 20자리 이내의 문자열로 정의할 수 있다.","1","3","용어사전(Word Dictionary)"
"17","다음 중 아래 설명이 나타내는 데이터모델의 개념으로 가장 적절한 것은?","주문이라는 엔터티가 있을 때 단가라는 속성 값의 범위는 100에서 10,000 사이의 실수 값이며 제품명이라는 속성은 길이가 20자리 이내의 문자열로 정의할 수 있다.","1","4","시스템카탈로그(System Catalog)"
"44","다음 중 NULL의 설명으로 가장 부적절한 것은?","","2","1","NULL과의 모든 비교 (IS NULL 제외)는 알 수 없음 (Unknown) 을 반환한다."
"44","다음 중 NULL의 설명으로 가장 부적절한 것은?","","2","2","공백문자 (Empty String)  혹은 숫자 0을 의미한다."
"44","다음 중 NULL의 설명으로 가장 부적절한 것은?","","2","3","값의 부재를 의미한다."
"44","다음 중 NULL의 설명으로 가장 부적절한 것은?","","2","4","모르는 값을 의미한다."
"49","다음 중 외래키에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","2,3","1","외래키 값은 참조 무결성 제약을 받을 수 있다."
"49","다음 중 외래키에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","2,3","2","한 테이블에 하나만 존재해야 한다."
"49","다음 중 외래키에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","2,3","3","외래키 값은 널 값을 가질 수 없다."
"49","다음 중 외래키에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","2,3","4","테이블 생성시 설정할 수 있다."
"50","다음 중 데이터베이스 테이블의 제약조건(Constraint)에 대한 설명으로 가장 부적절한 것은?","","2","1","외래키(Foreign Key)는 테이블간의 관계를 정의하기 위해 기본키(Primary Key)를 다른 테이블의 외래키가 참조하도록 생성한다."
"50","다음 중 데이터베이스 테이블의 제약조건(Constraint)에 대한 설명으로 가장 부적절한 것은?","","2","2","고유키(Unique Key)로 지정된 모든 컬럼들은 Null 값을 가질 수 없다"
"50","다음 중 데이터베이스 테이블의 제약조건(Constraint)에 대한 설명으로 가장 부적절한 것은?","","2","3","기본키(Primary Key)는 반드시 테이블 당 하나의 제약만을 정의할 수 있다."
"50","다음 중 데이터베이스 테이블의 제약조건(Constraint)에 대한 설명으로 가장 부적절한 것은?","","2","4","Check 제약조건(Constraint)은 데이터베이스에서 데이터의 무결성을 유지하기 위하여 테이블의 특정 컬럼(Column)에 설정하는 제약이다."
"66","아래와 같은 DDL 문장으로 테이블 생성하고, SQL들을 수행하였을 때 다음 설명 중 옳은 것은?","CREATE TABLE 서비스
(서비스번호 VARCHAR2(10) PRIMARY KEY, 
서비스명 VARCHAR2(100) NULL,
개시일자 DATE NOT NULL  ); 
 [SQL]
(ㄱ)SELECT * FROM 서비스 WHERE 서비스번호 = 1；
(ㄴ)INSERT INTO 서비스 VALUES ('999', "", '2015-11-11')；
(ㄷ)SELECT * FROM 서비스 WHERE 서비스명 = ''；
(ㄹ) SELECT * FROM 서비스 WHERE 서비스명 IS NULL；","1","1","SQL Server에서 (ㄴ)과같이 데이터를 입력하고, (ㄹ)과 같이 조회하였을 때, 데이터는 조회되지 않는다."
"66","아래와 같은 DDL 문장으로 테이블 생성하고, SQL들을 수행하였을 때 다음 설명 중 옳은 것은?","CREATE TABLE 서비스
(서비스번호 VARCHAR2(10) PRIMARY KEY, 
서비스명 VARCHAR2(100) NULL,
개시일자 DATE NOT NULL  ); 
 [SQL]
(ㄱ)SELECT * FROM 서비스 WHERE 서비스번호 = 1；
(ㄴ)INSERT INTO 서비스 VALUES ('999', "", '2015-11-11')；
(ㄷ)SELECT * FROM 서비스 WHERE 서비스명 = ''；
(ㄹ) SELECT * FROM 서비스 WHERE 서비스명 IS NULL；","1","2","ORACLE에서 (ㄴ)과같이 데이터를 입력하고, (ㄷ)과 같이 조회하였을 때, 데이터는 조회된다."
"66","아래와 같은 DDL 문장으로 테이블 생성하고, SQL들을 수행하였을 때 다음 설명 중 옳은 것은?","CREATE TABLE 서비스
(서비스번호 VARCHAR2(10) PRIMARY KEY, 
서비스명 VARCHAR2(100) NULL,
개시일자 DATE NOT NULL  ); 
 [SQL]
(ㄱ)SELECT * FROM 서비스 WHERE 서비스번호 = 1；
(ㄴ)INSERT INTO 서비스 VALUES ('999', "", '2015-11-11')；
(ㄷ)SELECT * FROM 서비스 WHERE 서비스명 = ''；
(ㄹ) SELECT * FROM 서비스 WHERE 서비스명 IS NULL；","1","3","ORACLE에서 (ㄴ)과같이 데이터를 입력하였을 때, 서비스명 컬럼에 공백문자 데이터가 입력된다."
"66","아래와 같은 DDL 문장으로 테이블 생성하고, SQL들을 수행하였을 때 다음 설명 중 옳은 것은?","CREATE TABLE 서비스
(서비스번호 VARCHAR2(10) PRIMARY KEY, 
서비스명 VARCHAR2(100) NULL,
개시일자 DATE NOT NULL  ); 
 [SQL]
(ㄱ)SELECT * FROM 서비스 WHERE 서비스번호 = 1；
(ㄴ)INSERT INTO 서비스 VALUES ('999', "", '2015-11-11')；
(ㄷ)SELECT * FROM 서비스 WHERE 서비스명 = ''；
(ㄹ) SELECT * FROM 서비스 WHERE 서비스명 IS NULL；","1","4","서비스번호 컬럼에 모든 레코드 중에서 ‘001’과 같은 숫자형식으로 하나의 레코드만이라도 입력되어 (ㄱ)은 오류 없이 실행된다."
"69","아래와 같은 내장 함수에 대한 설명 중에서 옳은 것을 모두 묶은 것은?","가) 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분할 수 있다.
나) 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET 절에 사용이 가능하다.
다) 1：M 관계의 두 테이블을 조인할 경우 이쪽에 다중행이 출력되므로 단일행 함수는 사용할 수 없다.
라) 단일행 함수는 다중행 함수와 다르게 여러 개의 인수가 입력 되어도 단일 값만을 반환한다.","3","1","가,나,다,라"
"69","아래와 같은 내장 함수에 대한 설명 중에서 옳은 것을 모두 묶은 것은?","가) 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분할 수 있다.
나) 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET 절에 사용이 가능하다.
다) 1：M 관계의 두 테이블을 조인할 경우 이쪽에 다중행이 출력되므로 단일행 함수는 사용할 수 없다.
라) 단일행 함수는 다중행 함수와 다르게 여러 개의 인수가 입력 되어도 단일 값만을 반환한다.","3","2","가,나,다"
"69","아래와 같은 내장 함수에 대한 설명 중에서 옳은 것을 모두 묶은 것은?","가) 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분할 수 있다.
나) 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET 절에 사용이 가능하다.
다) 1：M 관계의 두 테이블을 조인할 경우 이쪽에 다중행이 출력되므로 단일행 함수는 사용할 수 없다.
라) 단일행 함수는 다중행 함수와 다르게 여러 개의 인수가 입력 되어도 단일 값만을 반환한다.","3","3","가,나"
"69","아래와 같은 내장 함수에 대한 설명 중에서 옳은 것을 모두 묶은 것은?","가) 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분할 수 있다.
나) 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET 절에 사용이 가능하다.
다) 1：M 관계의 두 테이블을 조인할 경우 이쪽에 다중행이 출력되므로 단일행 함수는 사용할 수 없다.
라) 단일행 함수는 다중행 함수와 다르게 여러 개의 인수가 입력 되어도 단일 값만을 반환한다.","3","4","가"
"72","팀별 포지션별 FW, MF, DF, GK 포지션의 인원수와 팀별 전체 인원수를 SQL을 작성할 때 결과가 다른 것은? (보기 1은 SQL Server 환경이고, 보기 2,3,4는 ORACLE 환경이다.)","","1","1","SELECT TEAM_ID,
 NVL(SUM(CASE  POSITION WHEN 'FW' THEN 1 ELSE 1 END), 0) FW,
 NVL(SUM(CASE  POSITION WHEN 'MF' THEN 1 ELSE 1 END), 0) MF,
 NVL(SUM(CASE  POSITION WHEN 'DF' THEN 1 ELSE 1 END), 0) DF,
 NVL(SUM(CASE  POSITION WHEN 'GK' THEN 1 ELSE 1 END), 0) GK,
 COUNT(*) SUM 
FROM PLAYER
GROUP BY TEAM_ID；"
"72","팀별 포지션별 FW, MF, DF, GK 포지션의 인원수와 팀별 전체 인원수를 SQL을 작성할 때 결과가 다른 것은? (보기 1은 SQL Server 환경이고, 보기 2,3,4는 ORACLE 환경이다.)","","1","2","SELECT TEAM_ID,
 NVL(SUM(CASE  WHEN POSITION = 'FW' THEN 1  END), 0) FW,
 NVL(SUM(CASE  WHEN POSITION = 'MF' THEN 1  END), 0) MF,
 NVL(SUM(CASE  WHEN POSITION = 'DF' THEN 1  END), 0) DF,
 NVL(SUM(CASE  WHEN POSITION = 'GK' THEN 1  END), 0) GK,
 COUNT(*) SUM 
FROM PLAYER
GROUP BY TEAM_ID；"
"72","팀별 포지션별 FW, MF, DF, GK 포지션의 인원수와 팀별 전체 인원수를 SQL을 작성할 때 결과가 다른 것은? (보기 1은 SQL Server 환경이고, 보기 2,3,4는 ORACLE 환경이다.)","","1","3","SELECT TEAM_ID,
 NVL(SUM(CASE  POSITION WHEN 'FW' THEN 1  END), 0) FW,
 NVL(SUM(CASE  POSITION WHEN 'MF' THEN 1  END), 0) MF,
 NVL(SUM(CASE  POSITION WHEN 'DF' THEN 1  END), 0) DF,
 NVL(SUM(CASE  POSITION WHEN 'GK' THEN 1  END), 0) GK,
 COUNT(*) SUM 
FROM PLAYER
GROUP BY TEAM_ID；"
"72","팀별 포지션별 FW, MF, DF, GK 포지션의 인원수와 팀별 전체 인원수를 SQL을 작성할 때 결과가 다른 것은? (보기 1은 SQL Server 환경이고, 보기 2,3,4는 ORACLE 환경이다.)","","1","4","SELECT TEAM_ID,
 ISNULL(SUM(CASE WHEN POSITION = 'FW' THEN 1 END), 0) FW,
 ISNULL(SUM(CASE WHEN POSITION = 'MF' THEN 1 END), 0) MF,
 ISNULL(SUM(CASE WHEN POSITION = 'DF' THEN 1 END), 0) DF,
 ISNULL(SUM(CASE WHEN POSITION = 'GK' THEN 1 END), 0) GK,
 COUNT(*) SUM 
FROM PLAYER
GROUP BY TEAM_ID；"
"148","엔터티 간 1:1, 1:M과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가?","","4","1","관계정의"
"148","엔터티 간 1:1, 1:M과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가?","","4","2","관계선택성"
"148","엔터티 간 1:1, 1:M과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가?","","4","3","관계명"
"148","엔터티 간 1:1, 1:M과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가?","","4","4","관계 차수"
"149","관계를 정의할 때 주요하게 체크해야 하는 사항과 거리가 먼 것은?","","3","1","두 개의 엔터티 사이에 정보의 조합이 발생되는가?"
"149","관계를 정의할 때 주요하게 체크해야 하는 사항과 거리가 먼 것은?","","3","2","업무기술서, 장표에 관계연결 규칙이 서술되어 있는가?"
"149","관계를 정의할 때 주요하게 체크해야 하는 사항과 거리가 먼 것은?","","3","3","업무기술서, 장표에 관계연결을 가능하게 하는 명사가 있는가?"
"149","관계를 정의할 때 주요하게 체크해야 하는 사항과 거리가 먼 것은?","","3","4","두 개의 엔터티 사이에 관심 있는 연관규칙이 존재하는가?"
"153","데이터 모델링에 대한 단계 중 아래에서 설명하는 단계는 어떤 단계의 모델링인가?","-추상화 수준이 높고 업무 중심적이며 포괄적인 수준의 모델링을 진행한다.
-전시적 데이터 모델링 또는 EA 수립 시 많이 이용된다.","2","1","추상적 데이터 모델링"
"153","데이터 모델링에 대한 단계 중 아래에서 설명하는 단계는 어떤 단계의 모델링인가?","-추상화 수준이 높고 업무 중심적이며 포괄적인 수준의 모델링을 진행한다.
-전시적 데이터 모델링 또는 EA 수립 시 많이 이용된다.","2","2","개념적 데이터 모델링"
"153","데이터 모델링에 대한 단계 중 아래에서 설명하는 단계는 어떤 단계의 모델링인가?","-추상화 수준이 높고 업무 중심적이며 포괄적인 수준의 모델링을 진행한다.
-전시적 데이터 모델링 또는 EA 수립 시 많이 이용된다.","2","3","논리적 데이터 모델링"
"153","데이터 모델링에 대한 단계 중 아래에서 설명하는 단계는 어떤 단계의 모델링인가?","-추상화 수준이 높고 업무 중심적이며 포괄적인 수준의 모델링을 진행한다.
-전시적 데이터 모델링 또는 EA 수립 시 많이 이용된다.","2","4","물리적 데이터 모델링"
"158","다음 설명에 해당하는 속성의 종류는 무엇인가?","-다른 속성에 영향을 받아 발생하는 속성으로서 보통 계산된 값들이 이에 해당한다.
-다른 속성에 영향을 받기 때문에 프로세스 설계 시 데이터 정합성을 유지하기 위해 유의해야 할 점이 많다.
-가급적 속성을 적게 정의하는 것이 좋다.","1","1","파생 속성"
"158","다음 설명에 해당하는 속성의 종류는 무엇인가?","-다른 속성에 영향을 받아 발생하는 속성으로서 보통 계산된 값들이 이에 해당한다.
-다른 속성에 영향을 받기 때문에 프로세스 설계 시 데이터 정합성을 유지하기 위해 유의해야 할 점이 많다.
-가급적 속성을 적게 정의하는 것이 좋다.","1","2","설계 속성"
"158","다음 설명에 해당하는 속성의 종류는 무엇인가?","-다른 속성에 영향을 받아 발생하는 속성으로서 보통 계산된 값들이 이에 해당한다.
-다른 속성에 영향을 받기 때문에 프로세스 설계 시 데이터 정합성을 유지하기 위해 유의해야 할 점이 많다.
-가급적 속성을 적게 정의하는 것이 좋다.","1","3","기본 속성"
"158","다음 설명에 해당하는 속성의 종류는 무엇인가?","-다른 속성에 영향을 받아 발생하는 속성으로서 보통 계산된 값들이 이에 해당한다.
-다른 속성에 영향을 받기 때문에 프로세스 설계 시 데이터 정합성을 유지하기 위해 유의해야 할 점이 많다.
-가급적 속성을 적게 정의하는 것이 좋다.","1","4","연관 속성"
"159","3차정규화에 대한 설명으로 옳은 것을 고르시오.","","4","1","다수의 주식별자를 분리시킨다."
"159","3차정규화에 대한 설명으로 옳은 것을 고르시오.","","4","2","모든 속성은 반드시 하나의 값을 가져야 한다."
"159","3차정규화에 대한 설명으로 옳은 것을 고르시오.","","4","3","모든 속성은 반드시 기본 키 전부에 종속되어야 한다."
"159","3차정규화에 대한 설명으로 옳은 것을 고르시오.","","4","4","속성 간 종속성을 가지면 안 된다."
"165","테이블의 반정규화 기법 중 데이터 무결성을 깨뜨릴 위험을 갖지 않고서도 데이터 처리의 성능을 향상 시킬 수 있는 기법은?","","3","1","데이터 반정규화"
"165","테이블의 반정규화 기법 중 데이터 무결성을 깨뜨릴 위험을 갖지 않고서도 데이터 처리의 성능을 향상 시킬 수 있는 기법은?","","3","2","칼럼 반정규화"
"165","테이블의 반정규화 기법 중 데이터 무결성을 깨뜨릴 위험을 갖지 않고서도 데이터 처리의 성능을 향상 시킬 수 있는 기법은?","","3","3","중복관계 추가"
"165","테이블의 반정규화 기법 중 데이터 무결성을 깨뜨릴 위험을 갖지 않고서도 데이터 처리의 성능을 향상 시킬 수 있는 기법은?","","3","4","테이블 반정규화"
"170","엔터티에 대한 개념 중 엔터티 정의의 공통점 3가지가 아닌 것은?","","4","1","업무상 관리가 필요한 관심사에 해당된다."
"170","엔터티에 대한 개념 중 엔터티 정의의 공통점 3가지가 아닌 것은?","","4","2","저장되기 위한 어떤 것이다."
"170","엔터티에 대한 개념 중 엔터티 정의의 공통점 3가지가 아닌 것은?","","4","3","엔터티는 사람, 장소, 물건, 사건, 개념 등의 명사에 해당된다."
"170","엔터티에 대한 개념 중 엔터티 정의의 공통점 3가지가 아닌 것은?","","4","4","데이터베이스 내에서 변멸 가능한 객체이다."
"173","데이터 유형에 대한 설명 중 틀린 것은 무엇인가?","","4","1","DATE 유형은 날짜 데이터를 다룰 때 사용한다."
"173","데이터 유형에 대한 설명 중 틀린 것은 무엇인가?","","4","2","NUMERIC 유형은 숫자형 데이터를 표현한다."
"173","데이터 유형에 대한 설명 중 틀린 것은 무엇인가?","","4","3","CHAR 유형은 고정 길이 문자형이다."
"173","데이터 유형에 대한 설명 중 틀린 것은 무엇인가?","","4","4","VARCHAR 유형은 가변 길이 숫자형이다."
"176","Commit과 Rollback의 장점으로 적합하지 않은 것은 무엇인가?","","3","1","논리적으로 연관된 작업을 그룹핑하여 처리 가능하다."
"176","Commit과 Rollback의 장점으로 적합하지 않은 것은 무엇인가?","","3","2","영구적인 변경을 하기 전에 데이터의 변경 사항 확인이 가능하다."
"176","Commit과 Rollback의 장점으로 적합하지 않은 것은 무엇인가?","","3","3","영구적인 변경을 할 수 없게 한다."
"176","Commit과 Rollback의 장점으로 적합하지 않은 것은 무엇인가?","","3","4","데이터 무결성을 보장한다."
"184","다음 설명 중 올바르지 않은 것은?","","4","1","EXCEPT 연산자는 조회 결과에 대한 차집합을 의미한다."
"184","다음 설명 중 올바르지 않은 것은?","","4","2","INTERSECT 연산자는 조회 결과에 대한 교집합을 의미한다."
"184","다음 설명 중 올바르지 않은 것은?","","4","3","UNION 연산자는 조회 결과에 대한 합집합을 나타내며 자동으로 정렬을 해준다."
"184","다음 설명 중 올바르지 않은 것은?","","4","4","UNION ALL 연산자는 조회 결과를 정렬하고 중복되는 데이터를 한 번만 표현한다."
"214","다음 SQL문에 대한 설명으로 올바른 것은?","SELECT *
FROM SQLD_33
WHERE EMP_NAME LIKE 'A%'","3","1","테이블의 EMP_NAME이 A 또는 a로 끝나는 모든 ROW"
"214","다음 SQL문에 대한 설명으로 올바른 것은?","SELECT *
FROM SQLD_33
WHERE EMP_NAME LIKE 'A%'","3","2","테이블의 EMP_NAME이 A로 끝나는 모든 ROW"
"214","다음 SQL문에 대한 설명으로 올바른 것은?","SELECT *
FROM SQLD_33
WHERE EMP_NAME LIKE 'A%'","3","3","테이블의 EMP_NAME이 A로 시작하는 모든 ROW"
"214","다음 SQL문에 대한 설명으로 올바른 것은?","SELECT *
FROM SQLD_33
WHERE EMP_NAME LIKE 'A%'","3","4","테이블의 EMP_NAME이 A 또는 a로 시작하는 모든 ROW"
"223","그룹 내 순위 관련 WINDOW 함수의 특징으로 올바르지 않은 것을 고르시오.","","2","1","RANK 함수가 동일한 값에 대해서는 동일한 순위를 부여하는 데 반해, ROW_NUMBER 함수는 고유한 순위를 부여한다."
"223","그룹 내 순위 관련 WINDOW 함수의 특징으로 올바르지 않은 것을 고르시오.","","2","2","RCUMM_RANK 함수는 누적된 순위를 부여한다."
"223","그룹 내 순위 관련 WINDOW 함수의 특징으로 올바르지 않은 것을 고르시오.","","2","3","DENSE_RANK 함수는 RANK 함수와 흡사하며, 동일한 순위를 하나의 건수로 취급한다."
"223","그룹 내 순위 관련 WINDOW 함수의 특징으로 올바르지 않은 것을 고르시오.","","2","4","RANK 함수는 동일한 값에 대해서는 동일한 순위를 부여한다."
"227","우선순위를 계산하는 윈도우 함수에서 동일한 우선순위가 나와도 고유의 값을 부여하기 위한 방법으로 올바른 것은 무엇인가?","","2","1","Select UNIQUE_RANK() OVER 
(PARTITION BY DEPTNO 
ORDER BY SAL DESC) 
DEPT_RANK;"
"227","우선순위를 계산하는 윈도우 함수에서 동일한 우선순위가 나와도 고유의 값을 부여하기 위한 방법으로 올바른 것은 무엇인가?","","2","2","Select ROW_NUMBER() OVER 
(PARTITION BY DEPTNO 
ORDER BY SAL DESC) 
DEPT_RANK;"
"227","우선순위를 계산하는 윈도우 함수에서 동일한 우선순위가 나와도 고유의 값을 부여하기 위한 방법으로 올바른 것은 무엇인가?","","2","3","Select DENSE_RANK() OVER 
(PARTITION BY DEPTNO 
ORDER BY SAL DESC) 
DEPT_RANK;"
"227","우선순위를 계산하는 윈도우 함수에서 동일한 우선순위가 나와도 고유의 값을 부여하기 위한 방법으로 올바른 것은 무엇인가?","","2","4","Select RANK() OVER 
(PARTITION BY DEPTNO 
ORDER BY SAL DESC) 
DEPT_RANK;"
"230","서브쿼리의 종류 중에서 서브쿼리가 메인쿼리의 제공자 역할을 하고 메인쿼리의 값이 서브쿼리에 주입되지 않는 유형은 무엇인가?","","1","1","Access Subquery"
"230","서브쿼리의 종류 중에서 서브쿼리가 메인쿼리의 제공자 역할을 하고 메인쿼리의 값이 서브쿼리에 주입되지 않는 유형은 무엇인가?","","1","2","Associative Subquery"
"230","서브쿼리의 종류 중에서 서브쿼리가 메인쿼리의 제공자 역할을 하고 메인쿼리의 값이 서브쿼리에 주입되지 않는 유형은 무엇인가?","","1","3","Early Filter형 Subquery"
"230","서브쿼리의 종류 중에서 서브쿼리가 메인쿼리의 제공자 역할을 하고 메인쿼리의 값이 서브쿼리에 주입되지 않는 유형은 무엇인가?","","1","4","Filter형 Subquery"
"274","다음 중 Mytest 테이블에 JOB 칼럼을 추가하는 방법으로 올바른 것을 고르시오.(단, 데이터타입, 제약조건 등은 따로 고려하지 않음)","","2","1","ALTER table Mytest add constraint JOB"
"274","다음 중 Mytest 테이블에 JOB 칼럼을 추가하는 방법으로 올바른 것을 고르시오.(단, 데이터타입, 제약조건 등은 따로 고려하지 않음)","","2","2","ALTER table Mytest add JOB"
"274","다음 중 Mytest 테이블에 JOB 칼럼을 추가하는 방법으로 올바른 것을 고르시오.(단, 데이터타입, 제약조건 등은 따로 고려하지 않음)","","2","3","ATLER table Mytest modify add JOB"
"274","다음 중 Mytest 테이블에 JOB 칼럼을 추가하는 방법으로 올바른 것을 고르시오.(단, 데이터타입, 제약조건 등은 따로 고려하지 않음)","","2","4","ALTER table Mytest alter add column JOB"
"302","EMP 테이블의 급여합계에 대해서 결합 가능한 모든 조건의 합계를 계산하는 것은?","","1","1","CUBE(DEPTNO, JOB)"
"302","EMP 테이블의 급여합계에 대해서 결합 가능한 모든 조건의 합계를 계산하는 것은?","","1","2","ROLLUP(DEPTNO, JOB)"
"302","EMP 테이블의 급여합계에 대해서 결합 가능한 모든 조건의 합계를 계산하는 것은?","","1","3","GROUPING SETS(DEPTNO, JOB)"
"302","EMP 테이블의 급여합계에 대해서 결합 가능한 모든 조건의 합계를 계산하는 것은?","","1","4","GROUP BY DEPTNO, JOB"
"315","아래 ER 모델링의 표기법은 무엇인가?","","3","1","IDEFIX 표기법"
"315","아래 ER 모델링의 표기법은 무엇인가?","","3","2","UML 표기법"
"315","아래 ER 모델링의 표기법은 무엇인가?","","3","3","IE 표기법"
"315","아래 ER 모델링의 표기법은 무엇인가?","","3","4","Barker 표기법"
"324","다음 SQL문의 실행 결과로 올바른 것은?","","3","1","SELECT TRUNC(35.8) FROM DUAL -> 36"
"324","다음 SQL문의 실행 결과로 올바른 것은?","","3","2","SELECT ROUND(36.8,0) FROM DUAL -> 36"
"324","다음 SQL문의 실행 결과로 올바른 것은?","","3","3","SELECT CEIL(35.8) FROM DUAL -> 36"
"324","다음 SQL문의 실행 결과로 올바른 것은?","","3","4","SELECT FLOOR(35.8) FROM DUAL -> 36"
"336","다음 중 B-Tree 인덱스에 대한 설명으로 올바른 것은?","","3","1","정보계와 같은 Data warehouse 에서 사용하고 많은 양의 데이터를 검색할 때 사용한다."
"336","다음 중 B-Tree 인덱스에 대한 설명으로 올바른 것은?","","3","2","인덱스 내부 구조에 해당 데이터가 있으면 1, 없으면 0으로 저장한다."
"336","다음 중 B-Tree 인덱스에 대한 설명으로 올바른 것은?","","3","3","분기를 수행하는 브랜치 블록, 인덱스를 구성하는 칼럼값을 가지는 리프 블록으로 구성된다."
"336","다음 중 B-Tree 인덱스에 대한 설명으로 올바른 것은?","","3","4","인덱스를 생성하면 물리적으로 정렬되기 때문에 빠르게 연속적인 데이터 블록을 검색할 수 있다."
"394","SQL문의 집합 연산자에 대한 설명이다. 다음 중 INTERSECT로 올바른 것은?","","1","1","양쪽 모두 포함된 행을 검색한다."
"394","SQL문의 집합 연산자에 대한 설명이다. 다음 중 INTERSECT로 올바른 것은?","","1","2","차집합을 검색한다."
"394","SQL문의 집합 연산자에 대한 설명이다. 다음 중 INTERSECT로 올바른 것은?","","1","3","중복을 제거한 결과의 합을 검색한다."
"394","SQL문의 집합 연산자에 대한 설명이다. 다음 중 INTERSECT로 올바른 것은?","","1","4","중복을 포함한 결과의 합을 검색한다."
"396","어느 기업의 직원 테이블(EMP)이 직급(GRADE)별로 사원 500명, 대리 100명, 과장 30명, 차장 10명, 부장 5명, 직급이 정해지지 않은(NULL) 사람 25명으로 구성되어 있을 때, 다음 중 SQL문을 SQL1)부터 SQL3)까지 순차적으로 실행한 결과 건수를 순서대로 나열한 것은?","SQL1) SELECT COUNT(GRADE) FROM EMP;
SQL2) SELECT GRADE FROM EMP WHERE GRADE IN('차장', '부장', '널');
SQL3) SELECT GRADE, COUNT(*) FROM EMP GROUP BY GRADE;","2","1","670, 40, 6"
"396","어느 기업의 직원 테이블(EMP)이 직급(GRADE)별로 사원 500명, 대리 100명, 과장 30명, 차장 10명, 부장 5명, 직급이 정해지지 않은(NULL) 사람 25명으로 구성되어 있을 때, 다음 중 SQL문을 SQL1)부터 SQL3)까지 순차적으로 실행한 결과 건수를 순서대로 나열한 것은?","SQL1) SELECT COUNT(GRADE) FROM EMP;
SQL2) SELECT GRADE FROM EMP WHERE GRADE IN('차장', '부장', '널');
SQL3) SELECT GRADE, COUNT(*) FROM EMP GROUP BY GRADE;","2","2","645, 15, 6"
"396","어느 기업의 직원 테이블(EMP)이 직급(GRADE)별로 사원 500명, 대리 100명, 과장 30명, 차장 10명, 부장 5명, 직급이 정해지지 않은(NULL) 사람 25명으로 구성되어 있을 때, 다음 중 SQL문을 SQL1)부터 SQL3)까지 순차적으로 실행한 결과 건수를 순서대로 나열한 것은?","SQL1) SELECT COUNT(GRADE) FROM EMP;
SQL2) SELECT GRADE FROM EMP WHERE GRADE IN('차장', '부장', '널');
SQL3) SELECT GRADE, COUNT(*) FROM EMP GROUP BY GRADE;","2","3","645, 40, 5"
"396","어느 기업의 직원 테이블(EMP)이 직급(GRADE)별로 사원 500명, 대리 100명, 과장 30명, 차장 10명, 부장 5명, 직급이 정해지지 않은(NULL) 사람 25명으로 구성되어 있을 때, 다음 중 SQL문을 SQL1)부터 SQL3)까지 순차적으로 실행한 결과 건수를 순서대로 나열한 것은?","SQL1) SELECT COUNT(GRADE) FROM EMP;
SQL2) SELECT GRADE FROM EMP WHERE GRADE IN('차장', '부장', '널');
SQL3) SELECT GRADE, COUNT(*) FROM EMP GROUP BY GRADE;","2","4","670, 15, 5"
"407","다음의 ANSI JOIN에서 가장 올바르지 않은 것은?","","3","1","SELECT E.EMPNO, E.DEPTNO, D.DAME FROM EMP E 
INNER JOIN DEPT D ON (E.DEPTNO = D.DEPTNO);"
"407","다음의 ANSI JOIN에서 가장 올바르지 않은 것은?","","3","2","SELECT * FROM DEPT JOIN DEPT_TEMP USING (DEPTNO);"
"407","다음의 ANSI JOIN에서 가장 올바르지 않은 것은?","","3","3","SELECT EMP.DEPTNO, EMPNO, ENAME, DNAME FROM EMP NATURAL JOIN DEPT;"
"407","다음의 ANSI JOIN에서 가장 올바르지 않은 것은?","","3","4","SELECT * FROM EMP a INNER JOIN DEPT b ON a.DEPTNO = b.DEPTNO;"
"408","아래의 SQL 구문 중 결과가 다른 것은?","MytestA 테이블 칼럼: NO, C1
MytestB 테이블 칼럼: NO, C2","2","1","SELECT  A.NO, A.C1, B.C2
FROM MytestA A
JOIN MytestB B
ON (A.NO = B.NO);"
"408","아래의 SQL 구문 중 결과가 다른 것은?","MytestA 테이블 칼럼: NO, C1
MytestB 테이블 칼럼: NO, C2","2","2","SELECT  A.NO, A.C1, B.C2
FROM MytestA A
CROSS JOIN MytestB B;"
"408","아래의 SQL 구문 중 결과가 다른 것은?","MytestA 테이블 칼럼: NO, C1
MytestB 테이블 칼럼: NO, C2","2","3","SELECT  NO, A.C1, B.C2
FROM MytestA A
CROSS JOIN MytestB B;"
"408","아래의 SQL 구문 중 결과가 다른 것은?","MytestA 테이블 칼럼: NO, C1
MytestB 테이블 칼럼: NO, C2","2","4","SELECT  NO, A.C1, B.C2
FROM MytestA A
NATURAL JOIN MytestB B;"
"462","다음 중 VIEW에 대한 설명으로 올바르지 않은 것은?","","2","1","보안성 : 직원의 급여정보와 같이 숨기고 싶은 정보가 존재한다면 뷰를 생성할 때 해당 칼럼을 빼고 생성함으로써 사용자에게 정보를 감출 수 있다."
"462","다음 중 VIEW에 대한 설명으로 올바르지 않은 것은?","","2","2","물리성 : 실제 데이터를 가지고 있어서 물리적인 관리가 가능하다."
"462","다음 중 VIEW에 대한 설명으로 올바르지 않은 것은?","","2","3","편리성 : 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성할 수 있다. 또한 해당 형태의 SQL문을 자주 사용할 때 뷰를 이용하면 편리하게 사용할 수 있다."
"462","다음 중 VIEW에 대한 설명으로 올바르지 않은 것은?","","2","4","독립성 : 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다."
"467","테이블의 칼럼을 변경하는 DDL문으로 올바른 것은?","TEST 테이블의 NAME 칼럼의 데이터 타입을 CHAR에서 VARCHAR로 변경하고 데이터 크기를 100으로 늘린다.","3","1","ALTER table TEST add constraint column name NAME varchar(100)"
"467","테이블의 칼럼을 변경하는 DDL문으로 올바른 것은?","TEST 테이블의 NAME 칼럼의 데이터 타입을 CHAR에서 VARCHAR로 변경하고 데이터 크기를 100으로 늘린다.","3","2","ALTER table TEST add column NAME varchar(100);"
"467","테이블의 칼럼을 변경하는 DDL문으로 올바른 것은?","TEST 테이블의 NAME 칼럼의 데이터 타입을 CHAR에서 VARCHAR로 변경하고 데이터 크기를 100으로 늘린다.","3","3","ALTER table TEST modify (NAME varchar(100));"
"467","테이블의 칼럼을 변경하는 DDL문으로 올바른 것은?","TEST 테이블의 NAME 칼럼의 데이터 타입을 CHAR에서 VARCHAR로 변경하고 데이터 크기를 100으로 늘린다.","3","4","ALTER talbe TEST alter column NAME varchar(100);"
"476","아래의 SQL문을 순차적으로 수행한 결괏값으로 올바른 것은?","CREATE TABLE SQLD_29 (N1 NUMBER);
INSERT INTO SQLD_29 VALUES(1);
INSERT INTO SQLD_29 VALUES(2);
CREATE TABLE TMP_SQLD_29 (N1 NUMBER);
INSERT INTO TMP_SQLD_29 VALUES(1);
TRUNCATE TABLE TMP_SQLD_29;
ROLLBACK;
COMMIT;
SELECT SUM(N1) FROM SQLD_29;","2","1","4"
"476","아래의 SQL문을 순차적으로 수행한 결괏값으로 올바른 것은?","CREATE TABLE SQLD_29 (N1 NUMBER);
INSERT INTO SQLD_29 VALUES(1);
INSERT INTO SQLD_29 VALUES(2);
CREATE TABLE TMP_SQLD_29 (N1 NUMBER);
INSERT INTO TMP_SQLD_29 VALUES(1);
TRUNCATE TABLE TMP_SQLD_29;
ROLLBACK;
COMMIT;
SELECT SUM(N1) FROM SQLD_29;","2","2","3"
"476","아래의 SQL문을 순차적으로 수행한 결괏값으로 올바른 것은?","CREATE TABLE SQLD_29 (N1 NUMBER);
INSERT INTO SQLD_29 VALUES(1);
INSERT INTO SQLD_29 VALUES(2);
CREATE TABLE TMP_SQLD_29 (N1 NUMBER);
INSERT INTO TMP_SQLD_29 VALUES(1);
TRUNCATE TABLE TMP_SQLD_29;
ROLLBACK;
COMMIT;
SELECT SUM(N1) FROM SQLD_29;","2","3","1"
"476","아래의 SQL문을 순차적으로 수행한 결괏값으로 올바른 것은?","CREATE TABLE SQLD_29 (N1 NUMBER);
INSERT INTO SQLD_29 VALUES(1);
INSERT INTO SQLD_29 VALUES(2);
CREATE TABLE TMP_SQLD_29 (N1 NUMBER);
INSERT INTO TMP_SQLD_29 VALUES(1);
TRUNCATE TABLE TMP_SQLD_29;
ROLLBACK;
COMMIT;
SELECT SUM(N1) FROM SQLD_29;","2","4","NULL"
"478","아래 설명 중 빈칸에 해당하는 내용을 작성하시오.","ABC기업에 입사한 새로운 개발자에게 권한을 부여할 때 사용하는 것은 ( ㄱ ) 이고 권한을 회수할 때 사용하는 것은 ( ㄴ )이다.","2","1","ㄱ. AUTHORIZE  ㄴ.REMOVE"
"478","아래 설명 중 빈칸에 해당하는 내용을 작성하시오.","ABC기업에 입사한 새로운 개발자에게 권한을 부여할 때 사용하는 것은 ( ㄱ ) 이고 권한을 회수할 때 사용하는 것은 ( ㄴ )이다.","2","2","ㄱ.GRANT ㄴ.REVOKE"
"478","아래 설명 중 빈칸에 해당하는 내용을 작성하시오.","ABC기업에 입사한 새로운 개발자에게 권한을 부여할 때 사용하는 것은 ( ㄱ ) 이고 권한을 회수할 때 사용하는 것은 ( ㄴ )이다.","2","3","ㄱ.ALLOW ㄴ.REVOKE"
"478","아래 설명 중 빈칸에 해당하는 내용을 작성하시오.","ABC기업에 입사한 새로운 개발자에게 권한을 부여할 때 사용하는 것은 ( ㄱ ) 이고 권한을 회수할 때 사용하는 것은 ( ㄴ )이다.","2","4","ㄱ.GRANT ㄴ.WITHDRAW"
"501","다음의 PL/SQL에 대한 설명으로 올바르지 않은 것은?","","3","1","PL/SQL에서 name이라는 변수에 'aaa'를 대입할 경우 "":=""을 사용한다."
"501","다음의 PL/SQL에 대한 설명으로 올바르지 않은 것은?","","3","2","PL/SQL에서 조건문은 IF~ THEN~ ELSEIF~ END IF 와 CASE~WHEN을 사용한다."
"501","다음의 PL/SQL에 대한 설명으로 올바르지 않은 것은?","","3","3","PL/SQL에서 테이블을 생성할 수는 없다."
"501","다음의 PL/SQL에 대한 설명으로 올바르지 않은 것은?","","3","4","PL/SQL은 절차형 언어이다."
"504","Orders 테이블의 고객id에는 Customers 테이블에 존재하지 않는 고객id도 있다. Customers  테이블에 존재하지 않는 고객id만 Orders 테이블에서 추출하는 SQL을 (  )를 채워 완성하시오.","SELECT * FROM Orders
WHERE ( ㄱ ) (SELECT * FROM Customers WHERE (  ㄴ  ));","2","1","ㄱ: NOT EXISTS
ㄴ: Customers. id <> Orders. id"
"504","Orders 테이블의 고객id에는 Customers 테이블에 존재하지 않는 고객id도 있다. Customers  테이블에 존재하지 않는 고객id만 Orders 테이블에서 추출하는 SQL을 (  )를 채워 완성하시오.","SELECT * FROM Orders
WHERE ( ㄱ ) (SELECT * FROM Customers WHERE (  ㄴ  ));","2","2","ㄱ: NOT EXISTS
ㄴ: Customers. id = Orders. id"
"504","Orders 테이블의 고객id에는 Customers 테이블에 존재하지 않는 고객id도 있다. Customers  테이블에 존재하지 않는 고객id만 Orders 테이블에서 추출하는 SQL을 (  )를 채워 완성하시오.","SELECT * FROM Orders
WHERE ( ㄱ ) (SELECT * FROM Customers WHERE (  ㄴ  ));","2","3","ㄱ: EXISTS
ㄴ: Customers. id <> Orders. id"
"504","Orders 테이블의 고객id에는 Customers 테이블에 존재하지 않는 고객id도 있다. Customers  테이블에 존재하지 않는 고객id만 Orders 테이블에서 추출하는 SQL을 (  )를 채워 완성하시오.","SELECT * FROM Orders
WHERE ( ㄱ ) (SELECT * FROM Customers WHERE (  ㄴ  ));","2","4","ㄱ: EXISTS
ㄴ: Customers. id = Orders. id"
"518","Gender 칼럼이 0이면 남자, 1이면 여자를 출력
SELECT ( ㄱ ) FROM EMP;

V_NAME은 문자열 변수
SELECT NAME ( ㄴ ) V_NAME FROM EMP;","","4","1","ㄱ : DECODE(GENDER, 0, '남자', '여자'), ㄴ : ON"
"518","Gender 칼럼이 0이면 남자, 1이면 여자를 출력
SELECT ( ㄱ ) FROM EMP;

V_NAME은 문자열 변수
SELECT NAME ( ㄴ ) V_NAME FROM EMP;","","4","2","ㄱ : DECODE(GENDER, 0, '남자', '여자'), ㄴ : INTO"
"518","Gender 칼럼이 0이면 남자, 1이면 여자를 출력
SELECT ( ㄱ ) FROM EMP;

V_NAME은 문자열 변수
SELECT NAME ( ㄴ ) V_NAME FROM EMP;","","4","3","ㄱ : DECODE(GENDER, 1, '남자', '여자'), ㄴ : ON"
"518","Gender 칼럼이 0이면 남자, 1이면 여자를 출력
SELECT ( ㄱ ) FROM EMP;

V_NAME은 문자열 변수
SELECT NAME ( ㄴ ) V_NAME FROM EMP;","","4","4","ㄱ : DECODE(GENDER, 0, '남자', '여자'), ㄴ : INTO"
"526","다음 설명에 해당하는 속성의 종류는 무엇인가?","ABC 온라인 쇼핑몰은 매일 고객들의 주문정보를 주문 릴레이션에 저장하고 있다. 그리고 매일 24시에 주문 릴레이션에 있는 금액을 조회하여 일별 주문합계 테이블에 상품별, 일별, 주문합계 금액을 보관한다. 이때 주문 릴레이션의 금액 속성에 의해서 발생된 주문합계 속성은 무엇이라고 하는가? 또한 주문합계 속성은 금액 속성과 데이터 정합성을 유지해야 한다.","4","1","연관 속성"
"526","다음 설명에 해당하는 속성의 종류는 무엇인가?","ABC 온라인 쇼핑몰은 매일 고객들의 주문정보를 주문 릴레이션에 저장하고 있다. 그리고 매일 24시에 주문 릴레이션에 있는 금액을 조회하여 일별 주문합계 테이블에 상품별, 일별, 주문합계 금액을 보관한다. 이때 주문 릴레이션의 금액 속성에 의해서 발생된 주문합계 속성은 무엇이라고 하는가? 또한 주문합계 속성은 금액 속성과 데이터 정합성을 유지해야 한다.","4","2","설계 속성"
"526","다음 설명에 해당하는 속성의 종류는 무엇인가?","ABC 온라인 쇼핑몰은 매일 고객들의 주문정보를 주문 릴레이션에 저장하고 있다. 그리고 매일 24시에 주문 릴레이션에 있는 금액을 조회하여 일별 주문합계 테이블에 상품별, 일별, 주문합계 금액을 보관한다. 이때 주문 릴레이션의 금액 속성에 의해서 발생된 주문합계 속성은 무엇이라고 하는가? 또한 주문합계 속성은 금액 속성과 데이터 정합성을 유지해야 한다.","4","3","기본 속성"
"526","다음 설명에 해당하는 속성의 종류는 무엇인가?","ABC 온라인 쇼핑몰은 매일 고객들의 주문정보를 주문 릴레이션에 저장하고 있다. 그리고 매일 24시에 주문 릴레이션에 있는 금액을 조회하여 일별 주문합계 테이블에 상품별, 일별, 주문합계 금액을 보관한다. 이때 주문 릴레이션의 금액 속성에 의해서 발생된 주문합계 속성은 무엇이라고 하는가? 또한 주문합계 속성은 금액 속성과 데이터 정합성을 유지해야 한다.","4","4","파생 속성"
"542","다음 보기 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","1","고유키 제약이 설정되면 NULL값을 가질 수 없다."
"542","다음 보기 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","2","Check 제약조건은 특정값만 입력되게 제약한다."
"542","다음 보기 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","3","기본키는 제약사항을 테이블 당 하나만 제약할 수 있다."
"542","다음 보기 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","4","외래키는 두 개의 테이블 간의 참조 무결성을 제약한다."
"572","다음중 엔터티의 특징이 아닌 것은?","","1","1","정규화 이론에 근간하여 정해진 주식별자는 함수적 종속성을 가져야 한다."
"572","다음중 엔터티의 특징이 아닌 것은?","","1","2","엔터티는 반드시 속성이 있어야 한다."
"572","다음중 엔터티의 특징이 아닌 것은?","","1","3","유일한 식별자에 의해 식별이 가능해야 한다."
"572","다음중 엔터티의 특징이 아닌 것은?","","1","4","반드시 해당 업무에서 필요하고 관리되어야 하는 정보이어야 한다."
"676","다음이 설명하는 정규화로 가장 적절한 것은?","테이블의 컬럼이 원자성(한 속성이 하나의 값을 갖는 특성)을 갖도록 테이블을 분해하는 단계","4","1","제 4 정규화"
"676","다음이 설명하는 정규화로 가장 적절한 것은?","테이블의 컬럼이 원자성(한 속성이 하나의 값을 갖는 특성)을 갖도록 테이블을 분해하는 단계","4","2","제 3 정규화"
"676","다음이 설명하는 정규화로 가장 적절한 것은?","테이블의 컬럼이 원자성(한 속성이 하나의 값을 갖는 특성)을 갖도록 테이블을 분해하는 단계","4","3","제 2 정규화"
"676","다음이 설명하는 정규화로 가장 적절한 것은?","테이블의 컬럼이 원자성(한 속성이 하나의 값을 갖는 특성)을 갖도록 테이블을 분해하는 단계","4","4","제 1 정규화"
"678","다음 중 트랜잭션에 대한 설명으로 가장 적절하지 않은 것은? ","","2","1","하나의 트랜잭션에는 여러 SELECT, INSERT, DELETE, UPDATE 등이 포함될 수 있다."
"678","다음 중 트랜잭션에 대한 설명으로 가장 적절하지 않은 것은? ","","2","2","하나의 트랜잭션은 부분 COMMIT이 가능하다."
"678","다음 중 트랜잭션에 대한 설명으로 가장 적절하지 않은 것은? ","","2","3","두 엔터티가 서로 독립적 수행이 가능하다면 선택적 관계로 표현한다."
"678","다음 중 트랜잭션에 대한 설명으로 가장 적절하지 않은 것은? ","","2","4","두 엔터티의 관계가 서로 필수적일 때 하나의 트랜잭션을 형성한다."
"684","다음 중 DISTINCT에 대한 설명으로 가장 적절하지 않은 것은?","","2","1","DISTINCT 뒤에 * 를 사용할 수 있다."
"684","다음 중 DISTINCT에 대한 설명으로 가장 적절하지 않은 것은?","","2","2","DISTINCT 뒤에 나열되는 컬럼의 순서에 따라 결과 집합의 수가 달라진다."
"684","다음 중 DISTINCT에 대한 설명으로 가장 적절하지 않은 것은?","","2","3","SELECT 문에서만 사용 가능하다."
"684","다음 중 DISTINCT에 대한 설명으로 가장 적절하지 않은 것은?","","2","4","DISTINCT 뒤에 나열되는 컬럼들의 중복값을 한 번만 출력하기 위해 사용한다."
"712","다음 SQL 실행 결과로 알맞은 것은?","SELECT LENGTH(REGEXP_REPLACE('REGEXP \. ESCAPE CHARACTER, A|B : A OR B', '[A-z|0-9\. ]'))  FROM DUAL;","4","1","5"
"712","다음 SQL 실행 결과로 알맞은 것은?","SELECT LENGTH(REGEXP_REPLACE('REGEXP \. ESCAPE CHARACTER, A|B : A OR B', '[A-z|0-9\. ]'))  FROM DUAL;","4","2","4"
"712","다음 SQL 실행 결과로 알맞은 것은?","SELECT LENGTH(REGEXP_REPLACE('REGEXP \. ESCAPE CHARACTER, A|B : A OR B', '[A-z|0-9\. ]'))  FROM DUAL;","4","3","3"
"712","다음 SQL 실행 결과로 알맞은 것은?","SELECT LENGTH(REGEXP_REPLACE('REGEXP \. ESCAPE CHARACTER, A|B : A OR B', '[A-z|0-9\. ]'))  FROM DUAL;","4","4","2"
"714","COMMIT 이후의 데이터 상태로 옳지 않은 것은? ","","1","1","COMMIT을 수행한 사용자만 결과를 볼 수 있다."
"714","COMMIT 이후의 데이터 상태로 옳지 않은 것은? ","","1","2","이전 데이터는 영원히 되돌릴 수 없다."
"714","COMMIT 이후의 데이터 상태로 옳지 않은 것은? ","","1","3","변경된 행에 대한 잠금이 풀리고 다른 사용자들이 행을 조작할 수 있다."
"714","COMMIT 이후의 데이터 상태로 옳지 않은 것은? ","","1","4","데이터에 대한 변경 사항이 데이터베이스에 영구 저장된다."
"721","다음이 설명하는 모델링의 특징으로 가장 적절한 것은?","누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술하는 것을 의미한다.","4","1","그룹화"
"721","다음이 설명하는 모델링의 특징으로 가장 적절한 것은?","누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술하는 것을 의미한다.","4","2","단순화"
"721","다음이 설명하는 모델링의 특징으로 가장 적절한 것은?","누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술하는 것을 의미한다.","4","3","추상화"
"721","다음이 설명하는 모델링의 특징으로 가장 적절한 것은?","누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술하는 것을 의미한다.","4","4","명확화"
"723","다음 중 속성에 대한 설명 중 가장 적절하지 않은 것은?","","1","1","파생속성은 가급적 많이 정의할수록 좋은 속성이다."
"723","다음 중 속성에 대한 설명 중 가장 적절하지 않은 것은?","","1","2","파생속성은 다른 속성에 영향을 받아 발생하는 속성이다."
"723","다음 중 속성에 대한 설명 중 가장 적절하지 않은 것은?","","1","3","설계 속성은 업무상 필요한 데이터 외에 업무를 규칙화하기 위하여 기본 속성을 변형하는 속성이다."
"723","다음 중 속성에 대한 설명 중 가장 적절하지 않은 것은?","","1","4","기본속성에 대한 예를 들자면 일련번호이다."
"735","다음 함수의 출력 결과로 가장 적절하지 않은 것은?","","2","1","LAST_DAY(TO_DATE('2024-01-01','YYYY-MM-DD')) : 2024-01-31"
"735","다음 함수의 출력 결과로 가장 적절하지 않은 것은?","","2","2","POWER(3,3) = 9"
"735","다음 함수의 출력 결과로 가장 적절하지 않은 것은?","","2","3","FLOOR(3.5) = 3"
"735","다음 함수의 출력 결과로 가장 적절하지 않은 것은?","","2","4","DATE_FORMAT('2024-01-01','%Y-%m-%d') : 2024-01-01"
"753","집합 연산자 사용시 주의사항에 대한 설명으로 가장 적절하지 않은 것은?","","1","1","위 집합의 컬럼의 사이즈보다 아래 집합의 컬럼 사이즈가 큰 경우 연산이 불가하다."
"753","집합 연산자 사용시 주의사항에 대한 설명으로 가장 적절하지 않은 것은?","","1","2","두 집합 중 위의 집합의 컬럼명을 전체 집합의 컬럼명으로 가져간다."
"753","집합 연산자 사용시 주의사항에 대한 설명으로 가장 적절하지 않은 것은?","","1","3","두 집합의 각 컬럼의 데이터 유형이 일치해야 한다."
"753","집합 연산자 사용시 주의사항에 대한 설명으로 가장 적절하지 않은 것은?","","1","4","두 집합의 컬럼 수가 일치해야 한다."
"764","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_SUBSTR('123-234-4545-233', '((\d+)-(\d+))-((\d+)-(\d+))', 1, 1, NULL, 4) FROM DUAL;","2","1","4545"
"764","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_SUBSTR('123-234-4545-233', '((\d+)-(\d+))-((\d+)-(\d+))', 1, 1, NULL, 4) FROM DUAL;","2","2","4545-233"
"764","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_SUBSTR('123-234-4545-233', '((\d+)-(\d+))-((\d+)-(\d+))', 1, 1, NULL, 4) FROM DUAL;","2","3","234"
"764","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_SUBSTR('123-234-4545-233', '((\d+)-(\d+))-((\d+)-(\d+))', 1, 1, NULL, 4) FROM DUAL;","2","4","233"
"786","다음의 연산 결과가 다른 하나는?","","1","1","SELECT LAST_DAY(TO_DATE('2024/05/14', 'YYYY/MM/DD')) FROM DUAL;"
"786","다음의 연산 결과가 다른 하나는?","","1","2","SELECT TO_DATE('2024/05', 'YYYY/MM') FROM DUAL;"
"786","다음의 연산 결과가 다른 하나는?","","1","3","SELECT ROUND(TO_DATE('2024/05/14', 'YYYY/MM/DD'), 'MONTH') FROM DUAL;"
"786","다음의 연산 결과가 다른 하나는?","","1","4","SELECT TRUNC(TO_DATE('2024/05/14', 'YYYY/MM/DD'), 'MONTH') FROM DUAL;"
"238","숫자형 함수 적용과 그 결괏값이 올바르지 않은 것은?","","2","1","CEIL(38,12)=39"
"238","숫자형 함수 적용과 그 결괏값이 올바르지 않은 것은?","","2","2","MOD(7,3)=2"
"238","숫자형 함수 적용과 그 결괏값이 올바르지 않은 것은?","","2","3","SIGN(-50)=-1"
"238","숫자형 함수 적용과 그 결괏값이 올바르지 않은 것은?","","2","4","ABS(-30)=30"
"240","다음 중 옳지 않은 것은?","","4","1","COUNT(표현식)은 표현식의 값이 NULL값인 것을 제외한 행 수를 출력한다."
"240","다음 중 옳지 않은 것은?","","4","2","(날짜1 - 날짜2)의 결과는 일수가 나온다."
"240","다음 중 옳지 않은 것은?","","4","3","CASE 문은 IF-THEN-ELSE를 구현 할 수 있다."
"240","다음 중 옳지 않은 것은?","","4","4","Length('LIMBEST') = 8"
"267","고객 엔터티에 고객 ID, 이름, 주소가 있다. 이 때 주소는 어떤 속성인가?","","1","1","복합 속성"
"267","고객 엔터티에 고객 ID, 이름, 주소가 있다. 이 때 주소는 어떤 속성인가?","","1","2","설계 속성 "
"267","고객 엔터티에 고객 ID, 이름, 주소가 있다. 이 때 주소는 어떤 속성인가?","","1","3","일반 속성"
"267","고객 엔터티에 고객 ID, 이름, 주소가 있다. 이 때 주소는 어떤 속성인가?","","1","4","파생 속성"
"805","엔터티(Entity)의 정의로 옳은 것은?","","3","1","업무를 수행하는 사람"
"805","엔터티(Entity)의 정의로 옳은 것은?","","3","2","데이터베이스에서 속성을 나타내는 것"
"805","엔터티(Entity)의 정의로 옳은 것은?","","3","3","저장할 필요가 있는 데이터의 집합"
"805","엔터티(Entity)의 정의로 옳은 것은?","","3","4","비즈니스 규칙"
"806","다음 중 정규화의 주요 목적이 아닌 것은?","","3","1","중복 데이터 제거"
"806","다음 중 정규화의 주요 목적이 아닌 것은?","","3","2","무결성 향상"
"806","다음 중 정규화의 주요 목적이 아닌 것은?","","3","3","성능 향상"
"806","다음 중 정규화의 주요 목적이 아닌 것은?","","3","4","종속성 제거"
"2","다음 설명 중 데이터 모델링이 필요한 주요 이유로 가장 부적절한 것은?","","2","1","데이터모델링 자체로서 업무의 흐름을 설명하고 분석하는 부분에 의미를 가지고 있다."
"2","다음 설명 중 데이터 모델링이 필요한 주요 이유로 가장 부적절한 것은?","","2","2","데이터베이스를 구축하기 위한 용도를 위해 데이터모델링을 수행하고 업무에 대한 설명은 별도의 표기법을 이용한다."
"2","다음 설명 중 데이터 모델링이 필요한 주요 이유로 가장 부적절한 것은?","","2","3","분석된 모델을 가지고 데이터베이스를 생성하여 개발 및 데이터관리에 사용하기 위한 것이다."
"2","다음 설명 중 데이터 모델링이 필요한 주요 이유로 가장 부적절한 것은?","","2","4","업무정보를 구성하는 기초가 되는 정보들에 대해 일정한 표기법에 의해 표현한다."
"3","다음 중 데이터모델링을 할 때 유의해야 할 사항으로 가장 부적절한 것은?","","2","1","데이터간의 상호 연관관계를 명확하게 정의하여 일관성 있게 데이터가 유지되도록 한다."
"3","다음 중 데이터모델링을 할 때 유의해야 할 사항으로 가장 부적절한 것은?","","2","2","사용자가 처리하는 프로세스나 장표 등에 따라 매핑이 될 수 있도록 프로그램과 테이블간의 연계성을 높인다."
"3","다음 중 데이터모델링을 할 때 유의해야 할 사항으로 가장 부적절한 것은?","","2","3","데이터의 정의를 데이터의 사용 프로세스와 분리하여 유연성을 높인다."
"3","다음 중 데이터모델링을 할 때 유의해야 할 사항으로 가장 부적절한 것은?","","2","4","여러 장소의 데이터베이스에 같은 정보를 저장하지 않도록 하여 중복성을 최소화 한다."
"5","다음 중 아래 데이터모델링 개념에 대한 설명에서 (ㄱ),(ㄴ) 에 들어갈 단어로 가장 적절한 것은?","전사적 데이터 모델링을 수행할 때 많이 하며, 추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링을 진행하는 것을 (ㄱ) 데이터 모델링 이라고 한다. 이와 달리 실제로 데이터베이스에 이식 할 수 있도록 성능, 저장 등의 물리적인 성격을 고려한 데이터 모델링은  (ㄴ) 데이터모델링 이라고 한다.","4","1","ㄱ - 개념적, ㄴ - 논리적"
"5","다음 중 아래 데이터모델링 개념에 대한 설명에서 (ㄱ),(ㄴ) 에 들어갈 단어로 가장 적절한 것은?","전사적 데이터 모델링을 수행할 때 많이 하며, 추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링을 진행하는 것을 (ㄱ) 데이터 모델링 이라고 한다. 이와 달리 실제로 데이터베이스에 이식 할 수 있도록 성능, 저장 등의 물리적인 성격을 고려한 데이터 모델링은  (ㄴ) 데이터모델링 이라고 한다.","4","2","ㄱ - 논리적, ㄴ - 물리적"
"5","다음 중 아래 데이터모델링 개념에 대한 설명에서 (ㄱ),(ㄴ) 에 들어갈 단어로 가장 적절한 것은?","전사적 데이터 모델링을 수행할 때 많이 하며, 추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링을 진행하는 것을 (ㄱ) 데이터 모델링 이라고 한다. 이와 달리 실제로 데이터베이스에 이식 할 수 있도록 성능, 저장 등의 물리적인 성격을 고려한 데이터 모델링은  (ㄴ) 데이터모델링 이라고 한다.","4","3","ㄱ - 논리적, ㄴ - 개념적"
"5","다음 중 아래 데이터모델링 개념에 대한 설명에서 (ㄱ),(ㄴ) 에 들어갈 단어로 가장 적절한 것은?","전사적 데이터 모델링을 수행할 때 많이 하며, 추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링을 진행하는 것을 (ㄱ) 데이터 모델링 이라고 한다. 이와 달리 실제로 데이터베이스에 이식 할 수 있도록 성능, 저장 등의 물리적인 성격을 고려한 데이터 모델링은  (ㄴ) 데이터모델링 이라고 한다.","4","4","ㄱ - 개념적, ㄴ - 물리적"
"18","다음 중 데이터모델링을 할 때 속성의 명칭을 부여하는 방법으로 가장 부적절한 것은?","","2","1","데이터모델링 대상에서 사용하는 용어도 있고 외부에서 사용하는 용어도 있어 중복이 있을 때, 가급적 해당 업무에서 자주 사용하는 이름을 이용하도록 한다."
"18","다음 중 데이터모델링을 할 때 속성의 명칭을 부여하는 방법으로 가장 부적절한 것은?","","2","2","직원 엔터티의 이름, 고객 엔터티의 이름과 같이 각 엔터티별로 동일한 속성명을 사용하여 데이터모델의 일관성을 가져가는 것이 좋다."
"18","다음 중 데이터모델링을 할 때 속성의 명칭을 부여하는 방법으로 가장 부적절한 것은?","","2","3","속성의 이름에는 서술식 용어는 사용하지 않도록 한다."
"18","다음 중 데이터모델링을 할 때 속성의 명칭을 부여하는 방법으로 가장 부적절한 것은?","","2","4","속성의 이름에 약어를 사용할 경우 그 의미를 명확하게 이해할 수 없고 혼돈을 초래하여 커뮤니케이션의 혼란을 야기할수 있으므로 지나친 약어 사용은 가급적 제한하도록 한다."
"23","다음 중 두 개의 엔터티 사이에서 관계를 도출 할 때 체크 할 사항을 모두 고른 것은?","가. 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
나. 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
다. 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
라. 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb) 가 있 는가?","1","1","가,나다,라"
"23","다음 중 두 개의 엔터티 사이에서 관계를 도출 할 때 체크 할 사항을 모두 고른 것은?","가. 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
나. 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
다. 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
라. 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb) 가 있 는가?","1","2","가,나,다"
"23","다음 중 두 개의 엔터티 사이에서 관계를 도출 할 때 체크 할 사항을 모두 고른 것은?","가. 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
나. 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
다. 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
라. 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb) 가 있 는가?","1","3","가,나,라"
"23","다음 중 두 개의 엔터티 사이에서 관계를 도출 할 때 체크 할 사항을 모두 고른 것은?","가. 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
나. 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
다. 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
라. 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb) 가 있 는가?","1","4","가,다,라"
"31","다음중 아래에서 성능을 고려한 데이터 모델링의 순서로 가장 적절한 것은?","가. 데이터 모델링을 할 때 정규화를 정확하게 수행한다.
나. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
다. 데이터베이스 용량산정을 수행한다.
라. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
마. 성능관점에서 데이터 모델을 검증한다.
바. 이력모델의 조정,  PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.","1","1","가-다-라-나-바-마"
"31","다음중 아래에서 성능을 고려한 데이터 모델링의 순서로 가장 적절한 것은?","가. 데이터 모델링을 할 때 정규화를 정확하게 수행한다.
나. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
다. 데이터베이스 용량산정을 수행한다.
라. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
마. 성능관점에서 데이터 모델을 검증한다.
바. 이력모델의 조정,  PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.","1","2","가-다-라-바-나-마"
"31","다음중 아래에서 성능을 고려한 데이터 모델링의 순서로 가장 적절한 것은?","가. 데이터 모델링을 할 때 정규화를 정확하게 수행한다.
나. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
다. 데이터베이스 용량산정을 수행한다.
라. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
마. 성능관점에서 데이터 모델을 검증한다.
바. 이력모델의 조정,  PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.","1","3","가-나-다-라-바-마"
"31","다음중 아래에서 성능을 고려한 데이터 모델링의 순서로 가장 적절한 것은?","가. 데이터 모델링을 할 때 정규화를 정확하게 수행한다.
나. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
다. 데이터베이스 용량산정을 수행한다.
라. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
마. 성능관점에서 데이터 모델을 검증한다.
바. 이력모델의 조정,  PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.","1","4","가-나-다-라-마-바"
"40","데이터베이스를 정의하고 접근하기 위해서는 데이터베아스 관리 시스템과의 통신수단이 필요한데 이를 데이터 언어(Data Language) 라고 하며, 그 가능과 사용 목적에 따라 데이터 정의어(DDJ, 데이터 조작어(DML) 데이터 제어어(DCL)로 구분된다. 다음 중 데이터 언어와 SQL 명령어에 대한 설명으로 가장 부적절한 것은? ","","4","1","호스트 프로그램 속에 삽입되어 사용되는 DML 명령어들을 데이터 부속어 (Data Sub Language) 라고 한다."
"40","데이터베이스를 정의하고 접근하기 위해서는 데이터베아스 관리 시스템과의 통신수단이 필요한데 이를 데이터 언어(Data Language) 라고 하며, 그 가능과 사용 목적에 따라 데이터 정의어(DDJ, 데이터 조작어(DML) 데이터 제어어(DCL)로 구분된다. 다음 중 데이터 언어와 SQL 명령어에 대한 설명으로 가장 부적절한 것은? ","","4","2","DDL은 스키마, 도메인, 테이블, 뷰, 인덱스를 정의하거나 변경 또는 제거할 때 사용되며 CREATE, ALTER, DROP, RENAME 등이 있다."
"40","데이터베이스를 정의하고 접근하기 위해서는 데이터베아스 관리 시스템과의 통신수단이 필요한데 이를 데이터 언어(Data Language) 라고 하며, 그 가능과 사용 목적에 따라 데이터 정의어(DDJ, 데이터 조작어(DML) 데이터 제어어(DCL)로 구분된다. 다음 중 데이터 언어와 SQL 명령어에 대한 설명으로 가장 부적절한 것은? ","","4","3","DML은 데이터베이스 사용자가 응용 프로그램이나 질의어를 통하여 저장된 데이터베이스를 실질적으로 접근하는데 사용되며 SELECT, INSERT, DELETE, UPDATE 등이 있다. "
"40","데이터베이스를 정의하고 접근하기 위해서는 데이터베아스 관리 시스템과의 통신수단이 필요한데 이를 데이터 언어(Data Language) 라고 하며, 그 가능과 사용 목적에 따라 데이터 정의어(DDJ, 데이터 조작어(DML) 데이터 제어어(DCL)로 구분된다. 다음 중 데이터 언어와 SQL 명령어에 대한 설명으로 가장 부적절한 것은? ","","4","4","비절차적 데이터 조작어(DML)는 사용자가 무슨 데이터를 원하며, 어떻게 그것을 접근해야 되는지를 명세하는 언어이다."
"52","표준 SQL(SQL1999)에서테이블 생성시참조관계를정의하기 위해 외래키 (Foreign Key)를 선언한다. 관계형 데이터베이스에서 Child Table의 FK 데이터 생성시 Parent Table에 PK가 없는 경우, Child Table 데이터 입력을 허용하지 않는 참조동작(Referential Action)인 것은?","","1","1","DEPENDENT"
"52","표준 SQL(SQL1999)에서테이블 생성시참조관계를정의하기 위해 외래키 (Foreign Key)를 선언한다. 관계형 데이터베이스에서 Child Table의 FK 데이터 생성시 Parent Table에 PK가 없는 경우, Child Table 데이터 입력을 허용하지 않는 참조동작(Referential Action)인 것은?","","1","2","AUTOMATIC"
"52","표준 SQL(SQL1999)에서테이블 생성시참조관계를정의하기 위해 외래키 (Foreign Key)를 선언한다. 관계형 데이터베이스에서 Child Table의 FK 데이터 생성시 Parent Table에 PK가 없는 경우, Child Table 데이터 입력을 허용하지 않는 참조동작(Referential Action)인 것은?","","1","3","RESTRICT"
"52","표준 SQL(SQL1999)에서테이블 생성시참조관계를정의하기 위해 외래키 (Foreign Key)를 선언한다. 관계형 데이터베이스에서 Child Table의 FK 데이터 생성시 Parent Table에 PK가 없는 경우, Child Table 데이터 입력을 허용하지 않는 참조동작(Referential Action)인 것은?","","1","4","CASCADE"
"85","다음 중 SELECT 문장의 실행 순서를 올바르게 나열한 것은?","","1","1","FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY"
"85","다음 중 SELECT 문장의 실행 순서를 올바르게 나열한 것은?","","1","2","FROM - WHERE - GROUP BY - HAVING - ORDER BY - SELECT"
"85","다음 중 SELECT 문장의 실행 순서를 올바르게 나열한 것은?","","1","3","FROM - SELECT - WHERE - GROUP BY - HAVING - ORDER BY"
"85","다음 중 SELECT 문장의 실행 순서를 올바르게 나열한 것은?","","1","4","SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY"
"126","다음 설명 중 가장 적절한 것은?","","1","1","CUBE 그룹 함수는 인자로 주어진 컬럼의 결합 가능한 모든 조합에 대해서 집계를 수행하므로 다른 그룹 함수에 비해 시스템에 대한 부하가 크다."
"126","다음 설명 중 가장 적절한 것은?","","1","2","CUBE, ROLLUP, GROUPING SETS 함수들의 대상 컬럼 중 집계된 컬럼 이외의 대상 컬럼 값은 해당 컬럼의 데이터 중 가장 작은 값을 반환한다."
"126","다음 설명 중 가장 적절한 것은?","","1","3","GROUPING SETS 함수의 경우에는 함수의 인자로 주어진 컬럼의 순서에 따라 결과가 달라지므로 컬럼의 순서가 중요하다."
"126","다음 설명 중 가장 적절한 것은?","","1","4","일반 그룹 함수를 사용하여 CUBE, GROUPING SETS와 같은 그룹함수와 동일한 결과를 추출할 수 있으나, ROLLUP 그룹 함수와 동일한 결과는 추출할 수 없다."
"142","다음 중 정보시스템을 모델링할 때 세가지 관점에 해당하지 않는 것은?","모델링을 할 때의 세 가지 관점은 데이터에 대한 관점, 프로세스에 대한 관점, 그리고 데이터와 프로세스가 서로 연관성이 표현되는 상관 관점이다.","2","1","업무에서 처리하는 일의 방법에 따라 데이터가 어떻게 영향을 받는지 분석"
"142","다음 중 정보시스템을 모델링할 때 세가지 관점에 해당하지 않는 것은?","모델링을 할 때의 세 가지 관점은 데이터에 대한 관점, 프로세스에 대한 관점, 그리고 데이터와 프로세스가 서로 연관성이 표현되는 상관 관점이다.","2","2","업무를 처리할 수 있는 프로그램 구성을 어떻게 해야 하는지 분석"
"142","다음 중 정보시스템을 모델링할 때 세가지 관점에 해당하지 않는 것은?","모델링을 할 때의 세 가지 관점은 데이터에 대한 관점, 프로세스에 대한 관점, 그리고 데이터와 프로세스가 서로 연관성이 표현되는 상관 관점이다.","2","3","업무에서 실제로 하는 일은 무엇인지 또는 무엇을 해야 하는지 분석"
"142","다음 중 정보시스템을 모델링할 때 세가지 관점에 해당하지 않는 것은?","모델링을 할 때의 세 가지 관점은 데이터에 대한 관점, 프로세스에 대한 관점, 그리고 데이터와 프로세스가 서로 연관성이 표현되는 상관 관점이다.","2","4","업무가 어떤 데이터와 관련이 있는지 분석"
"155","다음 중 분산 데이터베이스의 특징으로 가장 부적절한 것은?","","1","1","처리 비용의 감소"
"155","다음 중 분산 데이터베이스의 특징으로 가장 부적절한 것은?","","1","2","오류의 잠재성 증대"
"155","다음 중 분산 데이터베이스의 특징으로 가장 부적절한 것은?","","1","3","빠른 응답 속도와 통신 비용 절감"
"155","다음 중 분산 데이터베이스의 특징으로 가장 부적절한 것은?","","1","4","지역 자치성, 점증적 시스템 용량 확장"
"182","JOIN의 종류에 대한 설명으로 틀린 것은 무엇인가?","","3","1","SELF JOIN은 하나의 테이블을 논리적으로 분리시켜 EQUI JOIN을 이용하는 방법이다."
"182","JOIN의 종류에 대한 설명으로 틀린 것은 무엇인가?","","3","2","OUTER JOIN은 JOIN 조건을 만족하지 않는 데이터도 볼 수 있는 JOIN 방법이다."
"182","JOIN의 종류에 대한 설명으로 틀린 것은 무엇인가?","","3","3","EQUI JOIN은 반드시 기본키, 외래키 관계에 의해서만 성립된다."
"182","JOIN의 종류에 대한 설명으로 틀린 것은 무엇인가?","","3","4","NON-EQUI JOIN은 등가 조건이 성립되지 않은 테이블에 JOIN을 걸어주는 방법이다."
"193","다음 주어진 SQL문을 수행한 결과 영구적으로 반영되는 것은 무엇인가?","INSERT INTO TAB1 VALUES(1);
INSERT INTO TAB1 VALUES(2);
SAVEPOINT SV1;
UPDATE TAB1 SET COL1=7 WHERE COL1=2;
INSERT INTO TAB1 VALUES(9);
SAVEPOINT SV2;
DELETE TAB1 WHERE COL1=7;
INSERT INTO TAB1 VALUES(11);
SAVEPOINT SV3;
INSERT INTO TAB1 VALUES(9);
ROLLBACK TO SV2;
COMMIT;","4","1","1,2"
"193","다음 주어진 SQL문을 수행한 결과 영구적으로 반영되는 것은 무엇인가?","INSERT INTO TAB1 VALUES(1);
INSERT INTO TAB1 VALUES(2);
SAVEPOINT SV1;
UPDATE TAB1 SET COL1=7 WHERE COL1=2;
INSERT INTO TAB1 VALUES(9);
SAVEPOINT SV2;
DELETE TAB1 WHERE COL1=7;
INSERT INTO TAB1 VALUES(11);
SAVEPOINT SV3;
INSERT INTO TAB1 VALUES(9);
ROLLBACK TO SV2;
COMMIT;","4","2","1,9,11,9"
"193","다음 주어진 SQL문을 수행한 결과 영구적으로 반영되는 것은 무엇인가?","INSERT INTO TAB1 VALUES(1);
INSERT INTO TAB1 VALUES(2);
SAVEPOINT SV1;
UPDATE TAB1 SET COL1=7 WHERE COL1=2;
INSERT INTO TAB1 VALUES(9);
SAVEPOINT SV2;
DELETE TAB1 WHERE COL1=7;
INSERT INTO TAB1 VALUES(11);
SAVEPOINT SV3;
INSERT INTO TAB1 VALUES(9);
ROLLBACK TO SV2;
COMMIT;","4","3","1,9,11"
"193","다음 주어진 SQL문을 수행한 결과 영구적으로 반영되는 것은 무엇인가?","INSERT INTO TAB1 VALUES(1);
INSERT INTO TAB1 VALUES(2);
SAVEPOINT SV1;
UPDATE TAB1 SET COL1=7 WHERE COL1=2;
INSERT INTO TAB1 VALUES(9);
SAVEPOINT SV2;
DELETE TAB1 WHERE COL1=7;
INSERT INTO TAB1 VALUES(11);
SAVEPOINT SV3;
INSERT INTO TAB1 VALUES(9);
ROLLBACK TO SV2;
COMMIT;","4","4","1,7,9"
"231","다음 중에서 집합 연산자의 종류에 해당되지 않은 것을 고르시오.","","2","1","Except"
"231","다음 중에서 집합 연산자의 종류에 해당되지 않은 것을 고르시오.","","2","2","Project"
"231","다음 중에서 집합 연산자의 종류에 해당되지 않은 것을 고르시오.","","2","3","Union"
"231","다음 중에서 집합 연산자의 종류에 해당되지 않은 것을 고르시오.","","2","4","Union all"
"272","다음에서 설명하는 DDL문으로 올바른 것은?","Mytest 테이블 칼럼을 데이터 타입 조건으로 not null을 기본으로 수정하시오.","2","1","ALTER table Mytest add
constraint column 칼럼명
default not null"
"272","다음에서 설명하는 DDL문으로 올바른 것은?","Mytest 테이블 칼럼을 데이터 타입 조건으로 not null을 기본으로 수정하시오.","2","2","ALTER table Mytest modify (칼럼명 not null)"
"272","다음에서 설명하는 DDL문으로 올바른 것은?","Mytest 테이블 칼럼을 데이터 타입 조건으로 not null을 기본으로 수정하시오.","2","3","ALTER table Mytest add column 칼럼명 default not null"
"272","다음에서 설명하는 DDL문으로 올바른 것은?","Mytest 테이블 칼럼을 데이터 타입 조건으로 not null을 기본으로 수정하시오.","2","4","ALTER table Mytest alter column 칼럼명 not null"
"282","다음 중 SQL문의 실행 순서로 올바른 것은?","","1","1","FROM-WHERE-GROUP BY-HAVING-SELECT-ORDER BY"
"282","다음 중 SQL문의 실행 순서로 올바른 것은?","","1","2","FROM-WHERE-GROUP BY-SELECT-HAVING-ORDER BY"
"282","다음 중 SQL문의 실행 순서로 올바른 것은?","","1","3","FROM-WHERE-HAVING-GROUP BY-ORDER BY-SELECT"
"282","다음 중 SQL문의 실행 순서로 올바른 것은?","","1","4","FROM-WHERE-GROUP BY-HAVING-ORDER BY-SELECT"
"326","다음 중 Oracle과 SQL Server의 트랜잭션 처리 방식에 대한 설명으로 올바르지 않은 것은?","","1","1","Oracle에서 INSERT를 실행하면 자동적으로 COMMIT까지 완료된다."
"326","다음 중 Oracle과 SQL Server의 트랜잭션 처리 방식에 대한 설명으로 올바르지 않은 것은?","","1","2","암시적(묵시적) 트랜잭션 처리는 트랜잭션이 자동으로 시작되며 자동으로 완료 혹은 취소되는 것이다."
"326","다음 중 Oracle과 SQL Server의 트랜잭션 처리 방식에 대한 설명으로 올바르지 않은 것은?","","1","3","명시적 트랜잭션의 시작과 끝은 모두 SQL을 실행하는 사용자가 지정한다."
"326","다음 중 Oracle과 SQL Server의 트랜잭션 처리 방식에 대한 설명으로 올바르지 않은 것은?","","1","4","SQL의 DML과 DDL을 실행할 때 COMMIT을 자동으로 처리하는 것이 AUTO COMMIT이다."
"337","다음 중 해시 조인에 대해서 올바르지 않은 것은?","","2","1","조인 칼럼에 인덱스가 없어도 사용이 가능하다."
"337","다음 중 해시 조인에 대해서 올바르지 않은 것은?","","2","2","Equal Join 과 Non-Equal Join 모두 사용이 가능하다."
"337","다음 중 해시 조인에 대해서 올바르지 않은 것은?","","2","3","해시 조인을 위해서 해시 함수를 사용하기 때문에 CPU를 많이 사용한다."
"337","다음 중 해시 조인에 대해서 올바르지 않은 것은?","","2","4","해시 조인 시에 선행 테이블은 작은 테이블이 먼저와야 한다."
"357","DEPT 테이블에는 총4개의 데이터가 있다. 다음의 SQL문을 실행하면 총 몇 개의 행이 조회되는가?","SELECT * FROM DEPT CROSS JOIN DEPT;","1","1","16"
"357","DEPT 테이블에는 총4개의 데이터가 있다. 다음의 SQL문을 실행하면 총 몇 개의 행이 조회되는가?","SELECT * FROM DEPT CROSS JOIN DEPT;","1","2","12"
"357","DEPT 테이블에는 총4개의 데이터가 있다. 다음의 SQL문을 실행하면 총 몇 개의 행이 조회되는가?","SELECT * FROM DEPT CROSS JOIN DEPT;","1","3","8"
"357","DEPT 테이블에는 총4개의 데이터가 있다. 다음의 SQL문을 실행하면 총 몇 개의 행이 조회되는가?","SELECT * FROM DEPT CROSS JOIN DEPT;","1","4","4"
"390","다음 SQL문을 실행했을 때 오류가 발생하는 것은?","CREATE TABLE T_ORDER(
C1 NUMBER(10),
C2 DATE,
C3 VARCHAR(10),
C4 NUMBER DEFAULT 1000
);","4","1","UPDATE T_ORDER SET C1=1"
"390","다음 SQL문을 실행했을 때 오류가 발생하는 것은?","CREATE TABLE T_ORDER(
C1 NUMBER(10),
C2 DATE,
C3 VARCHAR(10),
C4 NUMBER DEFAULT 1000
);","4","2","DELETE FROM T_ORDER"
"390","다음 SQL문을 실행했을 때 오류가 발생하는 것은?","CREATE TABLE T_ORDER(
C1 NUMBER(10),
C2 DATE,
C3 VARCHAR(10),
C4 NUMBER DEFAULT 1000
);","4","3","DELETE T_ORDER"
"390","다음 SQL문을 실행했을 때 오류가 발생하는 것은?","CREATE TABLE T_ORDER(
C1 NUMBER(10),
C2 DATE,
C3 VARCHAR(10),
C4 NUMBER DEFAULT 1000
);","4","4","INSERT INTO T_ORDER VALUES(2, SYSDATE-1, 'ABC')"
"409","다음 중 UNION구에 대한 설명으로 가장 올바른 것은?","","4","1","정렬을 수행하지 않고 교집합을 생성한다."
"409","다음 중 UNION구에 대한 설명으로 가장 올바른 것은?","","4","2","UNION구는 두 개의 테이블에 포함된 모든 행을 검색한다."
"409","다음 중 UNION구에 대한 설명으로 가장 올바른 것은?","","4","3","두 개의 테이블을 UNION하면 중복행은 제거되지 않으므로 UNION은 SORT를 유발한다."
"409","다음 중 UNION구에 대한 설명으로 가장 올바른 것은?","","4","4","두 개의 테이블을 UNION하면 중복행은 제거되므로 UNION은 SORT를 유발한다."
"418","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","4","1","PL/SQL은 절차형 언어이다."
"418","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","4","2","User Stored Procedure, User Defined Function, Trigger 등의 객체를 PL/SQL로 생성할 수 있다."
"418","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","4","3","변수와 상수 등을 사용해서 일반 SELECT 문장을 실행할 때 WHERE절의 조건을 대입할 수 있다."
"418","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","4","4","PL/SQL문의 기본 구조로 DECLARE, BEGIN ~ END, EXCEPTION은 반드시 사용해야 한다."
"430","다음 중 문자열의 m번째 위치에서 n개의 길이에 해당하는 문자열을 반환하는 함수는?","","1","1","SUBSTR(문자열,M,N)"
"430","다음 중 문자열의 m번째 위치에서 n개의 길이에 해당하는 문자열을 반환하는 함수는?","","1","2","STRING_SPLIT(문자열,M,N)"
"430","다음 중 문자열의 m번째 위치에서 n개의 길이에 해당하는 문자열을 반환하는 함수는?","","1","3","CONCAT(문자열,M,N)"
"430","다음 중 문자열의 m번째 위치에서 n개의 길이에 해당하는 문자열을 반환하는 함수는?","","1","4","TRIM(문자열,M,N)"
"436","다음의 SQL문 실행 결과를 고르시오.","SELECT ROUND(3.47,1)
AS DATA1 FROM DUAL;","3","1","4"
"436","다음의 SQL문 실행 결과를 고르시오.","SELECT ROUND(3.47,1)
AS DATA1 FROM DUAL;","3","2","3"
"436","다음의 SQL문 실행 결과를 고르시오.","SELECT ROUND(3.47,1)
AS DATA1 FROM DUAL;","3","3","3,5"
"436","다음의 SQL문 실행 결과를 고르시오.","SELECT ROUND(3.47,1)
AS DATA1 FROM DUAL;","3","4","3,4"
"437","다음 중 ROWID에 대한 설명으로 올바르지 않은 것은?","","4","1","오브젝트 번호, 상대파일 번호, 블록 번호, 데이터 번호로 구성된다."
"437","다음 중 ROWID에 대한 설명으로 올바르지 않은 것은?","","4","2","ROWID를 사용하면 조회를 원하는 블록을 바로 참조할 수 있다."
"437","다음 중 ROWID에 대한 설명으로 올바르지 않은 것은?","","4","3","ROWID는 ORACLE 데이터베이스 내에서 데이터를 구분할 수 있는 유일한 값이다."
"437","다음 중 ROWID에 대한 설명으로 올바르지 않은 것은?","","4","4","ORACLE 데이터베이스가 내부적으로 관리하는 값이기 때문에, 개발자가 ROWID 값을 확인할 수 없다."
"447","ERD 작성 순서로 올바른 것을 고르시오.","가) 엔터티를 그린다.
나) 엔터티를 적절하게 배치한다.
다) 엔터티 간에 관계를 설정한다.
라) 관계명을 기술한다.
마) 관계의 참여도를 기술한다.
바) 관계의 필수 여부를 기술한다.","4","1","가->나->다->마->바->라"
"447","ERD 작성 순서로 올바른 것을 고르시오.","가) 엔터티를 그린다.
나) 엔터티를 적절하게 배치한다.
다) 엔터티 간에 관계를 설정한다.
라) 관계명을 기술한다.
마) 관계의 참여도를 기술한다.
바) 관계의 필수 여부를 기술한다.","4","2","가->나->라->다->마->바"
"447","ERD 작성 순서로 올바른 것을 고르시오.","가) 엔터티를 그린다.
나) 엔터티를 적절하게 배치한다.
다) 엔터티 간에 관계를 설정한다.
라) 관계명을 기술한다.
마) 관계의 참여도를 기술한다.
바) 관계의 필수 여부를 기술한다.","4","3","나->가->다->라->마->바"
"447","ERD 작성 순서로 올바른 것을 고르시오.","가) 엔터티를 그린다.
나) 엔터티를 적절하게 배치한다.
다) 엔터티 간에 관계를 설정한다.
라) 관계명을 기술한다.
마) 관계의 참여도를 기술한다.
바) 관계의 필수 여부를 기술한다.","4","4","가->나->다->라->마->바"
"457","주어진 SQL문에서 오류가 발생하지 않는 것은?","CREATE TABLE TEST20
(
ID NUMBER PRIMARY KEY,
AGE NUMBER NOT NULL,
NAME VARCHAR2(1)
);

(1) insert into test20 values(10,20,sysdate);
(2)insert into test20 values(20,null,'a');
(3)insert into test20(age, name) values(20,'a');
(4)insert into test20(id,age,name) values(20,10,null);","1","1","4"
"457","주어진 SQL문에서 오류가 발생하지 않는 것은?","CREATE TABLE TEST20
(
ID NUMBER PRIMARY KEY,
AGE NUMBER NOT NULL,
NAME VARCHAR2(1)
);

(1) insert into test20 values(10,20,sysdate);
(2)insert into test20 values(20,null,'a');
(3)insert into test20(age, name) values(20,'a');
(4)insert into test20(id,age,name) values(20,10,null);","1","2","3"
"457","주어진 SQL문에서 오류가 발생하지 않는 것은?","CREATE TABLE TEST20
(
ID NUMBER PRIMARY KEY,
AGE NUMBER NOT NULL,
NAME VARCHAR2(1)
);

(1) insert into test20 values(10,20,sysdate);
(2)insert into test20 values(20,null,'a');
(3)insert into test20(age, name) values(20,'a');
(4)insert into test20(id,age,name) values(20,10,null);","1","3","2"
"457","주어진 SQL문에서 오류가 발생하지 않는 것은?","CREATE TABLE TEST20
(
ID NUMBER PRIMARY KEY,
AGE NUMBER NOT NULL,
NAME VARCHAR2(1)
);

(1) insert into test20 values(10,20,sysdate);
(2)insert into test20 values(20,null,'a');
(3)insert into test20(age, name) values(20,'a');
(4)insert into test20(id,age,name) values(20,10,null);","1","4","1"
"482","성능 데이터 모델링에서 고려해야 할 사항으로 올바르지 않은 것은?","","4","1","데이터베이스 모델링 시에 성능을 고려한 모델링을 수행하면 성능 비용을 감소시킬 수 있다."
"482","성능 데이터 모델링에서 고려해야 할 사항으로 올바르지 않은 것은?","","4","2","성능 향상을 위해서 튜닝을 수행하면 데이터베이스 모델링이 변경될 수 있다."
"482","성능 데이터 모델링에서 고려해야 할 사항으로 올바르지 않은 것은?","","4","3","배치를 통해서 입력되는 데이터 용량이 크면 클수록 성능 튜닝을 위한 비용은 증가된다."
"482","성능 데이터 모델링에서 고려해야 할 사항으로 올바르지 않은 것은?","","4","4","성능 튜닝을 위해서 애플리케이션이 데이터베이스에 접근하는 트랜잭션 유형은 무시해도 된다."
"485","릴레이션을 정규화하는 목적에 관한 설명 중 가장 거리가 먼 것은?","","3","1","정보의 중복을 막는다."
"485","릴레이션을 정규화하는 목적에 관한 설명 중 가장 거리가 먼 것은?","","3","2","정보의 손실을 막는다."
"485","릴레이션을 정규화하는 목적에 관한 설명 중 가장 거리가 먼 것은?","","3","3","정보의 보안을 목적으로 한다."
"485","릴레이션을 정규화하는 목적에 관한 설명 중 가장 거리가 먼 것은?","","3","4","정보의 갱신 이상이 생기지 않도록 한다."
"486","속성에 대한 아래의 설명에서 빈칸에 들어갈 것으로 올바른 것은?","(ㄱ)은 엔터티를 식별할 수 있는 속성이고 (ㄴ)은 다른 엔터티의 관계에 포함되는 속성이다.
다른 엔터티의 관계에 포함되지 않는 속성을 (ㄷ)이라고 한다.","4","1","일반속성 - 기본키 속성 - 외래키 속성"
"486","속성에 대한 아래의 설명에서 빈칸에 들어갈 것으로 올바른 것은?","(ㄱ)은 엔터티를 식별할 수 있는 속성이고 (ㄴ)은 다른 엔터티의 관계에 포함되는 속성이다.
다른 엔터티의 관계에 포함되지 않는 속성을 (ㄷ)이라고 한다.","4","2","파생속성 - 외래키 속성 - 기본키 속성"
"486","속성에 대한 아래의 설명에서 빈칸에 들어갈 것으로 올바른 것은?","(ㄱ)은 엔터티를 식별할 수 있는 속성이고 (ㄴ)은 다른 엔터티의 관계에 포함되는 속성이다.
다른 엔터티의 관계에 포함되지 않는 속성을 (ㄷ)이라고 한다.","4","3","외래키속성 - 기본키 속성 - 파생 속성"
"486","속성에 대한 아래의 설명에서 빈칸에 들어갈 것으로 올바른 것은?","(ㄱ)은 엔터티를 식별할 수 있는 속성이고 (ㄴ)은 다른 엔터티의 관계에 포함되는 속성이다.
다른 엔터티의 관계에 포함되지 않는 속성을 (ㄷ)이라고 한다.","4","4","기본키 속성 - 외래키 속성 - 일반 속성"
"493","다음 중 SQL 명령어가 올바르지 않은 것은?","","1","1","DML : RENAME"
"493","다음 중 SQL 명령어가 올바르지 않은 것은?","","1","2","DCL : REVOKE"
"493","다음 중 SQL 명령어가 올바르지 않은 것은?","","1","3","DDL : ALTER"
"493","다음 중 SQL 명령어가 올바르지 않은 것은?","","1","4","DDL : TRUNCATE"
"499","SELECT NVL(COUNT(*), 9999) FROM TABLE WHERE 1=2의 결괏값은?","","3","1","1"
"499","SELECT NVL(COUNT(*), 9999) FROM TABLE WHERE 1=2의 결괏값은?","","3","2","NULL"
"499","SELECT NVL(COUNT(*), 9999) FROM TABLE WHERE 1=2의 결괏값은?","","3","3","0"
"499","SELECT NVL(COUNT(*), 9999) FROM TABLE WHERE 1=2의 결괏값은?","","3","4","9999"
"503","TEST24 테이블에는 1,2,3의 3개의 행이 있을 때 다음의 SQL 실행 결과로 올바른 것은?","SELECT * FROM test24
minus
SELECT 1 FROM DUAL;","3","1","1"
"503","TEST24 테이블에는 1,2,3의 3개의 행이 있을 때 다음의 SQL 실행 결과로 올바른 것은?","SELECT * FROM test24
minus
SELECT 1 FROM DUAL;","3","2","1,2"
"503","TEST24 테이블에는 1,2,3의 3개의 행이 있을 때 다음의 SQL 실행 결과로 올바른 것은?","SELECT * FROM test24
minus
SELECT 1 FROM DUAL;","3","3","2,3"
"503","TEST24 테이블에는 1,2,3의 3개의 행이 있을 때 다음의 SQL 실행 결과로 올바른 것은?","SELECT * FROM test24
minus
SELECT 1 FROM DUAL;","3","4","1,2,3"
"505","릴레이션 Emp, Dept가 다음과 같이 정의 되어 있다. 부서에 사원이 한명도 없는 부서를 검색하는 질의를 작성할 때, 가장 올바르지 않은 것은? (단, Emp 테이블의 deptno는 Dept의 deptno를 참조하는 외래키이며, Emp의 deptno에는 NULL인 값이 없음)","Emp(empno, ename, job, mgr, hiredate, sal, comm, deptno)
Dept(deptno, dname, loc)","1","1","SELECT deptno FROM Dept WHERE deptno <> ANY (SELECT deptno FROM Emp);"
"505","릴레이션 Emp, Dept가 다음과 같이 정의 되어 있다. 부서에 사원이 한명도 없는 부서를 검색하는 질의를 작성할 때, 가장 올바르지 않은 것은? (단, Emp 테이블의 deptno는 Dept의 deptno를 참조하는 외래키이며, Emp의 deptno에는 NULL인 값이 없음)","Emp(empno, ename, job, mgr, hiredate, sal, comm, deptno)
Dept(deptno, dname, loc)","1","2","SELECT b.deptno FROM Emp a RIGHT OUTER JOIN Dept b ON a.deptno = b.deptno WHERE empno IS NULL;"
"505","릴레이션 Emp, Dept가 다음과 같이 정의 되어 있다. 부서에 사원이 한명도 없는 부서를 검색하는 질의를 작성할 때, 가장 올바르지 않은 것은? (단, Emp 테이블의 deptno는 Dept의 deptno를 참조하는 외래키이며, Emp의 deptno에는 NULL인 값이 없음)","Emp(empno, ename, job, mgr, hiredate, sal, comm, deptno)
Dept(deptno, dname, loc)","1","3","SELECT deptno FROM Dept a WHERE NOT EXISTS (SELECT * FROM Emp b WHERE a.deptno = b.deptno);"
"505","릴레이션 Emp, Dept가 다음과 같이 정의 되어 있다. 부서에 사원이 한명도 없는 부서를 검색하는 질의를 작성할 때, 가장 올바르지 않은 것은? (단, Emp 테이블의 deptno는 Dept의 deptno를 참조하는 외래키이며, Emp의 deptno에는 NULL인 값이 없음)","Emp(empno, ename, job, mgr, hiredate, sal, comm, deptno)
Dept(deptno, dname, loc)","1","4","SELECT deptno FROM Dept WHERE Deptno NOT IN (SELECT deptno FROM Emp);"
"506","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","4","1","계층형 질의는 하나의 테이블에서 자기 자신을 조인하는 형태를 사용한다."
"506","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","4","2","재무제표 및 조직도와 같은 구조에서 사용할 수 있다."
"506","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","4","3","순방향과 역방향 모두 수행할 수 있다."
"506","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","4","4","루트 노드의 LEVEL 값은 가장 큰 값을 가진다."
"565","다음 중 뷰의 특징 중 틀린 것을 고르시오.","","1","1","뷰는 물리적으로 구현되어 있다."
"565","다음 중 뷰의 특징 중 틀린 것을 고르시오.","","1","2","데이터의 논리적 독립성을 제공할 수 있다."
"565","다음 중 뷰의 특징 중 틀린 것을 고르시오.","","1","3","일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다."
"565","다음 중 뷰의 특징 중 틀린 것을 고르시오.","","1","4","뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다."
"567","개념 스키마에 대한 설명으로 틀린 것을 고르시오.","","2","1","설계자 관점의 스키마다."
"567","개념 스키마에 대한 설명으로 틀린 것을 고르시오.","","2","2","데이터베이스의 물리적 저장 구조를 표현한다."
"567","개념 스키마에 대한 설명으로 틀린 것을 고르시오.","","2","3","전체 데이터베이스 내의 규칙과 구조를 표현한다."
"567","개념 스키마에 대한 설명으로 틀린 것을 고르시오.","","2","4","사용자 전체 집단의 데이터베이스 구조이다."
"570","3층 스키마의 물리적 저장 구조를 의미하는 것은?","","3","1","외부스키마"
"570","3층 스키마의 물리적 저장 구조를 의미하는 것은?","","3","2","구조스키마"
"570","3층 스키마의 물리적 저장 구조를 의미하는 것은?","","3","3","내부스키마"
"570","3층 스키마의 물리적 저장 구조를 의미하는 것은?","","3","4","개념스키마"
"573","속성의 분류 중 속성의 특성에 따른 분류가 아닌 것은? ","","2","1","설계속성"
"573","속성의 분류 중 속성의 특성에 따른 분류가 아닌 것은? ","","2","2","일반속성"
"573","속성의 분류 중 속성의 특성에 따른 분류가 아닌 것은? ","","2","3","파생속성"
"573","속성의 분류 중 속성의 특성에 따른 분류가 아닌 것은? ","","2","4","기본속성"
"583","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가정 적절한 것은?","","3","1","SELECT DEPTNO, ROUND(AVG(SAL)) AS ROUND_VALUE"
"583","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가정 적절한 것은?","","3","2","FROM EMP E"
"583","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가정 적절한 것은?","","3","3","WHERE ROUND_VALUE >= 3000"
"583","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가정 적절한 것은?","","3","4","GROUP BY DEPTNO;"
"584","다음의 함수 실행 결과 중 틀린 것은?","","3","1","LTRIM('AABABAA', 'A') : 'BABAA'"
"584","다음의 함수 실행 결과 중 틀린 것은?","","3","2","INSTR('WWW.ABCDEFGH.CO.KR','.', 5, 2) : 16 "
"584","다음의 함수 실행 결과 중 틀린 것은?","","3","3","LPAD('X',5,'X') : 'XXXXXX' 
"
"584","다음의 함수 실행 결과 중 틀린 것은?","","3","4","SUBSTR('WWW.ABCDEFGH.CO.KR', -5) : 'CO.KR' "
"596","다음 중 실행이 불가한 구문은?","","1","1","SELECT COL1, COL2, COL3 C1 FROM TAB1 T ORDER BY COL1, COL1, T.C1;"
"596","다음 중 실행이 불가한 구문은?","","1","2","SELECT COL1, COL2, COL3 C1 FROM TAB1 T ORDER BY 1, COL2, C1;"
"596","다음 중 실행이 불가한 구문은?","","1","3","SELECT COL1, COL2, COL3 C1 FROM TAB1 T ORDER BY 1, 2, 3;"
"596","다음 중 실행이 불가한 구문은?","","1","4","SELECT COL1, COL2, COL3 C1 FROM TAB1 T ORDER BY 1, COL2, COL3;"
"607","아래 쿼리중 결과값이 다른 하나는? ","","2","1","SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B 
   WHERE A.DEPTNO = B.DEPTNO 
   GROUP BY DNAME, JOB 
   UNION ALL 
  SELECT DNAME, '' AS JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B 
   WHERE A.DEPTNO = B.DEPTNO 
   GROUP BY DNAME 
   UNION ALL 
  SELECT '' AS DNAME, '' AS JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B 
   WHERE A.DEPTNO = B.DEPTNO 
   ORDER BY 1, 2;"
"607","아래 쿼리중 결과값이 다른 하나는? ","","2","2"," SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B 
   WHERE A.DEPTNO = B.DEPTNO 
   GROUP BY CUBE(DNAME, JOB) 
   ORDER BY 1, 2;"
"607","아래 쿼리중 결과값이 다른 하나는? ","","2","3","SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B  
   WHERE A.DEPTNO = B.DEPTNO 
   GROUP BY GROUPING SETS((DNAME,JOB), DNAME, NULL) 
   ORDER BY 1, 2;"
"607","아래 쿼리중 결과값이 다른 하나는? ","","2","4","SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B    
   WHERE A.DEPTNO = B.DEPTNO  
   GROUP BY ROLLUP(DNAME,JOB) 
   ORDER BY DNAME, JOB;"
"621","데이터 모델링을 할 때 유의해야 할 사항으로 가장 적절하지 않은 것은?","","1","1","사용자가 처리하는 프로세스에 따라 매핑이 될 수 있도록 프로그램과 테이블 간의 연계성을 높인다."
"621","데이터 모델링을 할 때 유의해야 할 사항으로 가장 적절하지 않은 것은?","","1","2","데이터의 정의를 프로세스와 분리하여 유연성을 높인다."
"621","데이터 모델링을 할 때 유의해야 할 사항으로 가장 적절하지 않은 것은?","","1","3","데이터 간의 상호 연관관계를 명확하게 정의하여 일관성 있게 데이터가 유지되도록 한다. "
"621","데이터 모델링을 할 때 유의해야 할 사항으로 가장 적절하지 않은 것은?","","1","4","같은 정보를 저장하지 않도록 하여 중복성을 최소화한다."
"632","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","1","1","SELECT문의 6개 절 중에서 SELECT절이 가장 마지막에 실행된다."
"632","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","1","2","HAVING절에서는 그룹함수가 없는 일반 조건을 사용할 수 있다."
"632","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","1","3","WHERE절에는 그룹함수를 사용한 조건 전달이 불가하다."
"632","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","1","4","GROUP BY절에는 컬럼별칭을 사용할 수 없다."
"633","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가장 적절한 것은?","","4","1","SELECT T.COL1, COL2, SUM(COL3) AS ""SUM VALUE"""
"633","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가장 적절한 것은?","","4","2","FROM TAB1 T"
"633","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가장 적절한 것은?","","4","3","GROUP BY COL1, COL2"
"633","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가장 적절한 것은?","","4","4","ORDER BY COL3;"
"671","다음 중 아래에서 설명하는 데이터모델의 개념으로 가장 적절한 것은? ","학생이라는 엔터티에서 학년이라는 속성 값의 범위는 1~4 사이의 정수이며, 주민번호 속성은 13자리 이내 문자열로 정의할 수 있다. ","4","1","속성사전"
"671","다음 중 아래에서 설명하는 데이터모델의 개념으로 가장 적절한 것은? ","학생이라는 엔터티에서 학년이라는 속성 값의 범위는 1~4 사이의 정수이며, 주민번호 속성은 13자리 이내 문자열로 정의할 수 있다. ","4","2","시스템카탈로그"
"671","다음 중 아래에서 설명하는 데이터모델의 개념으로 가장 적절한 것은? ","학생이라는 엔터티에서 학년이라는 속성 값의 범위는 1~4 사이의 정수이며, 주민번호 속성은 13자리 이내 문자열로 정의할 수 있다. ","4","3","릴레이션"
"671","다음 중 아래에서 설명하는 데이터모델의 개념으로 가장 적절한 것은? ","학생이라는 엔터티에서 학년이라는 속성 값의 범위는 1~4 사이의 정수이며, 주민번호 속성은 13자리 이내 문자열로 정의할 수 있다. ","4","4","도메인"
"674","엔터티간 1:1, 1:M 과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가? ","","3","1","관계정의"
"674","엔터티간 1:1, 1:M 과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가? ","","3","2","관계선택성"
"674","엔터티간 1:1, 1:M 과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가? ","","3","3","관계차수"
"674","엔터티간 1:1, 1:M 과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가? ","","3","4","관계명"
"682","테이블 생성 시 주의 할 사항으로 적절하지 않은 것은? ","","3","1","소유자가 다를 경우 같은 이름의 테이블을 생성할 수 있다."
"682","테이블 생성 시 주의 할 사항으로 적절하지 않은 것은? ","","3","2","테이블 생성시 대소문자 구분은 하지 않는다."
"682","테이블 생성 시 주의 할 사항으로 적절하지 않은 것은? ","","3","3","테이블명과 컬럼명은 숫자로 시작해도 무관하다."
"682","테이블 생성 시 주의 할 사항으로 적절하지 않은 것은? ","","3","4","컬럼 뒤에 데이터 유형은 꼭 지정되어야 한다."
"715","컬럼 변경 시 주의 사항으로 옳지 않은 것은? ","","4","1","컬럼의 DEFAULT 값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미친다."
"715","컬럼 변경 시 주의 사항으로 옳지 않은 것은? ","","4","2","컬럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다."
"715","컬럼 변경 시 주의 사항으로 옳지 않은 것은? ","","4","3","컬럼이 NULL 값만 가지고 있으면 데이터 유형을 변경할 수 있다."
"715","컬럼 변경 시 주의 사항으로 옳지 않은 것은? ","","4","4","컬럼의 크기를 늘릴 수는 있지만 줄일 수는 없다."
"719","다음 설명 중 가장 적절하지 않은 것은?","","1","1","NULL값이 삽입되어 있는 경우 UNIQUE 제약조건을 추가할 수 없다."
"719","다음 설명 중 가장 적절하지 않은 것은?","","1","2","이미 존재하는 컬럼에 대해 NOT NULL 제약조건 추가 시 반드시 MODIFY로 처리한다."
"719","다음 설명 중 가장 적절하지 않은 것은?","","1","3","제약 조건 추가 시 제약조건 이름을 명시하지 않을 수 있다."
"719","다음 설명 중 가장 적절하지 않은 것은?","","1","4","외래키를 생성 한 경우 부모 테이블의 참조키 컬럼을 삭제할 수 없다."
"720","권한에 대한 설명으로 가장 적절한 것은?","","2","1","WITH ADMIN OPTION을 통해 부여받은 테이블 조회 권한을 다른 유저에게 부여할 수 있다."
"720","권한에 대한 설명으로 가장 적절한 것은?","","2","2","롤에 있는 권한을 회수한 이후 롤을 부여받은 유저는 해당 권한을 갖지 않게 된다."
"720","권한에 대한 설명으로 가장 적절한 것은?","","2","3","테이블에 대한 조회 권한 부여 시 즉시 반영되지 않고 재접속을 해야 조회가 가능하다."
"720","권한에 대한 설명으로 가장 적절한 것은?","","2","4","권한은 테이블 소유자만이 부여할 수 있다."
"728","트랜잭션의 특징 중 옳지 않은 것은?","","1","1","중복성"
"728","트랜잭션의 특징 중 옳지 않은 것은?","","1","2","지속성"
"728","트랜잭션의 특징 중 옳지 않은 것은?","","1","3","원자성"
"728","트랜잭션의 특징 중 옳지 않은 것은?","","1","4","일관성"
"730","다음의 주식별자가 나타내는 특징을 가장 잘 설명한 것은?","주식별자를 구성하는 속성 중에서 유일성을 만족하는 최소한의 속성으로 구성한다.","3","1","존재성"
"730","다음의 주식별자가 나타내는 특징을 가장 잘 설명한 것은?","주식별자를 구성하는 속성 중에서 유일성을 만족하는 최소한의 속성으로 구성한다.","3","2","단일성"
"730","다음의 주식별자가 나타내는 특징을 가장 잘 설명한 것은?","주식별자를 구성하는 속성 중에서 유일성을 만족하는 최소한의 속성으로 구성한다.","3","3","최소성"
"730","다음의 주식별자가 나타내는 특징을 가장 잘 설명한 것은?","주식별자를 구성하는 속성 중에서 유일성을 만족하는 최소한의 속성으로 구성한다.","3","4","유일성"
"732","관계형 데이터베이스에 대한 특징 중 가장 적절하지 않은 것은?","","1","1","데이터베이스의 부하를 분석하기 쉽다."
"732","관계형 데이터베이스에 대한 특징 중 가장 적절하지 않은 것은?","","1","2","기존의 작성된 스키마를 수정하기 어렵다."
"732","관계형 데이터베이스에 대한 특징 중 가장 적절하지 않은 것은?","","1","3","데이터를 분류, 정렬, 탐색하는 속도가 빠르다."
"732","관계형 데이터베이스에 대한 특징 중 가장 적절하지 않은 것은?","","1","4","데이터의 무결성을 보장할 수 있다."
"734","다음 중 오류가 발생하는 문장으로 가장 적절한 것은?","","1","1","SELECT T.COL2, SUM(T.COL1), SUM(T.COL3) FROM TAB1 T GROUP BY T.COL2 ORDER BY T.COL3;"
"734","다음 중 오류가 발생하는 문장으로 가장 적절한 것은?","","1","2","SELECT T.COL2, SUM(T.COL1) AS SUM_VALUE FROM TAB1 T GROUP BY T.COL2 ORDER BY SUM_VALUE, T.COL2;"
"734","다음 중 오류가 발생하는 문장으로 가장 적절한 것은?","","1","3","SELECT T.COL2, SUM(T.COL1) FROM TAB1 T WHERE COL1 >= 100 GROUP BY COL2;"
"734","다음 중 오류가 발생하는 문장으로 가장 적절한 것은?","","1","4","SELECT COL1, T.COL2, T.COL3 FROM TAB1 T WHERE COL1 >= 100;"
"749","아래 SQL 중 결과가 다른 하나는?","","1","1","SELECT CODE, NAME, (SELECT PRICE FROM PRODUCT WHERE P1.CODE = P2.CODE) FROM PRODUCT P1;"
"749","아래 SQL 중 결과가 다른 하나는?","","1","2","SELECT CODE, NAME, PRICE FROM PRODUCT P1 WHERE PRICE = (SELECT MAX(PRICE) FROM PRODUCT P2 WHERE P1.CODE = P2.CODE);"
"749","아래 SQL 중 결과가 다른 하나는?","","1","3","SELECT CODE, NAME, PRICE FROM PRODUCT WHERE (CODE, PRICE) IN (SELECT CODE, MAX(PRICE) FROM PRODUCT GROUP BY CODE);"
"749","아래 SQL 중 결과가 다른 하나는?","","1","4","SELECT P.CODE, P.NAME, P.PRICE FROM PRODUCT P, (SELECT CODE, MAX(PRICE) AS MAX_PRICE FROM PRODUCT GROUP BY CODE) I WHERE P.CODE = I.CODE AND P.PRICE = I.MAX_PRICE;"
"762","PIVOT과 UNPIVOT에 대한 설명으로 가장 적절한 것은?","","1","1","PIVOT 시 FOR 앞에는 반드시 집계함수(SUM, AVG 등)의 형태여야 한다."
"762","PIVOT과 UNPIVOT에 대한 설명으로 가장 적절한 것은?","","1","2","UNPIVOT시 쌓을 컬럼을 지정할 수 없다."
"762","PIVOT과 UNPIVOT에 대한 설명으로 가장 적절한 것은?","","1","3","UNPIVOT은 LONG 데이터를 WIDE 데이터로 변환하는 기법이다."
"762","PIVOT과 UNPIVOT에 대한 설명으로 가장 적절한 것은?","","1","4","PIVOT은 교차표 형태의 데이터를 TIDY 데이터로 변경하는 문법이다."
"769","외래키에 대한 설명으로 가장 적절하지 않은 것은?","","2","1","자식 테이블은 UPDATE, INSERT 시 제약을 받는다."
"769","외래키에 대한 설명으로 가장 적절하지 않은 것은?","","2","2","ON DELETE CASCADE 옵션으로 외래키 생성 시 부모 데이터만 삭제되고 자식데이터는 그대로 남는다."
"769","외래키에 대한 설명으로 가장 적절하지 않은 것은?","","2","3","외래키 생성 후 부모 테이블은 자식 데이터가 있을 경우 삭제 불가하다."
"769","외래키에 대한 설명으로 가장 적절하지 않은 것은?","","2","4","외래키 생성 시 참조 테이블의 참조키에 반드시 기본키 또는 고유키가 생성되어 있어야 한다."
"770","뷰에 대한 설명 중 가장 적절하지 않은 것은?","","2","1","기본 테이블이 삭제되면 그 테이블을 참조하여 만든 뷰 역시 삭제된다."
"770","뷰에 대한 설명 중 가장 적절하지 않은 것은?","","2","2","뷰를 참조하는 또 다른 뷰는 생성 불가하다."
"770","뷰에 대한 설명 중 가장 적절하지 않은 것은?","","2","3","원본 테이블이 노출되지 않으므로 데이터를 안전하게 보호할 수 있다."
"770","뷰에 대한 설명 중 가장 적절하지 않은 것은?","","2","4","뷰는 가상의 테이블이기에 물리적으로 구현되어 있지 않으며 저장공간을 차지하지 않는다."
"796","다음 ANSI 문법을 오라클 문법으로 바꾼 것으로 가장 적절한 것은? ","SELECT * 
  FROM TAB1 JOIN TAB2 
     ON TAB1.COL1 = TAB2.COL1 
        LEFT OUTER JOIN TAB3 
     ON TAB1.COL2 = TAB3.COL2; ","2","1","SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1(+) AND TAB1.COL2 = TAB3.COL2(+);"
"796","다음 ANSI 문법을 오라클 문법으로 바꾼 것으로 가장 적절한 것은? ","SELECT * 
  FROM TAB1 JOIN TAB2 
     ON TAB1.COL1 = TAB2.COL1 
        LEFT OUTER JOIN TAB3 
     ON TAB1.COL2 = TAB3.COL2; ","2","2","SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1 AND TAB1.COL2 = TAB3.COL2(+);"
"796","다음 ANSI 문법을 오라클 문법으로 바꾼 것으로 가장 적절한 것은? ","SELECT * 
  FROM TAB1 JOIN TAB2 
     ON TAB1.COL1 = TAB2.COL1 
        LEFT OUTER JOIN TAB3 
     ON TAB1.COL2 = TAB3.COL2; ","2","3","SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1(+) AND TAB1.COL2 = TAB3.COL2;"
"796","다음 ANSI 문법을 오라클 문법으로 바꾼 것으로 가장 적절한 것은? ","SELECT * 
  FROM TAB1 JOIN TAB2 
     ON TAB1.COL1 = TAB2.COL1 
        LEFT OUTER JOIN TAB3 
     ON TAB1.COL2 = TAB3.COL2; ","2","4","SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1 AND TAB1.COL2 = TAB3.COL2;"
"243","테이블 3개를 조인하려면 최소 몇 개의 조건절이 필요한가?","","3","1","4"
"243","테이블 3개를 조인하려면 최소 몇 개의 조건절이 필요한가?","","3","2","3"
"243","테이블 3개를 조인하려면 최소 몇 개의 조건절이 필요한가?","","3","3","2"
"243","테이블 3개를 조인하려면 최소 몇 개의 조건절이 필요한가?","","3","4","1"
"260","다음의 SQL문은 파티션별 윈도우의 전체건수에서 현재 행보다 작거나 같은 건수에 대해서 누적백분율을 구하는 SQL문이다. (ㄱ)에 올바른 윈도우 함수는?","SELECT DEPTNO, ENAME, SAL, ( ㄱ ) OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) as PCT
FROM EMP;","1","1","CUME_DIST()"
"260","다음의 SQL문은 파티션별 윈도우의 전체건수에서 현재 행보다 작거나 같은 건수에 대해서 누적백분율을 구하는 SQL문이다. (ㄱ)에 올바른 윈도우 함수는?","SELECT DEPTNO, ENAME, SAL, ( ㄱ ) OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) as PCT
FROM EMP;","1","2","LAG()"
"260","다음의 SQL문은 파티션별 윈도우의 전체건수에서 현재 행보다 작거나 같은 건수에 대해서 누적백분율을 구하는 SQL문이다. (ㄱ)에 올바른 윈도우 함수는?","SELECT DEPTNO, ENAME, SAL, ( ㄱ ) OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) as PCT
FROM EMP;","1","3","LEAD()"
"260","다음의 SQL문은 파티션별 윈도우의 전체건수에서 현재 행보다 작거나 같은 건수에 대해서 누적백분율을 구하는 SQL문이다. (ㄱ)에 올바른 윈도우 함수는?","SELECT DEPTNO, ENAME, SAL, ( ㄱ ) OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) as PCT
FROM EMP;","1","4","NTILE()"
"261","윈도우 함수 중에서 윈도우에서 제일 먼저 나오는 것을 0으로 하고 제일 늦게 나오는 것을 1로 해서 행 순서별 백분율을 구하는 것은?","","2","1","CUME_DIST"
"261","윈도우 함수 중에서 윈도우에서 제일 먼저 나오는 것을 0으로 하고 제일 늦게 나오는 것을 1로 해서 행 순서별 백분율을 구하는 것은?","","2","2","PERCENT_RANK"
"261","윈도우 함수 중에서 윈도우에서 제일 먼저 나오는 것을 0으로 하고 제일 늦게 나오는 것을 1로 해서 행 순서별 백분율을 구하는 것은?","","2","3","LAST_VALUE"
"261","윈도우 함수 중에서 윈도우에서 제일 먼저 나오는 것을 0으로 하고 제일 늦게 나오는 것을 1로 해서 행 순서별 백분율을 구하는 것은?","","2","4","FIRST_VALUE"
"264","다음 설명 중 올바르지 않은 것은?","","4","1","Oracle에서 인덱스 구성 칼럼이 모두 null인 레코드는 인덱스에 저장하지 않는다."
"264","다음 설명 중 올바르지 않은 것은?","","4","2","SQL Server는 인덱스 구성 칼럼이 모두 null인 레코드도 인덱스에 저장한다."
"264","다음 설명 중 올바르지 않은 것은?","","4","3","Oracle에서 인덱스 구성 칼럼 중 하나라도 null이 아닌 레코드는 인덱스에 저장한다."
"264","다음 설명 중 올바르지 않은 것은?","","4","4","SQL Server는 null 값을 인덱스 맨 뒤에 저장한다."
"284","사용자 A가 어떤 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 B에게 허가하고, 사용자 B가 그 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 C에게 허가하고, 사용자 C가 그 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 D에게 허가했을 때, 사용자 A가 사용자 B로부터 SELECT 권한을 취소하면 사용자 C와 D의 권한은 어떻게 되는가?","","1","1","C와 D의 권한이 취소된다."
"284","사용자 A가 어떤 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 B에게 허가하고, 사용자 B가 그 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 C에게 허가하고, 사용자 C가 그 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 D에게 허가했을 때, 사용자 A가 사용자 B로부터 SELECT 권한을 취소하면 사용자 C와 D의 권한은 어떻게 되는가?","","1","2","C와 D의 권한이 유지된다."
"284","사용자 A가 어떤 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 B에게 허가하고, 사용자 B가 그 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 C에게 허가하고, 사용자 C가 그 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 D에게 허가했을 때, 사용자 A가 사용자 B로부터 SELECT 권한을 취소하면 사용자 C와 D의 권한은 어떻게 되는가?","","1","3","C의 권한은 취소되고, D의 권한은 유지된다."
"284","사용자 A가 어떤 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 B에게 허가하고, 사용자 B가 그 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 C에게 허가하고, 사용자 C가 그 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 D에게 허가했을 때, 사용자 A가 사용자 B로부터 SELECT 권한을 취소하면 사용자 C와 D의 권한은 어떻게 되는가?","","1","4","C의 권한은 유지되고, D의 권한은 취소된다."
"813","제1정규형(1NF)의 조건은?","","2","1","이행적 종속 제거"
"813","제1정규형(1NF)의 조건은?","","2","2","반복 속성 제거"
"813","제1정규형(1NF)의 조건은?","","2","3","후보키 결정"
"813","제1정규형(1NF)의 조건은?","","2","4","조인 수행"
"818","관계형 데이터베이스의 구성 요소가 아닌 것은?","","3","1","테이블"
"818","관계형 데이터베이스의 구성 요소가 아닌 것은?","","3","2","트랜잭션"
"818","관계형 데이터베이스의 구성 요소가 아닌 것은?","","3","3","애플리케이션"
"818","관계형 데이터베이스의 구성 요소가 아닌 것은?","","3","4","뷰(View)"
"819","SQL의 주요 기능이 아닌 것은?","","4","1","데이터 정의(DDL)"
"819","SQL의 주요 기능이 아닌 것은?","","4","2","데이터 조작(DML)"
"819","SQL의 주요 기능이 아닌 것은?","","4","3","데이터 제어(DCL)"
"819","SQL의 주요 기능이 아닌 것은?","","4","4","사용자 인터페이스 디자인"
"16","다음 중 데이터를 조회할 때 빠른 성능을 낼 수있도록 하기 위해 원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성으로 가장 적절한 것은?","","4","1","PK속성 (Derived Attribute)"
"16","다음 중 데이터를 조회할 때 빠른 성능을 낼 수있도록 하기 위해 원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성으로 가장 적절한 것은?","","4","2","설계속성(Designed Attribute)"
"16","다음 중 데이터를 조회할 때 빠른 성능을 낼 수있도록 하기 위해 원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성으로 가장 적절한 것은?","","4","3","기본속성 (Basic Attribute)"
"16","다음 중 데이터를 조회할 때 빠른 성능을 낼 수있도록 하기 위해 원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성으로 가장 적절한 것은?","","4","4","파생속성 (Derived Attribute)"
"20","다음 중 관계에 대한 설명으로 가장 부적절한 것은?","","3","1","주문과 배송 엔터티 간의 '배송근거' 관계는 행위에 의한 관계의 사례이다."
"20","다음 중 관계에 대한 설명으로 가장 부적절한 것은?","","3","2","부서와 사원 엔터티 간의 '소속' 관계는 존재적 관계의 사례이다."
"20","다음 중 관계에 대한 설명으로 가장 부적절한 것은?","","3","3","관계의 표기법은 관계명, 관계차수. 식별성의 3가지 개념을 사용한다."
"20","다음 중 관계에 대한 설명으로 가장 부적절한 것은?","","3","4","관계는 존재적 관계와 행위에 의한 관계로 나누어볼 수 있다."
"30","다음 중 성능 데이터모델링에 대한 설명으로 가장 부적절한 것은?","","4","1","분석/설계 단계에서 성능을 고려한 데이터모델링을 수행할 경우 성능 저하에 따른 Rework비용을 최소화 할 수 있는 기회를 가지게 된다."
"30","다음 중 성능 데이터모델링에 대한 설명으로 가장 부적절한 것은?","","4","2","데이터모델은 성능을 튜닝하면서 변경이 될 수 있는 특징이 있다."
"30","다음 중 성능 데이터모델링에 대한 설명으로 가장 부적절한 것은?","","4","3","데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용은 증가한다."
"30","다음 중 성능 데이터모델링에 대한 설명으로 가장 부적절한 것은?","","4","4","성능이 저하된 결과를 대상으로 데이터모델 보다는 문제발생 시점의 SQL을 중심으로 집중하여 튜닝을 한다."
"86","다음 중 5개의 테이블로부터 필요한 칼럼을 조회하려고 할 때, 최소 몇 개의 JOIN 조건이 필요한가?","","2","1","5개"
"86","다음 중 5개의 테이블로부터 필요한 칼럼을 조회하려고 할 때, 최소 몇 개의 JOIN 조건이 필요한가?","","2","2","4개"
"86","다음 중 5개의 테이블로부터 필요한 칼럼을 조회하려고 할 때, 최소 몇 개의 JOIN 조건이 필요한가?","","2","3","3개"
"86","다음 중 5개의 테이블로부터 필요한 칼럼을 조회하려고 할 때, 최소 몇 개의 JOIN 조건이 필요한가?","","2","4","2개"
"94","다음 중 팀(TEAM) 테이블과 구장(STADIUM) 테이블의 관계를 아용해서 소속팀이 가지고 있는 전용구장의 정보를 팀의 정보와 함께 출력하는 SQL을 작성할 때 결과가 다른 것은?","","4","1","SELECT TEAM.REGION_NAME, TEAM.TEAM_NAME, 
TEAM.STADIUM_ID, STADIUM.STADIUM_NAME 
FROM TEAM, STADIUM 
WHERE TEAM.STADIUM_ID = STADIUM.STADIUM_ID;"
"94","다음 중 팀(TEAM) 테이블과 구장(STADIUM) 테이블의 관계를 아용해서 소속팀이 가지고 있는 전용구장의 정보를 팀의 정보와 함께 출력하는 SQL을 작성할 때 결과가 다른 것은?","","4","2","SELECT T.REGION_NAME, T.TEAM_NAME, T.STADIUM_ID, 
S.STADIUM_NAME
 FROM TEAM T, STADIUM S
 WHERE T.STADIUM_ID = S.STADIUM_ID;"
"94","다음 중 팀(TEAM) 테이블과 구장(STADIUM) 테이블의 관계를 아용해서 소속팀이 가지고 있는 전용구장의 정보를 팀의 정보와 함께 출력하는 SQL을 작성할 때 결과가 다른 것은?","","4","3","SELECT TEAM.REGION_NAME, TEAM.TEAM_NAME, 
TEAM.STADIUM_ID, STADIUM.STADIUM_NAME 
FROM TEAM INNER JOIN STADIUM
 ON (TEAM.STADIUM_ID =
 STADIUM.STADIUM_ID) ;"
"94","다음 중 팀(TEAM) 테이블과 구장(STADIUM) 테이블의 관계를 아용해서 소속팀이 가지고 있는 전용구장의 정보를 팀의 정보와 함께 출력하는 SQL을 작성할 때 결과가 다른 것은?","","4","4","SELECT T.REGION_NAME, T.TEAM_NAME, T.STADIUM_ID, 
S.STADIUM_NAME
 FROM TEAM T INNER JOIN STADIUM S
 USING (T.STADIUM_ID = S.STADIUM_ID);"
"122","다음 중 뷰(View)에 대한 설명으로 가장 부적절한 것은?","","3","1","실제 데이터를 저장하고 있는 뷰를 생성하는 기능을 지원하는 DBMS도 있다."
"122","다음 중 뷰(View)에 대한 설명으로 가장 부적절한 것은?","","3","2","뷰는 보안을 강화하기 위한 목적으로도 활용할 수 있다."
"122","다음 중 뷰(View)에 대한 설명으로 가장 부적절한 것은?","","3","3","뷰는 복잡한 SQL 문장을 단순화 시켜주는 장점이 있는 반면, 테이블 구조가 변경되면 응용 프로그램을 변경해 주어야 한다."
"122","다음 중 뷰(View)에 대한 설명으로 가장 부적절한 것은?","","3","4","뷰는 단지 정의만을 가지고 있으며, 실행 시점에 질의를 재작성하여 수행한다."
"152","데이터 모델링에 대한 설명 중 알맞은 것은?","","1","1","논리 모델링이 외래키는 물리 모델에서 반드시 구현되지는 않는다."
"152","데이터 모델링에 대한 설명 중 알맞은 것은?","","1","2","물리 모델링 -> 논리 모델링 -> 개념 모델링 단계로 갈수록 구체적이다."
"152","데이터 모델링에 대한 설명 중 알맞은 것은?","","1","3","실제로 데이터베이스를 구축할 때 참고되는 모델은 개념적 데이터 모델링이다."
"152","데이터 모델링에 대한 설명 중 알맞은 것은?","","1","4","데이터 모델링의 3가지 요소는 Process, Attributes, Relationships이다."
"157","Hash Join 기법에 대한 설명으로 옳은 것은?","","4","1","Hash Join은 조인 칼럼의 인덱스가 존재하지 않으면 사용할 수 없는 기법이다."
"157","Hash Join 기법에 대한 설명으로 옳은 것은?","","4","2","해시 테이블을 저장할 때 메모리에 적재 할 수 있는 영역의 크기보다 커지면 초과한 크기를 제외한 영역만큼 메모리에 적재한다."
"157","Hash Join 기법에 대한 설명으로 옳은 것은?","","4","3","Hash Join은 해시 함수를 이용하여 조인을 수행하기 때문에 '='로 수행하는 조인인 동등조건 이외에도 사용할 수 있다."
"157","Hash Join 기법에 대한 설명으로 옳은 것은?","","4","4","조인 작업을 수행할 때는 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋다."
"180","다음과 같은 SQL 문장이 있다. 예제의 ORDER BY 절과 같은 결과를 갖는 구문은 어떤 것인가?","SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버 
FROM PLAYER
ORDER BY PLAYER_NAME, POSITION, BACK_NO DESC;","4","1","ORDER BY 1 DESC, 2, 백넘버"
"180","다음과 같은 SQL 문장이 있다. 예제의 ORDER BY 절과 같은 결과를 갖는 구문은 어떤 것인가?","SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버 
FROM PLAYER
ORDER BY PLAYER_NAME, POSITION, BACK_NO DESC;","4","2","ORDER BY PLAYER_NAME ASC, 2, 3"
"180","다음과 같은 SQL 문장이 있다. 예제의 ORDER BY 절과 같은 결과를 갖는 구문은 어떤 것인가?","SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버 
FROM PLAYER
ORDER BY PLAYER_NAME, POSITION, BACK_NO DESC;","4","3","ORDER BY 선수명, 2, DESC 백넘버"
"180","다음과 같은 SQL 문장이 있다. 예제의 ORDER BY 절과 같은 결과를 갖는 구문은 어떤 것인가?","SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버 
FROM PLAYER
ORDER BY PLAYER_NAME, POSITION, BACK_NO DESC;","4","4","ORDER BY 선수명 ASC, 포지션, 3 DESC"
"183","4개의 테이블로부터 필요한 칼럼을 조회하려고 한다. 최소 몇 개의 JOIN 조건이 필요한가?","","3","1","5개"
"183","4개의 테이블로부터 필요한 칼럼을 조회하려고 한다. 최소 몇 개의 JOIN 조건이 필요한가?","","3","2","4개"
"183","4개의 테이블로부터 필요한 칼럼을 조회하려고 한다. 최소 몇 개의 JOIN 조건이 필요한가?","","3","3","3개"
"183","4개의 테이블로부터 필요한 칼럼을 조회하려고 한다. 최소 몇 개의 JOIN 조건이 필요한가?","","3","4","2개"
"189","그룹 내 순위 관련 WINDOW 함수의 특징으로 틀린 것은?","","1","1","CUMM_RANK 함수는 누적된 순위를 부여할 수 있다(등수를 누적 순위로 표현함)."
"189","그룹 내 순위 관련 WINDOW 함수의 특징으로 틀린 것은?","","1","2","RANK 함수가 동일한 값에 대해서는 동일한 순위를 부여하는 데 반해 ROW_NUMBER 함수는 고유한 순위를 부여한다(같은 등수가 존재할 수 없음)."
"189","그룹 내 순위 관련 WINDOW 함수의 특징으로 틀린 것은?","","1","3","DENSE_RANK 함수는 RANK 함수와 흡사하나 동일한 순위를 하나의 건수로 취급하는 것이 틀린 점이다(같은 등수에 여럿이 존재하는 경우에도 등수가 SKIP되지 않음)."
"189","그룹 내 순위 관련 WINDOW 함수의 특징으로 틀린 것은?","","1","4","RANK 함수는 동일한 값에 대해서는 동일한 순위를 부여한다(같은 등수에 여럿이 존재하는 경우 등수가 SKIP될 수 있음)."
"213","다음 중 홍길동 사용자에게 아래의 작업을 실행할 수 있도록 권한을 부여한 것으로 올바른 것은 무엇인가?","Update emp set sal=1000
where deptno=100;","4","1","grant create table on 홍길동 on emp;"
"213","다음 중 홍길동 사용자에게 아래의 작업을 실행할 수 있도록 권한을 부여한 것으로 올바른 것은 무엇인가?","Update emp set sal=1000
where deptno=100;","4","2","revoke select, update on emp;"
"213","다음 중 홍길동 사용자에게 아래의 작업을 실행할 수 있도록 권한을 부여한 것으로 올바른 것은 무엇인가?","Update emp set sal=1000
where deptno=100;","4","3","grant select, update on emp;"
"213","다음 중 홍길동 사용자에게 아래의 작업을 실행할 수 있도록 권한을 부여한 것으로 올바른 것은 무엇인가?","Update emp set sal=1000
where deptno=100;","4","4","grant select, update on emp to 홍길동;"
"218","다음 SQL문의 실행 결과는 무엇인가?","SELECT COALESCE(NULL,'2','1') FROM DUAL;","3","1","NULL"
"218","다음 SQL문의 실행 결과는 무엇인가?","SELECT COALESCE(NULL,'2','1') FROM DUAL;","3","2","3"
"218","다음 SQL문의 실행 결과는 무엇인가?","SELECT COALESCE(NULL,'2','1') FROM DUAL;","3","3","2"
"218","다음 SQL문의 실행 결과는 무엇인가?","SELECT COALESCE(NULL,'2','1') FROM DUAL;","3","4","1"
"225","CASE문에서 ELSE를 생략하면 어떤 현상이 발생되는가?","","1","1","ELSE 조건이 만족하게 되면 NULL이 된다."
"225","CASE문에서 ELSE를 생략하면 어떤 현상이 발생되는가?","","1","2","ELSE 조건을 만족하게 되면 무시한다."
"225","CASE문에서 ELSE를 생략하면 어떤 현상이 발생되는가?","","1","3","ELSE 조건이 만족하게 되면 공집합이 리턴 된다."
"225","CASE문에서 ELSE를 생략하면 어떤 현상이 발생되는가?","","1","4","ELSE를 생략하고 작성하면 실행 시 ELSE 조건이 참이 되며 오류가 발생한다."
"273","다음 중 DDL 문이 아닌 것은?","","2","1","ALTER"
"273","다음 중 DDL 문이 아닌 것은?","","2","2","COMMIT"
"273","다음 중 DDL 문이 아닌 것은?","","2","3","RENAME"
"273","다음 중 DDL 문이 아닌 것은?","","2","4","CREATE TABLE"
"275","다음 SQL문의 실행 결과로 올바른 것은?","Create table Mytest(COL1 number(10));
INSERT INTO Mytest VALUES(2);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET COL1=7 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE CO1=7;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(20);
ROLLBACK TO SV2;
COMMIT;
SELECT * FROM mytest;","1","1","7,7,9"
"275","다음 SQL문의 실행 결과로 올바른 것은?","Create table Mytest(COL1 number(10));
INSERT INTO Mytest VALUES(2);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET COL1=7 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE CO1=7;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(20);
ROLLBACK TO SV2;
COMMIT;
SELECT * FROM mytest;","1","2","7,9,11,9"
"275","다음 SQL문의 실행 결과로 올바른 것은?","Create table Mytest(COL1 number(10));
INSERT INTO Mytest VALUES(2);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET COL1=7 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE CO1=7;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(20);
ROLLBACK TO SV2;
COMMIT;
SELECT * FROM mytest;","1","3","7,9,11"
"275","다음 SQL문의 실행 결과로 올바른 것은?","Create table Mytest(COL1 number(10));
INSERT INTO Mytest VALUES(2);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET COL1=7 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE CO1=7;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(20);
ROLLBACK TO SV2;
COMMIT;
SELECT * FROM mytest;","1","4","1,2"
"292","다음 중 파티션에 대한 설명으로 올바르지 않은 것은?","","1","1","AVG(SAL) OVER
(PARTITION BY MGR
ORDER BY TODAY
ROWS BETWEEN 1 PRECEDING
AND 1 FOLLOWING)
: 각 MGR 별로 앞의 한 건, 현재 행, 뒤의 한 건 사이에서 SAL의 평균을 계산한다."
"292","다음 중 파티션에 대한 설명으로 올바르지 않은 것은?","","1","2","COUNT(*) OVER
(ORDER BY SAL)
RANGE BETWEEN
10 PRECEDING
AND 150 FOLLOWING)
: SAL을 기준으로 현재 행에서의 SAL의 -10에서 +150사이의 급여를 가지는 행의 수를 계산한다."
"292","다음 중 파티션에 대한 설명으로 올바르지 않은 것은?","","1","3","SUM(SAL) OVER
(PARTITION BY MGR
ORDER BY SAL
RANGE UNBOUNDED
PRECEDING)
:각 MGR별 현재 행부터 파티션 내 첫 번째 행까지의 SAL의 합계를 계산한다."
"292","다음 중 파티션에 대한 설명으로 올바르지 않은 것은?","","1","4","RANK() OVER
(PARTITION BY JOB
ORDER BY SAL ASC) JOB_RANK
:각 JOB 별 SAL이 낮은 순서대로 순위가 부여된다. "
"300","다음의 SQL문을 ANSI 표준 SQL문으로 올바르게 변환한 것은?","SELECT * FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNAME = 'SALES';","1","1","SELECT * FROM SCOTT.EMP A
INNER JOIN SCOTT.DEPT B
ON A.DEPTNO = B.DEPTNO WHERE 1=1
AND B.DNAME = 'SALES';"
"300","다음의 SQL문을 ANSI 표준 SQL문으로 올바르게 변환한 것은?","SELECT * FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNAME = 'SALES';","1","2","SELECT * FROM SCOTT.EMP A
CROSS JOIN SCOTT.DEPT B
ON (A.DEPTNO = B.DEPTNO AND
B.DNAME = 'SALES');"
"300","다음의 SQL문을 ANSI 표준 SQL문으로 올바르게 변환한 것은?","SELECT * FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNAME = 'SALES';","1","3","SELECT * FROM SCOTT.EMP A
RIGHT OUTER JOIN SCOTT.DEPT B
ON (A.DEPTNO = B.DEPTNO AND
B.DNAME = 'SALES');"
"300","다음의 SQL문을 ANSI 표준 SQL문으로 올바르게 변환한 것은?","SELECT * FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNAME = 'SALES';","1","4","SELECT * FROM SCOTT.EMP A 
LEFT OUTER JOIN SCOTT.DEPT B
ON(A.DEPTNO = B.DEPTNO AND
B.DNAME 'SALES');"
"314","엔터티 간의 관계 중 비식별 관계에 대한 설명으로 올바르지 않은 것은?","","1","1","반드시 부모 엔터티에 종속한다."
"314","엔터티 간의 관계 중 비식별 관계에 대한 설명으로 올바르지 않은 것은?","","1","2","부모 쪽의 관계 참여가 선택적 관계이다."
"314","엔터티 간의 관계 중 비식별 관계에 대한 설명으로 올바르지 않은 것은?","","1","3","엔터티 간의 관계를 점선으로 표현한다."
"314","엔터티 간의 관계 중 비식별 관계에 대한 설명으로 올바르지 않은 것은?","","1","4","약한 연결 관계를 표현하고 있다."
"321","다음 중 엔터티, 인스턴스, 속성, 속성 값의 관계로 올바르지 않은 것은?","","1","1","한 개의 엔터티는 한 개의 속성만 가지고 있다."
"321","다음 중 엔터티, 인스턴스, 속성, 속성 값의 관계로 올바르지 않은 것은?","","1","2","한 개의 엔터티에는 두 개 이상의 인스턴스가 있다."
"321","다음 중 엔터티, 인스턴스, 속성, 속성 값의 관계로 올바르지 않은 것은?","","1","3","한 개의 속성은 한 개의 속성값을 가지고 있다."
"321","다음 중 엔터티, 인스턴스, 속성, 속성 값의 관계로 올바르지 않은 것은?","","1","4","한 개의 엔터티에는 두 개 이상의 속성이 있다."
"327","다음 SQL문에 대한 실행 계획을 읽는 순서로 올바른 것은?","1. Nested loops
2.    Hash join
3.    TABLE ACCESS (FULL) TABLE1
4.    TABLE ACCESS (FULL) TABLE2
5.  TABLE ACCESS (BY ROWID) TABLE3
6.     INDEX (UNIQUE SCAN) PK_TABLES3","4","1","6,5,4,3,2,1"
"327","다음 SQL문에 대한 실행 계획을 읽는 순서로 올바른 것은?","1. Nested loops
2.    Hash join
3.    TABLE ACCESS (FULL) TABLE1
4.    TABLE ACCESS (FULL) TABLE2
5.  TABLE ACCESS (BY ROWID) TABLE3
6.     INDEX (UNIQUE SCAN) PK_TABLES3","4","2","3,4,6,2,5,1"
"327","다음 SQL문에 대한 실행 계획을 읽는 순서로 올바른 것은?","1. Nested loops
2.    Hash join
3.    TABLE ACCESS (FULL) TABLE1
4.    TABLE ACCESS (FULL) TABLE2
5.  TABLE ACCESS (BY ROWID) TABLE3
6.     INDEX (UNIQUE SCAN) PK_TABLES3","4","3","1,2,3,4,5,6"
"327","다음 SQL문에 대한 실행 계획을 읽는 순서로 올바른 것은?","1. Nested loops
2.    Hash join
3.    TABLE ACCESS (FULL) TABLE1
4.    TABLE ACCESS (FULL) TABLE2
5.  TABLE ACCESS (BY ROWID) TABLE3
6.     INDEX (UNIQUE SCAN) PK_TABLES3","4","4","3,4,2,6,5,1"
"344","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","1","서브쿼리는 SELECT절, FROM절, WHERE절 등에서 사용 가능하다."
"344","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","2","메인쿼리에서 서브쿼리 내에 있는 칼럼을 사용할 수 없다."
"344","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","3","서브쿼리는 단일행 서브쿼리와 다중행 서브쿼리로 분리되고 다중행 서브쿼리의 경우 IN, ANY, EXISTS, ALL과 같은 함수를 사용해야 한다."
"344","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","4","서브쿼리는 SQL문의 SELECT구, FROM구, WHERE구 모두 사용이 가능하다."
"369","TRUNCATE TABLE 명령어에 대한 특징으로 가장 올바른 것은?","","4","1","삭제한 데이터는 되돌릴 수 있다."
"369","TRUNCATE TABLE 명령어에 대한 특징으로 가장 올바른 것은?","","4","2","테이블 용량은 줄어들지 않는다."
"369","TRUNCATE TABLE 명령어에 대한 특징으로 가장 올바른 것은?","","4","3","테이블의 구조를 포함한 테이블 자체가 삭제된다."
"369","TRUNCATE TABLE 명령어에 대한 특징으로 가장 올바른 것은?","","4","4","특정 행을 삭제할 수 없다."
"374","다음의 SQL문이 실행되었을 때 ""실행 결과""와 같이 조회되는 것은?","","2","1","SELECT * FROM MYTEST;"
"374","다음의 SQL문이 실행되었을 때 ""실행 결과""와 같이 조회되는 것은?","","2","2","SELECT * FROM MYTEST START WITH CCOL3 = 'B'
CONNECT BY PRIOR NCOL1 = NCOL2 AND
PRIOR CCOL4 = 'B';"
"374","다음의 SQL문이 실행되었을 때 ""실행 결과""와 같이 조회되는 것은?","","2","3","SELECT * FROM MYTEST START WITH CCOL3 = 'B'
CONNECT BY PRIOR NCOL1 = NCOL2 AND
PRIOR CCOL3 = 'B';"
"374","다음의 SQL문이 실행되었을 때 ""실행 결과""와 같이 조회되는 것은?","","2","4","SELECT * FROM MYTEST WHERE NCOL1 =4
START WITH NCOL2 IS NULL CONNECT BY PRIOR NCOL1 = NCOL2;"
"388","다음 중 물리적 테이블 명으로 올바른 것은?","","4","1","100-ABC"
"388","다음 중 물리적 테이블 명으로 올바른 것은?","","4","2","ABC-1A00"
"388","다음 중 물리적 테이블 명으로 올바른 것은?","","4","3","200_TAB"
"388","다음 중 물리적 테이블 명으로 올바른 것은?","","4","4","ABC_100"
"399","다음 SQL의 실행 결과는?","SELECT 1 FROM DUAL
UNION
SELECT 2 FROM DUAL
UNION
SELECT 1 FROM DUAL;","3","1","1,2,1"
"399","다음 SQL의 실행 결과는?","SELECT 1 FROM DUAL
UNION
SELECT 2 FROM DUAL
UNION
SELECT 1 FROM DUAL;","3","2","2,1"
"399","다음 SQL의 실행 결과는?","SELECT 1 FROM DUAL
UNION
SELECT 2 FROM DUAL
UNION
SELECT 1 FROM DUAL;","3","3","1,2"
"399","다음 SQL의 실행 결과는?","SELECT 1 FROM DUAL
UNION
SELECT 2 FROM DUAL
UNION
SELECT 1 FROM DUAL;","3","4","1"
"405","식별자 분류체계에서 업무에 의해서 만들어지는 식별자로 대체 여부로 분류되는 것은?","","2","1","단일 식별자"
"405","식별자 분류체계에서 업무에 의해서 만들어지는 식별자로 대체 여부로 분류되는 것은?","","2","2","본질 식별자"
"405","식별자 분류체계에서 업무에 의해서 만들어지는 식별자로 대체 여부로 분류되는 것은?","","2","3","내부 식별자"
"405","식별자 분류체계에서 업무에 의해서 만들어지는 식별자로 대체 여부로 분류되는 것은?","","2","4","주식별자"
"439","SELECT문의 결과 집합에 따른 가상의 순번은 무엇인가?","","3","1","HASH"
"439","SELECT문의 결과 집합에 따른 가상의 순번은 무엇인가?","","3","2","COUNT"
"439","SELECT문의 결과 집합에 따른 가상의 순번은 무엇인가?","","3","3","ROWNUM"
"439","SELECT문의 결과 집합에 따른 가상의 순번은 무엇인가?","","3","4","ROWID"
"440","DBA가 데이터를 잘못 수정하여서 COMMIT 하기 전 원래의 값으로 복원하는 SQL구는?","","3","1","REVOKE"
"440","DBA가 데이터를 잘못 수정하여서 COMMIT 하기 전 원래의 값으로 복원하는 SQL구는?","","3","2","GRANT"
"440","DBA가 데이터를 잘못 수정하여서 COMMIT 하기 전 원래의 값으로 복원하는 SQL구는?","","3","3","ROLLBACK"
"440","DBA가 데이터를 잘못 수정하여서 COMMIT 하기 전 원래의 값으로 복원하는 SQL구는?","","3","4","COMMIT"
"444","다음의 정규화 단계에서 주식별자와 관련성이 가장 낮은 것은?","","2","1","BCNF"
"444","다음의 정규화 단계에서 주식별자와 관련성이 가장 낮은 것은?","","2","2","제3정규화"
"444","다음의 정규화 단계에서 주식별자와 관련성이 가장 낮은 것은?","","2","3","제2정규화"
"444","다음의 정규화 단계에서 주식별자와 관련성이 가장 낮은 것은?","","2","4","제1정규화"
"445","엔터티의 종류 중 다:다 관계를 해소하려는 목적으로 인위적으로 만들어진 엔터티는 무엇인가?","","2","1","종속 엔터티"
"445","엔터티의 종류 중 다:다 관계를 해소하려는 목적으로 인위적으로 만들어진 엔터티는 무엇인가?","","2","2","교차 엔터티"
"445","엔터티의 종류 중 다:다 관계를 해소하려는 목적으로 인위적으로 만들어진 엔터티는 무엇인가?","","2","3","행위 엔터티"
"445","엔터티의 종류 중 다:다 관계를 해소하려는 목적으로 인위적으로 만들어진 엔터티는 무엇인가?","","2","4","기본 엔터티"
"455","다음의 GROUP BY문구와 동일한 SQL문을 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","3","1","동일한 보기가 없음"
"455","다음의 GROUP BY문구와 동일한 SQL문을 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","3","2","GROUP BY DEPTNO UNION ALL
GROUP BY JOB UNION ALL
GROUP BY (JOB, DEPTNO)"
"455","다음의 GROUP BY문구와 동일한 SQL문을 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","3","3","GROUP BY GROUPING SETS
(DEPTNO, JOB, (DEPTNO, JOB), ());"
"455","다음의 GROUP BY문구와 동일한 SQL문을 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","3","4","GROUP BY ROLLUP(DEPTNO);"
"487","다음 중 엔터티, 관계, 속성에 대한 설명으로 올바르지 않은 것은?","","3","1","한 개의 속성은 한 개의 속성값을 갖는다."
"487","다음 중 엔터티, 관계, 속성에 대한 설명으로 올바르지 않은 것은?","","3","2","한 개의 엔터티는 두 개 이상의 속성을 갖는다."
"487","다음 중 엔터티, 관계, 속성에 대한 설명으로 올바르지 않은 것은?","","3","3","엔터티는 관계를 두 개까지만 가질 수 있다."
"487","다음 중 엔터티, 관계, 속성에 대한 설명으로 올바르지 않은 것은?","","3","4","한 개의 엔터티는 두 개 이상의 인스턴스 집합이어야 한다."
"509","다음 보기 중 SELF JOIN을 수행해야 하는 경우로 가장 올바른 것은?","","4","1","한 테이블 내에서 서로 연관된 칼럼이 없을 경우 사용하는 방법이다."
"509","다음 보기 중 SELF JOIN을 수행해야 하는 경우로 가장 올바른 것은?","","4","2","온라인 쇼핑몰에서 주문정보는 주문정보를 사용해서 SELF JOIN을 한다."
"509","다음 보기 중 SELF JOIN을 수행해야 하는 경우로 가장 올바른 것은?","","4","3","네트워크로 분산된 시스템에서 같은 2개의 테이블을 조인하기 위해서 사용된다."
"509","다음 보기 중 SELF JOIN을 수행해야 하는 경우로 가장 올바른 것은?","","4","4","동일한 테이블 내에서 두 개의 칼럼 간에 조인을 수행한다."
"519","주어진 보기의 SQL(ROLLUP)에 대한 결과와 동일한 결과를 반환하도록 아래 SQL문의 (     )에 올바른 것은?","SELECT COL1, COL2, COUNT(*)
FROM TEST46
GROUP BY ROLLUP (COL1, COL2);

SELECT COL1, COL2, COUNT(*)
FROM TEST46
GROUP BY GROUPING SETS (       )","1","1","UNION ALL"
"519","주어진 보기의 SQL(ROLLUP)에 대한 결과와 동일한 결과를 반환하도록 아래 SQL문의 (     )에 올바른 것은?","SELECT COL1, COL2, COUNT(*)
FROM TEST46
GROUP BY ROLLUP (COL1, COL2);

SELECT COL1, COL2, COUNT(*)
FROM TEST46
GROUP BY GROUPING SETS (       )","1","2","MINUS"
"519","주어진 보기의 SQL(ROLLUP)에 대한 결과와 동일한 결과를 반환하도록 아래 SQL문의 (     )에 올바른 것은?","SELECT COL1, COL2, COUNT(*)
FROM TEST46
GROUP BY ROLLUP (COL1, COL2);

SELECT COL1, COL2, COUNT(*)
FROM TEST46
GROUP BY GROUPING SETS (       )","1","3","EXPECT"
"519","주어진 보기의 SQL(ROLLUP)에 대한 결과와 동일한 결과를 반환하도록 아래 SQL문의 (     )에 올바른 것은?","SELECT COL1, COL2, COUNT(*)
FROM TEST46
GROUP BY ROLLUP (COL1, COL2);

SELECT COL1, COL2, COUNT(*)
FROM TEST46
GROUP BY GROUPING SETS (       )","1","4","UNION "
"528","다음 중 엔터티 간의 관계에서 1:1, 1:M과 같이 관계의 기수성을 나타내는 것은?","","3","1","관계정의"
"528","다음 중 엔터티 간의 관계에서 1:1, 1:M과 같이 관계의 기수성을 나타내는 것은?","","3","2","도메인"
"528","다음 중 엔터티 간의 관계에서 1:1, 1:M과 같이 관계의 기수성을 나타내는 것은?","","3","3","관계차수"
"528","다음 중 엔터티 간의 관계에서 1:1, 1:M과 같이 관계의 기수성을 나타내는 것은?","","3","4","관계명"
"534","다음 주어진 SQL문을 수행하였을 때의 결과가 아래와 같을 때 (      )에 들어갈 것으로 알맞은 것은?","SELECT 10 + 20 * ((      )NULL, 0.1, 0.2))
FROM DUAL;
결과 : 14","2","1","COALESCE"
"534","다음 주어진 SQL문을 수행하였을 때의 결과가 아래와 같을 때 (      )에 들어갈 것으로 알맞은 것은?","SELECT 10 + 20 * ((      )NULL, 0.1, 0.2))
FROM DUAL;
결과 : 14","2","2","NVL2"
"534","다음 주어진 SQL문을 수행하였을 때의 결과가 아래와 같을 때 (      )에 들어갈 것으로 알맞은 것은?","SELECT 10 + 20 * ((      )NULL, 0.1, 0.2))
FROM DUAL;
결과 : 14","2","3","NVL"
"534","다음 주어진 SQL문을 수행하였을 때의 결과가 아래와 같을 때 (      )에 들어갈 것으로 알맞은 것은?","SELECT 10 + 20 * ((      )NULL, 0.1, 0.2))
FROM DUAL;
결과 : 14","2","4","ISNULL"
"563","스키마에 대한 내용 잘못된 것을 두 개 고르세요.","","1,2","1","외부 스키마는 모든 사용자 관점을 통합한 전체적인 하나의 관점으로 구성되어 있다."
"563","스키마에 대한 내용 잘못된 것을 두 개 고르세요.","","1,2","2","개념 스키마는 View 단계 여러 개의 사용자 관점으로 구성되며, 개개 사용자 단계로서 개개 사용자나 응용프로그래머가 접근하는 DB 정의이다."
"563","스키마에 대한 내용 잘못된 것을 두 개 고르세요.","","1,2","3","내부스키마는 DB가 물리적으로 저장된 형식을 말한다."
"563","스키마에 대한 내용 잘못된 것을 두 개 고르세요.","","1,2","4","외부스키마는 사용자 관점이며, 접근하는 특성에 따른 스키마로 구성되어 있다."
"575","다음은 식별자의 특징 중 무엇을 설명하고 있는가? 
","사원번호 없는 회사직원은 있을 수 없음","1","1","존재성"
"575","다음은 식별자의 특징 중 무엇을 설명하고 있는가? 
","사원번호 없는 회사직원은 있을 수 없음","1","2","불변성"
"575","다음은 식별자의 특징 중 무엇을 설명하고 있는가? 
","사원번호 없는 회사직원은 있을 수 없음","1","3","최소성"
"575","다음은 식별자의 특징 중 무엇을 설명하고 있는가? 
","사원번호 없는 회사직원은 있을 수 없음","1","4","유일성"
"582","SQL의 종류와 해당되는 명령어를 연결한 것 중 틀린 것은?","","4","1","DDL - ALTER"
"582","SQL의 종류와 해당되는 명령어를 연결한 것 중 틀린 것은?","","4","2","DCL - GRANT"
"582","SQL의 종류와 해당되는 명령어를 연결한 것 중 틀린 것은?","","4","3","TCL - COMMIT"
"582","SQL의 종류와 해당되는 명령어를 연결한 것 중 틀린 것은?","","4","4","DML - TRUNCATE"
"585","함수의 실행 결과로 적절하지 않은 것은?","","2","1","SIGN(120) : 1"
"585","함수의 실행 결과로 적절하지 않은 것은?","","2","2","ROUND(12345.678, -2) : 12350"
"585","함수의 실행 결과로 적절하지 않은 것은?","","2","3","FLOOR(3.5) : 3"
"585","함수의 실행 결과로 적절하지 않은 것은?","","2","4","CEIL(3.5) : 4"
"589","아래 SQL의 실행 결과로 가장 적절한 것은?(단, DBMS는 ORACLE로 가정)","SELECT TO_CHAR(TO_DATE('2024/08/24 10:00', 'YYYY/MM/DD HH24:MI') - 30/24/60, 'YYYY.MM.DD HH24:MI:SS') FROM DUAL;","2","1","2024.08.24 09:59:30"
"589","아래 SQL의 실행 결과로 가장 적절한 것은?(단, DBMS는 ORACLE로 가정)","SELECT TO_CHAR(TO_DATE('2024/08/24 10:00', 'YYYY/MM/DD HH24:MI') - 30/24/60, 'YYYY.MM.DD HH24:MI:SS') FROM DUAL;","2","2","2024.08.24 09:30:00"
"589","아래 SQL의 실행 결과로 가장 적절한 것은?(단, DBMS는 ORACLE로 가정)","SELECT TO_CHAR(TO_DATE('2024/08/24 10:00', 'YYYY/MM/DD HH24:MI') - 30/24/60, 'YYYY.MM.DD HH24:MI:SS') FROM DUAL;","2","3","2024.08.24 06:00:00"
"589","아래 SQL의 실행 결과로 가장 적절한 것은?(단, DBMS는 ORACLE로 가정)","SELECT TO_CHAR(TO_DATE('2024/08/24 10:00', 'YYYY/MM/DD HH24:MI') - 30/24/60, 'YYYY.MM.DD HH24:MI:SS') FROM DUAL;","2","4","2024.07.25 10:00:00"
"603","다음 SQL 중 정상 수행이 불가한 것은? "
"","","3","1","UPDATE TAB1 A 
     SET A.NAME = (SELECT B.NAME 
                     FROM TAB2 B 
                    WHERE A.NO = B.NO);"
"603","다음 SQL 중 정상 수행이 불가한 것은? "
"","","3","2","SELECT NO  
    FROM TAB1 A JOIN TAB2 B 
   USING (NO);"
"603","다음 SQL 중 정상 수행이 불가한 것은? "
"","","3","3","SELECT A.NO, (SELECT B.NAME 
                   FROM TAB2 B) 
    FROM TAB1 A 
   WHERE A.NO = B.NO;"
"603","다음 SQL 중 정상 수행이 불가한 것은? "
"","","3","4","SELECT * 
    FROM TAB1 A 
   WHERE NOT EXISTS (SELECT 'X' 
                         FROM TAB2 B 
                        WHERE A.NO = B.NO); "
"624","데이터 모델링의 관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","1","관계의 표기법은 관계명, 관계차수, 선택성 3가지 개념을 사용한다."
"624","데이터 모델링의 관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","2","관계의 페어링은 하나의 엔터티와 다른 엔터티 간의 레코드 연결 방식을 나타낸다."
"624","데이터 모델링의 관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","3","부서와 사원 엔터티 간의 ‘소속’ 관계는 존재적 관계의 사례이다."
"624","데이터 모델링의 관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","4","관계는 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있으나 ERD에서는 존재와 행위를 구분하지 않는다."
"627","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?  ","","3","1","관계는 엔터티간의 논리적 연관성을 의미한다."
"627","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?  ","","3","2","엔터티 간의 관계를 통해 데이터의 중복을 피하고, 각 데이터 요소를 한 번만 저장하여 유지관리의 복잡성을 줄일 수 있다."
"627","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?  ","","3","3","부모의 식별자를 자식의 일반속성으로 상속하면 식별 관계, 부모의 식별자를 자식의 식별자에 포함하면 비식별 관계라고 할 수 있다."
"627","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?  ","","3","4","조인(Join)이란 식별자를 상속하고, 상속된 속성을 매핑키로 활용하여 데이터를 결합하는 것을 의미한다."
"628","트랜잭션에 대한 설명 중 가장 적절하지 않은 것은?","","4","1","하나의 트랜잭션으로 구성된 작업은 부분 COMMIT이 불가하다."
"628","트랜잭션에 대한 설명 중 가장 적절하지 않은 것은?","","4","2","순차적으로 수행되는 작업 A와 B가 하나의 트랜잭션일 경우 A만 실행되고 시스템 장애가 발생했다면 A를 undo해야 한다."
"628","트랜잭션에 대한 설명 중 가장 적절하지 않은 것은?","","4","3","원자성이란 하나의 트랜잭션의 작업이 모두 성공하거나 모두 취소되어야 하는 특징을 말한다."
"628","트랜잭션에 대한 설명 중 가장 적절하지 않은 것은?","","4","4","트랜잭션에 의한 관계는 선택적인 관계 형태를 가진다."
"634","아래의 SQL 에 대해서 결과값이 다른 것은? ","","1","1","SELECT 'RDBMS' & ' SQL' FROM DUAL;"
"634","아래의 SQL 에 대해서 결과값이 다른 것은? ","","1","2","SELECT 'RDBMS' + ' SQL';"
"634","아래의 SQL 에 대해서 결과값이 다른 것은? ","","1","3","SELECT 'RDMBS' || ' SQL' FROM DUAL;"
"634","아래의 SQL 에 대해서 결과값이 다른 것은? ","","1","4","SELECT CONCAT ('RDBMS', ' SQL') FROM DUAL;"
"635","아래 SQL에서 밑줄 친 자리에 쓰인 함수의 결과가 다른 하나는? ","SELECT _________(5.47) FROM DUAL; ","3","1","ROUND"
"635","아래 SQL에서 밑줄 친 자리에 쓰인 함수의 결과가 다른 하나는? ","SELECT _________(5.47) FROM DUAL; ","3","2","FLOOR"
"635","아래 SQL에서 밑줄 친 자리에 쓰인 함수의 결과가 다른 하나는? ","SELECT _________(5.47) FROM DUAL; ","3","3","CEIL"
"635","아래 SQL에서 밑줄 친 자리에 쓰인 함수의 결과가 다른 하나는? ","SELECT _________(5.47) FROM DUAL; ","3","4","TRUNC"
"666","아래 SQL 실행 결과로 가장 적절한 것은? ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
 
INSERT INTO TAB1 VALUES(1,10); 
INSERT INTO TAB1 VALUES(2,20); 
INSERT INTO TAB1 VALUES(3,30); 
COMMIT; 
 
ALTER TABLE TAB1 ADD (COL3 NUMBER); 
 
INSERT INTO TAB1 VALUES(4,40,100); 
UPDATE TAB1 SET COL2 = 50 WHERE COL1 = 1; 
DELETE TAB1 WHERE COL1 = 3; 
 
ALTER TABLE TAB1 DROP COLUMN COL1; 
 
ROLLBACK; 
 
SELECT SUM(COL2 + COL3) FROM TAB1; ","1","1","140"
"666","아래 SQL 실행 결과로 가장 적절한 것은? ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
 
INSERT INTO TAB1 VALUES(1,10); 
INSERT INTO TAB1 VALUES(2,20); 
INSERT INTO TAB1 VALUES(3,30); 
COMMIT; 
 
ALTER TABLE TAB1 ADD (COL3 NUMBER); 
 
INSERT INTO TAB1 VALUES(4,40,100); 
UPDATE TAB1 SET COL2 = 50 WHERE COL1 = 1; 
DELETE TAB1 WHERE COL1 = 3; 
 
ALTER TABLE TAB1 DROP COLUMN COL1; 
 
ROLLBACK; 
 
SELECT SUM(COL2 + COL3) FROM TAB1; ","1","2","130"
"666","아래 SQL 실행 결과로 가장 적절한 것은? ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
 
INSERT INTO TAB1 VALUES(1,10); 
INSERT INTO TAB1 VALUES(2,20); 
INSERT INTO TAB1 VALUES(3,30); 
COMMIT; 
 
ALTER TABLE TAB1 ADD (COL3 NUMBER); 
 
INSERT INTO TAB1 VALUES(4,40,100); 
UPDATE TAB1 SET COL2 = 50 WHERE COL1 = 1; 
DELETE TAB1 WHERE COL1 = 3; 
 
ALTER TABLE TAB1 DROP COLUMN COL1; 
 
ROLLBACK; 
 
SELECT SUM(COL2 + COL3) FROM TAB1; ","1","3","120"
"666","아래 SQL 실행 결과로 가장 적절한 것은? ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
 
INSERT INTO TAB1 VALUES(1,10); 
INSERT INTO TAB1 VALUES(2,20); 
INSERT INTO TAB1 VALUES(3,30); 
COMMIT; 
 
ALTER TABLE TAB1 ADD (COL3 NUMBER); 
 
INSERT INTO TAB1 VALUES(4,40,100); 
UPDATE TAB1 SET COL2 = 50 WHERE COL1 = 1; 
DELETE TAB1 WHERE COL1 = 3; 
 
ALTER TABLE TAB1 DROP COLUMN COL1; 
 
ROLLBACK; 
 
SELECT SUM(COL2 + COL3) FROM TAB1; ","1","4","110"
"668","다음 설명 중 가장 적절하지 않은 것은? (단, DBMS는 오라클) ","","4","1","컬럼은 동시에 여러 개를 삭제할 수 없다."
"668","다음 설명 중 가장 적절하지 않은 것은? (단, DBMS는 오라클) ","","4","2","컬럼 추가 시 DEFAULT값을 선언하면 기존 데이터의 새로운 컬럼 값은 DEFAULT값이 된다."
"668","다음 설명 중 가장 적절하지 않은 것은? (단, DBMS는 오라클) ","","4","3","컬럼 사이즈는 언제든지 늘릴 수 있다."
"668","다음 설명 중 가장 적절하지 않은 것은? (단, DBMS는 오라클) ","","4","4","데이터 타입을 변경할 경우에는 반드시 빈 컬럼이어야 한다."
"670","다음 중 유저가 갖는 권한에 대한 설명으로 가장 적절한 것은?","SYSTEM) GRANT SELECT, INSERT ON SCOTT.EMP TO HR WITH GRANT OPTION; 
SYSTEM) GRANT CREATE VIEW TO HR WITH ADMIN OPTION; 
HR) GRANT SELECT, INSERT ON SCOTT.EMP TO HONG; 
HR) GRANT CREATE VIEW TO HONG; 
SYSTEM) REVOKE INSERT ON SCOTT.EMP FROM HR; 
SYSTEM) REVOKE CREATE VIEW FROM HR;","1","1","HR 유저에게 부여된 EMP 테이블 입력 권한 회수 시 HONG에게 부여된 권한도 함께 회수되었다."
"670","다음 중 유저가 갖는 권한에 대한 설명으로 가장 적절한 것은?","SYSTEM) GRANT SELECT, INSERT ON SCOTT.EMP TO HR WITH GRANT OPTION; 
SYSTEM) GRANT CREATE VIEW TO HR WITH ADMIN OPTION; 
HR) GRANT SELECT, INSERT ON SCOTT.EMP TO HONG; 
HR) GRANT CREATE VIEW TO HONG; 
SYSTEM) REVOKE INSERT ON SCOTT.EMP FROM HR; 
SYSTEM) REVOKE CREATE VIEW FROM HR;","1","2","HR이 HONG에게 부여한 EMP 테이블의 조회 권한은 SYSTEM 계정에서 직접 회수가 가능하다."
"670","다음 중 유저가 갖는 권한에 대한 설명으로 가장 적절한 것은?","SYSTEM) GRANT SELECT, INSERT ON SCOTT.EMP TO HR WITH GRANT OPTION; 
SYSTEM) GRANT CREATE VIEW TO HR WITH ADMIN OPTION; 
HR) GRANT SELECT, INSERT ON SCOTT.EMP TO HONG; 
HR) GRANT CREATE VIEW TO HONG; 
SYSTEM) REVOKE INSERT ON SCOTT.EMP FROM HR; 
SYSTEM) REVOKE CREATE VIEW FROM HR;","1","3","HR 유저에게 부여된 CREATE TABLE 권한 회수 시 HONG에게 부여된 CREATE TABLE 권한도 함께  
회수되었다."
"670","다음 중 유저가 갖는 권한에 대한 설명으로 가장 적절한 것은?","SYSTEM) GRANT SELECT, INSERT ON SCOTT.EMP TO HR WITH GRANT OPTION; 
SYSTEM) GRANT CREATE VIEW TO HR WITH ADMIN OPTION; 
HR) GRANT SELECT, INSERT ON SCOTT.EMP TO HONG; 
HR) GRANT CREATE VIEW TO HONG; 
SYSTEM) REVOKE INSERT ON SCOTT.EMP FROM HR; 
SYSTEM) REVOKE CREATE VIEW FROM HR;","1","4","HR 계정에게 부여된 SCOTT.EMP에 대한 SELECT 권한도 함께 회수된다."
"679","NULL에 대한 설명으로 틀린 것은? ","","1","1","공백과 같은 ASCII 값을 가진다."
"679","NULL에 대한 설명으로 틀린 것은? ","","1","2","NULL과의 수치연산은 NULL 값을 리턴한다."
"679","NULL에 대한 설명으로 틀린 것은? ","","1","3","NULL과의 비교연산은 FALSE(거짓)를 리턴한다."
"679","NULL에 대한 설명으로 틀린 것은? ","","1","4","값이 존재하지 않거나 확정되지 않은 값을 의미한다."
"683","다음 설명 중 틀린 하나는? ","","2","1","SELECT 문은 ORDER BY 절이 가장 나중에 실행된다."
"683","다음 설명 중 틀린 하나는? ","","2","2","GROUP BY 절을 사용하는 경우 ORDER BY 절에는 GROUP BY절에 정의되지 않은 컬럼을 사용할 수 있다."
"683","다음 설명 중 틀린 하나는? ","","2","3","테이블 별칭을 선언하면 컬럼 앞의 구분자는 반드시 테이블명 대신 테이블 별칭을 사용한다."
"683","다음 설명 중 틀린 하나는? ","","2","4","ORDER BY 절에 SELECT 절에 정의되지 않은 컬럼을 사용할 수 있다."
"725","다음 중 아래 개념이 설명하는 관계로 가장 적절한 것은?","부모 엔터티의 주식별자를 상속받아 자식 엔터티에서 외부식별자이면서 주식별자로 사용하는 관계","4","1","선택관계"
"725","다음 중 아래 개념이 설명하는 관계로 가장 적절한 것은?","부모 엔터티의 주식별자를 상속받아 자식 엔터티에서 외부식별자이면서 주식별자로 사용하는 관계","4","2","필수관계"
"725","다음 중 아래 개념이 설명하는 관계로 가장 적절한 것은?","부모 엔터티의 주식별자를 상속받아 자식 엔터티에서 외부식별자이면서 주식별자로 사용하는 관계","4","3","비식별관계"
"725","다음 중 아래 개념이 설명하는 관계로 가장 적절한 것은?","부모 엔터티의 주식별자를 상속받아 자식 엔터티에서 외부식별자이면서 주식별자로 사용하는 관계","4","4","식별관계"
"746","다음 중 실행 오류가 발생하는 조인 문법은?","","1","1","SELECT * FROM TAB1 NATURAL JOIN TAB2 USING (COL1);"
"746","다음 중 실행 오류가 발생하는 조인 문법은?","","1","2","SELECT * FROM TAB1 INNER JOIN TAB2 USING (COL1);"
"746","다음 중 실행 오류가 발생하는 조인 문법은?","","1","3","SELECT * FROM TAB1 JOIN TAB2 ON (TAB1.COL1 = TAB2.COL1);"
"746","다음 중 실행 오류가 발생하는 조인 문법은?","","1","4","SELECT * FROM TAB1 LEFT JOIN TAB2 ON TAB1.COL1 = TAB2.COL1;"
"771","다음이 설명하는 모델링 개념으로 가장 적절한 것은?","사용자 관점의 데이터베이스 스키마를 통합하여 데이터베이스의 전체 논리적 구조를 정의하는 단계로  전체 데이터베이스의 개체, 속성, 관계, 데이터 타입 등을 정의한다.","3","1","내부 스키마"
"771","다음이 설명하는 모델링 개념으로 가장 적절한 것은?","사용자 관점의 데이터베이스 스키마를 통합하여 데이터베이스의 전체 논리적 구조를 정의하는 단계로  전체 데이터베이스의 개체, 속성, 관계, 데이터 타입 등을 정의한다.","3","2","논리 스키마"
"771","다음이 설명하는 모델링 개념으로 가장 적절한 것은?","사용자 관점의 데이터베이스 스키마를 통합하여 데이터베이스의 전체 논리적 구조를 정의하는 단계로  전체 데이터베이스의 개체, 속성, 관계, 데이터 타입 등을 정의한다.","3","3","개념 스키마"
"771","다음이 설명하는 모델링 개념으로 가장 적절한 것은?","사용자 관점의 데이터베이스 스키마를 통합하여 데이터베이스의 전체 논리적 구조를 정의하는 단계로  전체 데이터베이스의 개체, 속성, 관계, 데이터 타입 등을 정의한다.","3","4","외부 스키마"
"774","두 개의 엔터티 사이의 관계 도출 시 고려사항이 아닌 것은?","","1","1","업무기술서, 장표에 관계연결을 가능하게 하는 명사가 있는가?"
"774","두 개의 엔터티 사이의 관계 도출 시 고려사항이 아닌 것은?","","1","2","업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?"
"774","두 개의 엔터티 사이의 관계 도출 시 고려사항이 아닌 것은?","","1","3","두 개의 엔터티 사이에 관련 있는 연관규칙이 존재하는가?"
"774","두 개의 엔터티 사이의 관계 도출 시 고려사항이 아닌 것은?","","1","4","두 개의 엔터티 사이에 정보의 조합이 발생되는가?"
"782","다음이 설명하는 용어로 가장 적절한 것은?","데이터베이스의 속성(ATTRIBUTE, 또는 필드)이 가질 수 있는 값들의 범위 또는 집합을 의미한다.","3","1","키"
"782","다음이 설명하는 용어로 가장 적절한 것은?","데이터베이스의 속성(ATTRIBUTE, 또는 필드)이 가질 수 있는 값들의 범위 또는 집합을 의미한다.","3","2","튜플"
"782","다음이 설명하는 용어로 가장 적절한 것은?","데이터베이스의 속성(ATTRIBUTE, 또는 필드)이 가질 수 있는 값들의 범위 또는 집합을 의미한다.","3","3","도메인"
"782","다음이 설명하는 용어로 가장 적절한 것은?","데이터베이스의 속성(ATTRIBUTE, 또는 필드)이 가질 수 있는 값들의 범위 또는 집합을 의미한다.","3","4","릴레이션"
"236","다음과 같은 문장으로 사원 테이블을 생성하였을 때, 사원 테이블에 유효한 데이터를 로드한 후, 아래 두 SQL문을 성공적으로 실행하였다. SQL A와 SQL B의 실행 결과로 옳은 것은?","create table 사원(번호 char(10) primary key, 월급 integer);

SQL A : select count(번호) from 사원 where 월급 > = 100000 or 월급 < 100000;
SQL B : select count(번호) from 사원;","2","1","SQL A와 SQL B의 결과는 다를 수 있으며, 그 이유는 번호 필드에 널(NULL)값이 존재할 수 있기 때문이다."
"236","다음과 같은 문장으로 사원 테이블을 생성하였을 때, 사원 테이블에 유효한 데이터를 로드한 후, 아래 두 SQL문을 성공적으로 실행하였다. SQL A와 SQL B의 실행 결과로 옳은 것은?","create table 사원(번호 char(10) primary key, 월급 integer);

SQL A : select count(번호) from 사원 where 월급 > = 100000 or 월급 < 100000;
SQL B : select count(번호) from 사원;","2","2","SQL A와 SQL B의 결과는 다를 수 있으며, 그 이유는 월급 필드에 널(NULL)값이 존재할 수 있기 때문이다."
"236","다음과 같은 문장으로 사원 테이블을 생성하였을 때, 사원 테이블에 유효한 데이터를 로드한 후, 아래 두 SQL문을 성공적으로 실행하였다. SQL A와 SQL B의 실행 결과로 옳은 것은?","create table 사원(번호 char(10) primary key, 월급 integer);

SQL A : select count(번호) from 사원 where 월급 > = 100000 or 월급 < 100000;
SQL B : select count(번호) from 사원;","2","3","SQL A와 SQL B의 결과는 항상 다르다."
"236","다음과 같은 문장으로 사원 테이블을 생성하였을 때, 사원 테이블에 유효한 데이터를 로드한 후, 아래 두 SQL문을 성공적으로 실행하였다. SQL A와 SQL B의 실행 결과로 옳은 것은?","create table 사원(번호 char(10) primary key, 월급 integer);

SQL A : select count(번호) from 사원 where 월급 > = 100000 or 월급 < 100000;
SQL B : select count(번호) from 사원;","2","4","SQL A와 SQL B의 결과는항상 같다."
"237","다음 SQL 문장 중 COLUMN1의 값이 널이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","1","SELECT * FROM T_TEST WHERE COLUMN1 NOT NULL;"
"237","다음 SQL 문장 중 COLUMN1의 값이 널이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","2","SELECT * FROM T_TEST WHERE COLUMN1 != NULL;"
"237","다음 SQL 문장 중 COLUMN1의 값이 널이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","3","SELECT * FROM T_TEST WHERE COLUMN1 <> NULL;"
"237","다음 SQL 문장 중 COLUMN1의 값이 널이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","4","SELECT * FROM T_TEST WHERE COLUMN1 IS NOT NULL;"
"257","다음의 SQL문에 대한 설명으로 올바른 것은?","SELECT 'A', 1 FROM DUAL
UNION ALL
SELECT 1, 'A' FROM DUAL;","2","1","실행 결과로 아무것도 출력되지 않는다."
"257","다음의 SQL문에 대한 설명으로 올바른 것은?","SELECT 'A', 1 FROM DUAL
UNION ALL
SELECT 1, 'A' FROM DUAL;","2","2","위의 SQL문은 실행되지 않는다."
"257","다음의 SQL문에 대한 설명으로 올바른 것은?","SELECT 'A', 1 FROM DUAL
UNION ALL
SELECT 1, 'A' FROM DUAL;","2","3","UNION ALL을 사용해서 합집합을 만들고 중복을 제거한다."
"257","다음의 SQL문에 대한 설명으로 올바른 것은?","SELECT 'A', 1 FROM DUAL
UNION ALL
SELECT 1, 'A' FROM DUAL;","2","4","위의 SQL문 실행 결과는 A, 1, 1 ,A가 조회된다."
"263","다음의 SQL문에 대한 설명 중 옳지 않은 것은?","SELECT * FROM EMP
WHERE EMPNO LIKE '100%';","2","1","기능상으로는 문제가 없지만 성능 문제가 있다."
"263","다음의 SQL문에 대한 설명 중 옳지 않은 것은?","SELECT * FROM EMP
WHERE EMPNO LIKE '100%';","2","2","EMP 테이블을 FULL SCAN한 것은 인덱스가 없어서이다."
"263","다음의 SQL문에 대한 설명 중 옳지 않은 것은?","SELECT * FROM EMP
WHERE EMPNO LIKE '100%';","2","3","LIKE 조건을 사용하지 말고 "">""를 사용해야 한다."
"263","다음의 SQL문에 대한 설명 중 옳지 않은 것은?","SELECT * FROM EMP
WHERE EMPNO LIKE '100%';","2","4","내부적으로 형변환이 발생했다."
"804","다음 중 관계형 데이터베이스의 특징이 아닌 것은?","","3","1","테이블 기반 구조"
"804","다음 중 관계형 데이터베이스의 특징이 아닌 것은?","","3","2","관계를 통해 데이터 연결"
"804","다음 중 관계형 데이터베이스의 특징이 아닌 것은?","","3","3","절차적 데이터 저장"
"804","다음 중 관계형 데이터베이스의 특징이 아닌 것은?","","3","4","SQL 사용"
"807","ERD에서 관계(Relationship)는 어떤 기호로 표현되는가?","","3","1","원"
"807","ERD에서 관계(Relationship)는 어떤 기호로 표현되는가?","","3","2","사각형"
"807","ERD에서 관계(Relationship)는 어떤 기호로 표현되는가?","","3","3","다이아몬드"
"807","ERD에서 관계(Relationship)는 어떤 기호로 표현되는가?","","3","4","삼각형"
"811","ERD에서 식별자는 무엇을 의미하는가?","","2","1","속성 이름"
"811","ERD에서 식별자는 무엇을 의미하는가?","","2","2","유일하게 개체를 구분하는 키"
"811","ERD에서 식별자는 무엇을 의미하는가?","","2","3","테이블 간의 관계"
"811","ERD에서 식별자는 무엇을 의미하는가?","","2","4","속성 값의 범위"
"9","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","s병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리해야 한다. (단, 업무범위와 데이터의 특성은 상기 시나리오에 기술되어 있는 사항만을 근거하여 판단해야 함)","3","1","주소"
"9","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","s병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리해야 한다. (단, 업무범위와 데이터의 특성은 상기 시나리오에 기술되어 있는 사항만을 근거하여 판단해야 함)","3","2","이름"
"9","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","s병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리해야 한다. (단, 업무범위와 데이터의 특성은 상기 시나리오에 기술되어 있는 사항만을 근거하여 판단해야 함)","3","3","환자"
"9","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","s병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리해야 한다. (단, 업무범위와 데이터의 특성은 상기 시나리오에 기술되어 있는 사항만을 근거하여 판단해야 함)","3","4","병원"
"10","다음 중 엔터티의 특징으로 가장 부적절한 것은?","","2","1","데이터로서 존재하지만 업무에서 필요로 하지 않으면 해당 업무의 엔터티로 성립될 수 없다."
"10","다음 중 엔터티의 특징으로 가장 부적절한 것은?","","2","2","객체지향의 디자인패턴에는 싱글턴패턴이 있어 하나의 인스턴스를 가지는 클래스가 존재한다. 이와 유사하게 엔터티는 한 개의 인스턴스를 가지는 것만으로도 충분한 의미를 부여할 수 있다."
"10","다음 중 엔터티의 특징으로 가장 부적절한 것은?","","2","3","엔터티는 다른 엔터티와 관계가 있을 수 밖에 없다. 단, 통계성 엔터티나, 코드성 엔터티의 경우 관계를 생략할 수 있다."
"10","다음 중 엔터티의 특징으로 가장 부적절한 것은?","","2","4","속성이 없는 엔터티는 있을 수 없다. 엔터티는 반드시 속성을 가져야 한다."
"27","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 가준을 묶은 것으로 가장 적절한 것은?","가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다.
다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다.
라. 자주 수정되는 속성을 주식별자로 지정한다.","3","1","나, 라"
"27","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 가준을 묶은 것으로 가장 적절한 것은?","가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다.
다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다.
라. 자주 수정되는 속성을 주식별자로 지정한다.","3","2","다, 라"
"27","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 가준을 묶은 것으로 가장 적절한 것은?","가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다.
다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다.
라. 자주 수정되는 속성을 주식별자로 지정한다.","3","3","가, 다"
"27","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 가준을 묶은 것으로 가장 적절한 것은?","가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다.
다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다.
라. 자주 수정되는 속성을 주식별자로 지정한다.","3","4","가, 나"
"28","프로젝트를 전개할 때는 식별자관계와 비식별자관계를 선택하여 연결해야 하는 높은 수준의 데이터모델링 기술이 필요하다. 다음 중 비식별자관계를 선택하는 가준으로 가장 부적절한 것은?","","1","1","부모엔터티의 주식별자를 자식엔터티에서 받아 손자엔터티까지 계속 흘려보내기 위해 비식별자관계를 고려한다."
"28","프로젝트를 전개할 때는 식별자관계와 비식별자관계를 선택하여 연결해야 하는 높은 수준의 데이터모델링 기술이 필요하다. 다음 중 비식별자관계를 선택하는 가준으로 가장 부적절한 것은?","","1","2","모든 관계가 식별자 관계로 연결되면 SQL Where절에서 비교하는 항목이 증가되어 조인에 참여하는 테이블에 따라 SQL문장이 길어져 SQL문의 복잡성이 증가되는 것을 방지하기 위해 비식별자관계를 고려한다."
"28","프로젝트를 전개할 때는 식별자관계와 비식별자관계를 선택하여 연결해야 하는 높은 수준의 데이터모델링 기술이 필요하다. 다음 중 비식별자관계를 선택하는 가준으로 가장 부적절한 것은?","","1","3","자식테이블에서 독립적인 Primary Key의 구조를 가지기 원할 때 비식별자관계를 고려한다."
"28","프로젝트를 전개할 때는 식별자관계와 비식별자관계를 선택하여 연결해야 하는 높은 수준의 데이터모델링 기술이 필요하다. 다음 중 비식별자관계를 선택하는 가준으로 가장 부적절한 것은?","","1","4","관계의 강약을 분석하여 상호간에 연관성이 약할 경우 비식별자관계를 고려한다."
"41","다음 중 데이터베아스 시스템 언어의 종류와 해당되는 명령어를 바르게 연결한 것을 2개 고르시오.","","3,4","1","DML - ALTER"
"41","다음 중 데이터베아스 시스템 언어의 종류와 해당되는 명령어를 바르게 연결한 것을 2개 고르시오.","","3,4","2","DCL - DROP"
"41","다음 중 데이터베아스 시스템 언어의 종류와 해당되는 명령어를 바르게 연결한 것을 2개 고르시오.","","3,4","3","TCL - COMMIT"
"41","다음 중 데이터베아스 시스템 언어의 종류와 해당되는 명령어를 바르게 연결한 것을 2개 고르시오.","","3,4","4","DML - SELECT"
"110","다음 중 계층형 질의문에 대한 설명으로 가장 부적절한 것은?","","1","1","오라클의 계층형 질의문에서 PRIOR 키워드는 CONNECT BY 절에만 사용할 수 있으며 'prior 자식 = 부모' 형태로 사용하면 순방향 전개로 수행 된다."
"110","다음 중 계층형 질의문에 대한 설명으로 가장 부적절한 것은?","","1","2","오라클의 계층형 질의문에서 WHERE 절은 모든 전개를 진행한 이후 필터 조건으로서 조건을 만족하는 데이터만을 추출하는데 활용된다."
"110","다음 중 계층형 질의문에 대한 설명으로 가장 부적절한 것은?","","1","3","SQL Server에서의 계층형 질의문은 앵커 멤버를 실행하여 기본 결과 집합을 만들고 이후 재귀 멤버를 지속적으로 실행한다."
"110","다음 중 계층형 질의문에 대한 설명으로 가장 부적절한 것은?","","1","4","SQL Server에서의 게층형 질의문은 CTE(Common Table Expression)를 재귀 호출함으로써 계층 구조를 전개한다."
"119","다음 중 아래 SQL에 대한 설명으로 가장 부적절한 것은?","[SQL]
SELECT B.사원번호, B.사원명, A.부서번호, A.부서명
, (SELECT COUNT(*)  FROM 부양가족 Y WHERE
Y.사원번호 = B.사원번호)  AS 부양가족수
FROM 부서 A, (SELECT *
FROM 사원
WHERE 입사년도 = '2014')  B
WHERE A.부서번호 = B.부서번호
AND EXISTS (SELECT 1 FROM 사원 X WHERE X.부서번호 =
A.부서번호);
","2","1","FROM 절의 서브쿼리는 동적 뷰(Dynamic View)라고도 하며, SQL문장 중 테이블 명이 올 수 있는 곳에서 사용할 수 있다."
"119","다음 중 아래 SQL에 대한 설명으로 가장 부적절한 것은?","[SQL]
SELECT B.사원번호, B.사원명, A.부서번호, A.부서명
, (SELECT COUNT(*)  FROM 부양가족 Y WHERE
Y.사원번호 = B.사원번호)  AS 부양가족수
FROM 부서 A, (SELECT *
FROM 사원
WHERE 입사년도 = '2014')  B
WHERE A.부서번호 = B.부서번호
AND EXISTS (SELECT 1 FROM 사원 X WHERE X.부서번호 =
A.부서번호);
","2","2","WHERE 절의 서브쿼리에 사원 테이블 검색 조건으로 입사년도 조건을 FROM절의 서브쿼리와 동일하게 추가해야 원하는 결과를 추출할 수 있다."
"119","다음 중 아래 SQL에 대한 설명으로 가장 부적절한 것은?","[SQL]
SELECT B.사원번호, B.사원명, A.부서번호, A.부서명
, (SELECT COUNT(*)  FROM 부양가족 Y WHERE
Y.사원번호 = B.사원번호)  AS 부양가족수
FROM 부서 A, (SELECT *
FROM 사원
WHERE 입사년도 = '2014')  B
WHERE A.부서번호 = B.부서번호
AND EXISTS (SELECT 1 FROM 사원 X WHERE X.부서번호 =
A.부서번호);
","2","3","SELECT절에 사용된 서브쿼리는 스칼라 서브쿼리라고도하며, 이러한 형태의 서브쿼리는 JOIN 으로 동일한 결과를 추출할 수도 있다.
"
"119","다음 중 아래 SQL에 대한 설명으로 가장 부적절한 것은?","[SQL]
SELECT B.사원번호, B.사원명, A.부서번호, A.부서명
, (SELECT COUNT(*)  FROM 부양가족 Y WHERE
Y.사원번호 = B.사원번호)  AS 부양가족수
FROM 부서 A, (SELECT *
FROM 사원
WHERE 입사년도 = '2014')  B
WHERE A.부서번호 = B.부서번호
AND EXISTS (SELECT 1 FROM 사원 X WHERE X.부서번호 =
A.부서번호);
","2","4","위 SQL에는 다중 행 연관 서브쿼리, 단일 행 연관 서브쿼리, Inline View 가 사용되었다"
"139","다음 중 PL/SQL에 대한 설명으로 가장 부적절한 것은?","","2","1","Procedure 내부에 작성된 절차적 코드는 PL/SQL엔진이 처 리하고 일반적인 SQL 문장은 SQL실행기가 처리한다."
"139","다음 중 PL/SQL에 대한 설명으로 가장 부적절한 것은?","","2","2","PL/SQL로 작성된 Procedure, User Defined Fimction은 전체가 하나의 트랜젝션으로 처리되어야 한다"
"139","다음 중 PL/SQL에 대한 설명으로 가장 부적절한 것은?","","2","3","Procedure, User Defined Function, Trigger 객체를 PL/SQL로 작성할 수 있다."
"139","다음 중 PL/SQL에 대한 설명으로 가장 부적절한 것은?","","2","4","변수와 상수 등을 사용하여 일반 SQL 문장을 실행할 때 WHERE절의 조건 등으로 대입할 수 있다."
"140","아래는 임시부서(TMP_DEPT)  테이블로부터 부서(DEPT) 테이블에 데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기 전에 부서 테이블의 모든 데이터를 ROLLBACKOI 불가능 하도록 삭제 하려고 한다. 다음 중 (ㄱ)에 들어갈 내용으로 옳은 것은?","[PL/SQL]
 create or replace procedure insert_dept authid_current_user 
as
 begin
(ㄱ)
 INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME, LOC)
 SELECT DEPTNO, DNAME, LOC
 FROM TMP_DEPT；
commit；
end；","2","1","execute 'TRUNCATE TABLE DEPT’;"
"140","아래는 임시부서(TMP_DEPT)  테이블로부터 부서(DEPT) 테이블에 데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기 전에 부서 테이블의 모든 데이터를 ROLLBACKOI 불가능 하도록 삭제 하려고 한다. 다음 중 (ㄱ)에 들어갈 내용으로 옳은 것은?","[PL/SQL]
 create or replace procedure insert_dept authid_current_user 
as
 begin
(ㄱ)
 INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME, LOC)
 SELECT DEPTNO, DNAME, LOC
 FROM TMP_DEPT；
commit；
end；","2","2","execute immediate 'TRUNCATE TABLE DEPT';"
"140","아래는 임시부서(TMP_DEPT)  테이블로부터 부서(DEPT) 테이블에 데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기 전에 부서 테이블의 모든 데이터를 ROLLBACKOI 불가능 하도록 삭제 하려고 한다. 다음 중 (ㄱ)에 들어갈 내용으로 옳은 것은?","[PL/SQL]
 create or replace procedure insert_dept authid_current_user 
as
 begin
(ㄱ)
 INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME, LOC)
 SELECT DEPTNO, DNAME, LOC
 FROM TMP_DEPT；
commit；
end；","2","3","DELETE FROM DEPT;"
"140","아래는 임시부서(TMP_DEPT)  테이블로부터 부서(DEPT) 테이블에 데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기 전에 부서 테이블의 모든 데이터를 ROLLBACKOI 불가능 하도록 삭제 하려고 한다. 다음 중 (ㄱ)에 들어갈 내용으로 옳은 것은?","[PL/SQL]
 create or replace procedure insert_dept authid_current_user 
as
 begin
(ㄱ)
 INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME, LOC)
 SELECT DEPTNO, DNAME, LOC
 FROM TMP_DEPT；
commit；
end；","2","4","TRUNCATE TABLE DEPT;"
"145","자신의 속성이 없어도 다른 속성을 이용하여 결과를 도출할 수 있는 특징을 가진 속성의 이름은?","","2","1","관계 속성"
"145","자신의 속성이 없어도 다른 속성을 이용하여 결과를 도출할 수 있는 특징을 가진 속성의 이름은?","","2","2","파생 속성"
"145","자신의 속성이 없어도 다른 속성을 이용하여 결과를 도출할 수 있는 특징을 가진 속성의 이름은?","","2","3","기본 속성"
"145","자신의 속성이 없어도 다른 속성을 이용하여 결과를 도출할 수 있는 특징을 가진 속성의 이름은?","","2","4","설계 속성"
"151","다음 개념에 해당하는 관계는 무엇인가?","부모 엔터티로부터 속성을 받았지만, 자식 엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용한다.","3","1","외부 식별 관계"
"151","다음 개념에 해당하는 관계는 무엇인가?","부모 엔터티로부터 속성을 받았지만, 자식 엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용한다.","3","2","일반 속성 관계"
"151","다음 개념에 해당하는 관계는 무엇인가?","부모 엔터티로부터 속성을 받았지만, 자식 엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용한다.","3","3","비식별자 관계"
"151","다음 개념에 해당하는 관계는 무엇인가?","부모 엔터티로부터 속성을 받았지만, 자식 엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용한다.","3","4","식별자 관계"
"154","엔터티 - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오.","","3","1","엔터티 하나의 인스턴스는 다른 엔터티의 인스턴스 간 관계인 Pariring을 가진다."
"154","엔터티 - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오.","","3","2","한 개의 엔터티는 두 개 이상의 속성을 갖는다."
"154","엔터티 - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오.","","3","3","하나의 속성은 하나 이상의 속성값을 가진다."
"154","엔터티 - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오.","","3","4","한 개의 엔터티는 두 개 이상의 인스턴스 집합이어야 한다."
"156","다음 설명에 해당하는 모델링 관점은 무엇인가?","업무가 어떤 데이터와 관련이 있는지 또는 데이터 간의 관계는 무엇인지에 대해서 모델링 하는 관점","1","1","데이터 관점"
"156","다음 설명에 해당하는 모델링 관점은 무엇인가?","업무가 어떤 데이터와 관련이 있는지 또는 데이터 간의 관계는 무엇인지에 대해서 모델링 하는 관점","1","2","데이터와 데이터 간의 상관 관점"
"156","다음 설명에 해당하는 모델링 관점은 무엇인가?","업무가 어떤 데이터와 관련이 있는지 또는 데이터 간의 관계는 무엇인지에 대해서 모델링 하는 관점","1","3","데이터와 프로세스의 상관 관점"
"156","다음 설명에 해당하는 모델링 관점은 무엇인가?","업무가 어떤 데이터와 관련이 있는지 또는 데이터 간의 관계는 무엇인지에 대해서 모델링 하는 관점","1","4","프로세스 관점"
"162","다음 중 설계 단계에서 데이터 모델의 성능을 고려하는 절차와 방법에 포함되지 않는 것은?","","1","1","데이터 모델링을 할 때 분석 단계에서부터 반정규화를 수행한다."
"162","다음 중 설계 단계에서 데이터 모델의 성능을 고려하는 절차와 방법에 포함되지 않는 것은?","","1","2","데이터베이스에 발생되는 트랜잭션의 유형을 파악한다."
"162","다음 중 설계 단계에서 데이터 모델의 성능을 고려하는 절차와 방법에 포함되지 않는 것은?","","1","3","데이터베이스 용량 산정을 수행한다."
"162","다음 중 설계 단계에서 데이터 모델의 성능을 고려하는 절차와 방법에 포함되지 않는 것은?","","1","4","이력모델의 조정, 기본키/외래키 조정, 슈퍼타입/서브타입 조정 등을 수행한다."
"164","다음 중 분산 데이터베이스의 투명성에 속하지 않는 것은?","","1","1","병렬 투명성"
"164","다음 중 분산 데이터베이스의 투명성에 속하지 않는 것은?","","1","2","중복 투명성"
"164","다음 중 분산 데이터베이스의 투명성에 속하지 않는 것은?","","1","3","병행 투명성"
"164","다음 중 분산 데이터베이스의 투명성에 속하지 않는 것은?","","1","4","분할 투명성"
"168","발생 시점에 따른 엔터티 분류에 의한 중심 엔터티가 아닌 것은?","","2","1","계약"
"168","발생 시점에 따른 엔터티 분류에 의한 중심 엔터티가 아닌 것은?","","2","2","사원"
"168","발생 시점에 따른 엔터티 분류에 의한 중심 엔터티가 아닌 것은?","","2","3","주문"
"168","발생 시점에 따른 엔터티 분류에 의한 중심 엔터티가 아닌 것은?","","2","4","매출"
"172","다음 설명 중 옳은 것은 무엇인가?","","4","1","데이터베이스에는 단 한 개의 테이블만 존재할 수 있다."
"172","다음 설명 중 옳은 것은 무엇인가?","","4","2","아주 복잡한 자료도 테이블은 하나만 만드는 것이 바람직하다."
"172","다음 설명 중 옳은 것은 무엇인가?","","4","3","데이터베이스 내에 테이블이란 존재하지 않는다."
"172","다음 설명 중 옳은 것은 무엇인가?","","4","4","모든 자료는 실질적으로 테이블에 저장되며 테이블에 있는 자료들을 꺼내 볼 수 있다."
"211","다음 중 자신과 성별이 같은 부양가족을 가진 직원의 이름을 검색하는 질의를 SQL로 적절하게 표현한 것을 고르시오.","","2","1","SELECT E.이름
FROM 직원 AS E
WHERE NOT EXISTS (SELECT * FROM 부양가족 WHERE E.직원번호 = 직원번호 AND E.성별 = 성별);"
"211","다음 중 자신과 성별이 같은 부양가족을 가진 직원의 이름을 검색하는 질의를 SQL로 적절하게 표현한 것을 고르시오.","","2","2","SELECT E.이름
FROM 직원 AS E
WHERE EXISTS (SELECT * FROM 부양가족 WHERE E.직원번호 = 직원번호 AND E.성별 = 성별);"
"211","다음 중 자신과 성별이 같은 부양가족을 가진 직원의 이름을 검색하는 질의를 SQL로 적절하게 표현한 것을 고르시오.","","2","3","SELECT E.이름
FROM 직원 AS E
WHERE NOT EXISTS (SELECT * FROM 부양가족 WHERE E.직원번호 = 직원번호);"
"211","다음 중 자신과 성별이 같은 부양가족을 가진 직원의 이름을 검색하는 질의를 SQL로 적절하게 표현한 것을 고르시오.","","2","4","SELECT E.이름
FROM 직원 AS E
WHERE E.직원번호 LIKE (SELECT 직원번호 FROM 부양가족 WHERE E.성별 = 성별);"
"216","다음의 데이터베이스에서 '부양가족을 2명 이상 가진 사원의 사번(eno), 성명(ename), 부양가족 수를 검색'하는 질의를 SQL로 적절하게 표현한 것은?","employee(eno, ename, address, score, dno)
dependent(eno, ename, birthday, relation)","2","1","SELECT e.eno, e.ename, count(*)
FROM employee e, dependent d
WHERE e.eno = d.eno
GROUP BY e.eno, e.name
HAVING count(*) >= 3;"
"216","다음의 데이터베이스에서 '부양가족을 2명 이상 가진 사원의 사번(eno), 성명(ename), 부양가족 수를 검색'하는 질의를 SQL로 적절하게 표현한 것은?","employee(eno, ename, address, score, dno)
dependent(eno, ename, birthday, relation)","2","2","SELECT e.eno, e.ename, t.cnt
FROM employee e,
(SELECT eno, count(*) as cnt
FROM dependent GROUP BY
eno HAVING count(*) >= 2) t
WHERE e.eno = t.eno;"
"216","다음의 데이터베이스에서 '부양가족을 2명 이상 가진 사원의 사번(eno), 성명(ename), 부양가족 수를 검색'하는 질의를 SQL로 적절하게 표현한 것은?","employee(eno, ename, address, score, dno)
dependent(eno, ename, birthday, relation)","2","3","SELECT e.eno, e.ename, count(*)
FROM employee e, dependent d
WHERE EXISTS (SELECT * FROM dependent 
GROUP BY eno
HAVING count(*) >=2)
GROUP BY e.eno, e.ename;"
"216","다음의 데이터베이스에서 '부양가족을 2명 이상 가진 사원의 사번(eno), 성명(ename), 부양가족 수를 검색'하는 질의를 SQL로 적절하게 표현한 것은?","employee(eno, ename, address, score, dno)
dependent(eno, ename, birthday, relation)","2","4","SELECT eno, ename, count(*)
FROM employee e, dependent d
WHERE e.eno = d.eno and count(*) >= 2
GROUP BY d.eno;"
"220","그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.","","2","1","LAG"
"220","그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.","","2","2","RANK"
"220","그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.","","2","3","LAST_VALUE"
"220","그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.","","2","4","FIRST_VALUE"
"222","CONNECT BY에 대한 설명으로 맞지 않은 것은?","","4","1","SYS_CONNECT_BY_PATH는 하위 레벨의 칼럼까지 모두 표시한다."
"222","CONNECT BY에 대한 설명으로 맞지 않은 것은?","","4","2","CONNECT_BY_ROOT는 ROOT 노드의 정보를 표시한다."
"222","CONNECT BY에 대한 설명으로 맞지 않은 것은?","","4","3","CONNECT_BY_ISCYCLE는 ROOT까지의 경로에 존재하는 데이터를 의미한다."
"222","CONNECT BY에 대한 설명으로 맞지 않은 것은?","","4","4","CONNECT_BY_ISLEAF는 전개과정에서 LEAF 데이터이면 0, 아니면 1을 가진다."
"224","다음은 Order by에 대한 설명이다. 올바르지 않은 것은?","","1","1","날짜형 데이터 타입을 오름차순으로 정렬하면 날짜 값이 가장 늦은 날짜가 먼저 출력된다."
"224","다음은 Order by에 대한 설명이다. 올바르지 않은 것은?","","1","2","SQL Server에서 오름차순으로 정렬하면 NULL 값이 가장 먼저 나온다."
"224","다음은 Order by에 대한 설명이다. 올바르지 않은 것은?","","1","3","오름차순으로 숫자형 데이터 타입을 정렬하면 가장 작은 값부터 출력된다."
"224","다음은 Order by에 대한 설명이다. 올바르지 않은 것은?","","1","4","기본적으로 정렬순서는 오름차순으로 정렬되지만 DESC를 사용하면 내림차순으로 정렬한다."
"226","다음의 SQL문과 동일한 것을 고르시오.","Select NVL(Name,'없음') From Emp;","2","1","Select Case When Name IS NULL THEN '없음' ELSE '0' END AS USER_NAME
FROM Emp;"
"226","다음의 SQL문과 동일한 것을 고르시오.","Select NVL(Name,'없음') From Emp;","2","2","Select Case When Name IS NULL THEN '없음' ELSE NAME END AS USER_NAME
FROM Emp;"
"226","다음의 SQL문과 동일한 것을 고르시오.","Select NVL(Name,'없음') From Emp;","2","3","Select Case When Name IS NOT NULL THEN '0' ELSE NAME END AS USER_NAME
FROM Emp;"
"226","다음의 SQL문과 동일한 것을 고르시오.","Select NVL(Name,'없음') From Emp;","2","4","Select Case When Name IS NOT NULL THEN NAME ELSE '0' END AS USER_NAME
FROM Emp;"
"228","서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?","","3","1","Access Subquery"
"228","서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?","","3","2","Associative Subquery"
"228","서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?","","3","3","Scala Subquery"
"228","서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?","","3","4","Looping"
"276","다음 주어진 CUBE문과 동일한 것은?","GROUP BY CUBE(DEPTNO, JOB);","3","1","GROUP BY (DEPTNO, JOB, (DEPTNO, JOB), 0);"
"276","다음 주어진 CUBE문과 동일한 것은?","GROUP BY CUBE(DEPTNO, JOB);","3","2","GROUP BY DEPTNO UNION
GROUP BY JOB UNION GROUP
BY (DEPTNO, JOB)"
"276","다음 주어진 CUBE문과 동일한 것은?","GROUP BY CUBE(DEPTNO, JOB);","3","3","GROUP BY GROUPING
SETS(DEPTNO, JOB, (DEPTNO, JOB), ());"
"276","다음 주어진 CUBE문과 동일한 것은?","GROUP BY CUBE(DEPTNO, JOB);","3","4","GROUP BY ROLLUP(DEPTNO, JOB);"
"286","다음 중 DROP TABLE 테이블명 [CASCADE CONSTRAINT]에 대한 설명으로 옳은 것은?","","1","1","CASCADE CONSTRAINT 옵션은 해당 테이블에서 참조되는 제약조건도삭제를 수행한다. "
"286","다음 중 DROP TABLE 테이블명 [CASCADE CONSTRAINT]에 대한 설명으로 옳은 것은?","","1","2","SQL Server에서는 테이블을 먼저 삭제 한 뒤 참조하는 FOREIGN KEY 제약조건, 참조하는 테이블을 삭제한다."
"286","다음 중 DROP TABLE 테이블명 [CASCADE CONSTRAINT]에 대한 설명으로 옳은 것은?","","1","3","CASCADE는 ORACLE, SQL Server, MySQL, PostgreSQL 모두 지원한다."
"286","다음 중 DROP TABLE 테이블명 [CASCADE CONSTRAINT]에 대한 설명으로 옳은 것은?","","1","4","테이블의 구조만 삭제된다."
"328","PL/SQL에서 FETCH 이후에 수행해야 하는 것은?","","2","1","EXIT"
"328","PL/SQL에서 FETCH 이후에 수행해야 하는 것은?","","2","2","Cursor CLOSE"
"328","PL/SQL에서 FETCH 이후에 수행해야 하는 것은?","","2","3","Cursor EXPTION"
"328","PL/SQL에서 FETCH 이후에 수행해야 하는 것은?","","2","4","Cursor DEFINE"
"331","다음 중 HASH 조인의 순서로 올바른 것은?","가. 선행 테이블에서 조건에 만족하는 데이터에 대해서 필터링을 수행한다.
나. 선행 테이블의 조인 키를 해시 함수의 입력으로 넣고 해시 테이블을 생성한다.
다. 가와 나의 작업은 선행 테이블에서 조건을 만족하는 모든 행에 대해서 실행한다.
라. 후행 테이블에 조건이 있으면 데이터에 대해서 필터링한다.
마. 후행 테이블의 조인 키를 해시 함수의 입력에 넣어서 해시값을 생성하고 선행 테이블의 해시 값과 비교해서 검색한다.","4","1","가 -> 라 -> 나 -> 마 -> 다"
"331","다음 중 HASH 조인의 순서로 올바른 것은?","가. 선행 테이블에서 조건에 만족하는 데이터에 대해서 필터링을 수행한다.
나. 선행 테이블의 조인 키를 해시 함수의 입력으로 넣고 해시 테이블을 생성한다.
다. 가와 나의 작업은 선행 테이블에서 조건을 만족하는 모든 행에 대해서 실행한다.
라. 후행 테이블에 조건이 있으면 데이터에 대해서 필터링한다.
마. 후행 테이블의 조인 키를 해시 함수의 입력에 넣어서 해시값을 생성하고 선행 테이블의 해시 값과 비교해서 검색한다.","4","2","나 -> 가 -> 마 -> 라 -> 다"
"331","다음 중 HASH 조인의 순서로 올바른 것은?","가. 선행 테이블에서 조건에 만족하는 데이터에 대해서 필터링을 수행한다.
나. 선행 테이블의 조인 키를 해시 함수의 입력으로 넣고 해시 테이블을 생성한다.
다. 가와 나의 작업은 선행 테이블에서 조건을 만족하는 모든 행에 대해서 실행한다.
라. 후행 테이블에 조건이 있으면 데이터에 대해서 필터링한다.
마. 후행 테이블의 조인 키를 해시 함수의 입력에 넣어서 해시값을 생성하고 선행 테이블의 해시 값과 비교해서 검색한다.","4","3","가 -> 나 -> 라 -> 마 -> 다"
"331","다음 중 HASH 조인의 순서로 올바른 것은?","가. 선행 테이블에서 조건에 만족하는 데이터에 대해서 필터링을 수행한다.
나. 선행 테이블의 조인 키를 해시 함수의 입력으로 넣고 해시 테이블을 생성한다.
다. 가와 나의 작업은 선행 테이블에서 조건을 만족하는 모든 행에 대해서 실행한다.
라. 후행 테이블에 조건이 있으면 데이터에 대해서 필터링한다.
마. 후행 테이블의 조인 키를 해시 함수의 입력에 넣어서 해시값을 생성하고 선행 테이블의 해시 값과 비교해서 검색한다.","4","4","가 -> 나 -> 다 -> 라 -> 마"
"339","다음 중 데이터베이스 관리 언어에 대한 설명으로 올바르지 않은 것은?","","1","1","DML은 비절차형 언어로 데이터를 조작할 수 있다."
"339","다음 중 데이터베이스 관리 언어에 대한 설명으로 올바르지 않은 것은?","","1","2","COMMIT과 ROLLBACK, SAVEPOINT는 TCL 명령어이다."
"339","다음 중 데이터베이스 관리 언어에 대한 설명으로 올바르지 않은 것은?","","1","3","DML은 질의를 실행하여 데이터를 조작할 수 있으며 INSERT, UPDATE, SELECT, DELETE구가 있다."
"339","다음 중 데이터베이스 관리 언어에 대한 설명으로 올바르지 않은 것은?","","1","4","DDL은 테이블, 뷰, 인덱스 등을 생성하거나 변경하는 것으로 CREATE, ALTER, DROP, RENAME 등이 있다."
"342","다음의 계층형 질의에서 리프 노드 여부를 출력하려고 한다. (    )에 올바른 것은?","SELECT LEVEL, LPAD(' ',4 + (LEVEL -1) )|| EMPNO, MGR, (    ) AS ISLEAF
FROM Mytest
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;","2","1","CONNECT_BY_LEAF"
"342","다음의 계층형 질의에서 리프 노드 여부를 출력하려고 한다. (    )에 올바른 것은?","SELECT LEVEL, LPAD(' ',4 + (LEVEL -1) )|| EMPNO, MGR, (    ) AS ISLEAF
FROM Mytest
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;","2","2","SYS_CONNECT_BY_PATH"
"342","다음의 계층형 질의에서 리프 노드 여부를 출력하려고 한다. (    )에 올바른 것은?","SELECT LEVEL, LPAD(' ',4 + (LEVEL -1) )|| EMPNO, MGR, (    ) AS ISLEAF
FROM Mytest
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;","2","3","CONNECT_BY_ISCYCLE"
"342","다음의 계층형 질의에서 리프 노드 여부를 출력하려고 한다. (    )에 올바른 것은?","SELECT LEVEL, LPAD(' ',4 + (LEVEL -1) )|| EMPNO, MGR, (    ) AS ISLEAF
FROM Mytest
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;","2","4","CONNECT_BY_ISLEAF"
"346","다음 중 데이터베이스 관리 언어를 올바르게 매핑한 것은?","","3","1","DML - ALTER"
"346","다음 중 데이터베이스 관리 언어를 올바르게 매핑한 것은?","","3","2","DCL - DROP"
"346","다음 중 데이터베이스 관리 언어를 올바르게 매핑한 것은?","","3","3","TCL - COMMIT"
"346","다음 중 데이터베이스 관리 언어를 올바르게 매핑한 것은?","","3","4","DML - RENAME"
"351","다음은 Oracle 데이터베이스의 계층형 질의에 대한 것이다. 올바르지 않은 것은?","","1","1","루트 노드의 LEVEL 값은 1이 아니다."
"351","다음은 Oracle 데이터베이스의 계층형 질의에 대한 것이다. 올바르지 않은 것은?","","1","2","순방향 전개란 부모 노드로부터 자식 노드로 전개하는 것이고 역방향 전개는 자식 노드에서 부모 노드로 전개하는 것이다."
"351","다음은 Oracle 데이터베이스의 계층형 질의에 대한 것이다. 올바르지 않은 것은?","","1","3","ORDER SIBILINGS BY구는 형제 노드 사이에 정렬을 수행한다."
"351","다음은 Oracle 데이터베이스의 계층형 질의에 대한 것이다. 올바르지 않은 것은?","","1","4","START WITH절은 계층 구조의 시작점을 지정하는 구문이다."
"364","다음 중 주식별자의 특징으로 올바르지 않은 것은?","","1","1","존재성 : 주식별자로 지정되면 데이터값이 존재하지 않을 수 있다."
"364","다음 중 주식별자의 특징으로 올바르지 않은 것은?","","1","2","불변성 : 식별자의 값은 변하지 않아야 한다."
"364","다음 중 주식별자의 특징으로 올바르지 않은 것은?","","1","3","최소성 : 속성의 수는 유일성을 만족해야 하고 최소의 수가 되어야 한다."
"364","다음 중 주식별자의 특징으로 올바르지 않은 것은?","","1","4","유일성 : 엔터티 내에서 모든 인스턴스들은 유일해야 한다."
"417","다음은 WINDOW FUNCTION에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?","","2","1","SUM(급여) OVER(PARTITION BY JOB ORDER BY JOB RANGE BETWEEN UNBOUNDED
PRECEDING AND CURRENT ROW) SAL"
"417","다음은 WINDOW FUNCTION에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?","","2","2","SUM(급여) OVER(PARTITION BY JOB ORDER BY EMPNO RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED PRECEDING) SAL"
"417","다음은 WINDOW FUNCTION에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?","","2","3","SUM(급여) OVER(PARTITION BY JOB ORDER BY EMPNO RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SAL"
"417","다음은 WINDOW FUNCTION에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?","","2","4","SUM(급여)  OVER()"
"419","다음 중 서브쿼리를 올바르게 구분한 것은?","SELECT (A)
FROM (B) a
WHERE a.col = (C)","2","1","A : 인라인 뷰
B : 스칼라 서브쿼리
C : 서브쿼리"
"419","다음 중 서브쿼리를 올바르게 구분한 것은?","SELECT (A)
FROM (B) a
WHERE a.col = (C)","2","2","A : 스칼라 서브쿼리
B : 인라인 뷰
C : 서브쿼리"
"419","다음 중 서브쿼리를 올바르게 구분한 것은?","SELECT (A)
FROM (B) a
WHERE a.col = (C)","2","3","A : 서브쿼리
B : 스칼라 서브쿼리
C : 인라인 뷰"
"419","다음 중 서브쿼리를 올바르게 구분한 것은?","SELECT (A)
FROM (B) a
WHERE a.col = (C)","2","4","A : 스칼라 서브쿼리
B : 서브쿼리
C : 인라인 뷰"
"449","식별자 중에서 비즈니스 프로세스에 의하여 만들어지는 식별자로 대체 여부로 분리되는 식별자는 무엇인가?","","4","1","인조 식별자"
"449","식별자 중에서 비즈니스 프로세스에 의하여 만들어지는 식별자로 대체 여부로 분리되는 식별자는 무엇인가?","","4","2","내부 식별자"
"449","식별자 중에서 비즈니스 프로세스에 의하여 만들어지는 식별자로 대체 여부로 분리되는 식별자는 무엇인가?","","4","3","단일 식별자"
"449","식별자 중에서 비즈니스 프로세스에 의하여 만들어지는 식별자로 대체 여부로 분리되는 식별자는 무엇인가?","","4","4","본질 식별자"
"456","아래의 SQL문을 실행했을 때 조회되는 행 수가 가장 많이 나오는 SQL문과 가장 적게 나오는 SQL문은?","insert into a1 values(1,4);
insert into a1 values(2,5);
insert into a1 values(3,6);
insert into a1 values(4,7);

insert into a2 values(1,4);
insert into a2 values(2,5);
insert into a2 values(null,6);
insert into a2 values(null,7);

(1)select * from a1,a2
     where a1.col1=a2.col1;

(2)select * from a1 left outer join a2
     on a1.col1=a2.col1;

(3)select * from a1 right outer join a2
     on a1.col1=a2.col1;

(4)select * from a1 full outer join a2
     on a1.col1=a2.col1;","1","1","(4), (1)"
"456","아래의 SQL문을 실행했을 때 조회되는 행 수가 가장 많이 나오는 SQL문과 가장 적게 나오는 SQL문은?","insert into a1 values(1,4);
insert into a1 values(2,5);
insert into a1 values(3,6);
insert into a1 values(4,7);

insert into a2 values(1,4);
insert into a2 values(2,5);
insert into a2 values(null,6);
insert into a2 values(null,7);

(1)select * from a1,a2
     where a1.col1=a2.col1;

(2)select * from a1 left outer join a2
     on a1.col1=a2.col1;

(3)select * from a1 right outer join a2
     on a1.col1=a2.col1;

(4)select * from a1 full outer join a2
     on a1.col1=a2.col1;","1","2","(3), (4)"
"456","아래의 SQL문을 실행했을 때 조회되는 행 수가 가장 많이 나오는 SQL문과 가장 적게 나오는 SQL문은?","insert into a1 values(1,4);
insert into a1 values(2,5);
insert into a1 values(3,6);
insert into a1 values(4,7);

insert into a2 values(1,4);
insert into a2 values(2,5);
insert into a2 values(null,6);
insert into a2 values(null,7);

(1)select * from a1,a2
     where a1.col1=a2.col1;

(2)select * from a1 left outer join a2
     on a1.col1=a2.col1;

(3)select * from a1 right outer join a2
     on a1.col1=a2.col1;

(4)select * from a1 full outer join a2
     on a1.col1=a2.col1;","1","3","(2), (3)"
"456","아래의 SQL문을 실행했을 때 조회되는 행 수가 가장 많이 나오는 SQL문과 가장 적게 나오는 SQL문은?","insert into a1 values(1,4);
insert into a1 values(2,5);
insert into a1 values(3,6);
insert into a1 values(4,7);

insert into a2 values(1,4);
insert into a2 values(2,5);
insert into a2 values(null,6);
insert into a2 values(null,7);

(1)select * from a1,a2
     where a1.col1=a2.col1;

(2)select * from a1 left outer join a2
     on a1.col1=a2.col1;

(3)select * from a1 right outer join a2
     on a1.col1=a2.col1;

(4)select * from a1 full outer join a2
     on a1.col1=a2.col1;","1","4","(1), (2)"
"463","다음 SQL문의 (     )에 들어가는 것으로 올바르지 않은 것은?","SELECT (         ), Count(Empno)
FROM EMP
WHERE EMPNO > 0
GROUP BY DEPTNO, SAL;","4","1","Deptno 와 Sal"
"463","다음 SQL문의 (     )에 들어가는 것으로 올바르지 않은 것은?","SELECT (         ), Count(Empno)
FROM EMP
WHERE EMPNO > 0
GROUP BY DEPTNO, SAL;","4","2","Sal"
"463","다음 SQL문의 (     )에 들어가는 것으로 올바르지 않은 것은?","SELECT (         ), Count(Empno)
FROM EMP
WHERE EMPNO > 0
GROUP BY DEPTNO, SAL;","4","3","Deptno "
"463","다음 SQL문의 (     )에 들어가는 것으로 올바르지 않은 것은?","SELECT (         ), Count(Empno)
FROM EMP
WHERE EMPNO > 0
GROUP BY DEPTNO, SAL;","4","4","Empno"
"472","오라클 데이터베이스에서 내일 날짜를 조회하는 방법으로 올바른 것은?","","3","1","SELECT TO_CHAR(SYSDATE-1, 'YYYYMMDD') FROM DUAL;"
"472","오라클 데이터베이스에서 내일 날짜를 조회하는 방법으로 올바른 것은?","","3","2","SELECT TO_DATE(SYSDATE-1, 'YYYYMMDD') FROM DUAL;"
"472","오라클 데이터베이스에서 내일 날짜를 조회하는 방법으로 올바른 것은?","","3","3","SELECT TO_CHAR(SYSDATE+1, 'YYYYMMDD') FROM DUAL;"
"472","오라클 데이터베이스에서 내일 날짜를 조회하는 방법으로 올바른 것은?","","3","4","SELECT TO_DATE(SYSDATE+1, 'YYYYMMDD') FROM DUAL;"
"515","아래의 SQL문에 대해서 실행 순서를 올바르게 나열한 것은?","SELECT DEPTNO, COUNT(EMPNO)
FROM SCOTT.EMP
WHERE SAL >= 400
GROUP BY DEPTNO
HAVING COUNT(EMPNO) >= 3
ORDER BY DEPTNO;","1","1","FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY"
"515","아래의 SQL문에 대해서 실행 순서를 올바르게 나열한 것은?","SELECT DEPTNO, COUNT(EMPNO)
FROM SCOTT.EMP
WHERE SAL >= 400
GROUP BY DEPTNO
HAVING COUNT(EMPNO) >= 3
ORDER BY DEPTNO;","1","2","FROM -> WHERE -> GROUP BY -> SELECT -> HAVING -> ORDER BY"
"515","아래의 SQL문에 대해서 실행 순서를 올바르게 나열한 것은?","SELECT DEPTNO, COUNT(EMPNO)
FROM SCOTT.EMP
WHERE SAL >= 400
GROUP BY DEPTNO
HAVING COUNT(EMPNO) >= 3
ORDER BY DEPTNO;","1","3","FROM -> WHERE -> HAVING -> GROUP BY -> ORDER BY -> SELECT"
"515","아래의 SQL문에 대해서 실행 순서를 올바르게 나열한 것은?","SELECT DEPTNO, COUNT(EMPNO)
FROM SCOTT.EMP
WHERE SAL >= 400
GROUP BY DEPTNO
HAVING COUNT(EMPNO) >= 3
ORDER BY DEPTNO;","1","4","FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> SELECT"
"522","다음에서 설명하는 것은 ER 모델 중 어떤 항목에 대한 설명인가?","1) 모든 릴레이션은 원자값을 가져야 한다.
2) 어떤 릴레이션에서 속성 값이 가질 수 있는 값의 범위를 의미한다.
3) 실제 속성값이 올바르게 되었는지 확인한다
4) 속성명과 반드시 동일할필요는 없다. ","3","1","차수"
"522","다음에서 설명하는 것은 ER 모델 중 어떤 항목에 대한 설명인가?","1) 모든 릴레이션은 원자값을 가져야 한다.
2) 어떤 릴레이션에서 속성 값이 가질 수 있는 값의 범위를 의미한다.
3) 실제 속성값이 올바르게 되었는지 확인한다
4) 속성명과 반드시 동일할필요는 없다. ","3","2","인스턴스"
"522","다음에서 설명하는 것은 ER 모델 중 어떤 항목에 대한 설명인가?","1) 모든 릴레이션은 원자값을 가져야 한다.
2) 어떤 릴레이션에서 속성 값이 가질 수 있는 값의 범위를 의미한다.
3) 실제 속성값이 올바르게 되었는지 확인한다
4) 속성명과 반드시 동일할필요는 없다. ","3","3","도메인"
"522","다음에서 설명하는 것은 ER 모델 중 어떤 항목에 대한 설명인가?","1) 모든 릴레이션은 원자값을 가져야 한다.
2) 어떤 릴레이션에서 속성 값이 가질 수 있는 값의 범위를 의미한다.
3) 실제 속성값이 올바르게 되었는지 확인한다
4) 속성명과 반드시 동일할필요는 없다. ","3","4","카디날리티"
"540","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","1","1","PL/SQL문의 기본 구조로 DECLARE, BEGIN ~ END, EXCEPTION은 필수적으로 써야 한다."
"540","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","1","2","Procedure 내부에 작성된 절차적 코드는 PL/SQL엔진이 처리하고 일반적인 SQL 문장은 SQL실행기가 처리한다. "
"540","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","1","3","Procedure, User Defined Function, Trigger 객체를 PL/SQL로 작성할 수 있다."
"540","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","1","4","변수와 상수 등을 사용하여 일반 SQL문장을 실행할 때 WHERE절의 조건 등으로 대입할 수 있다."
"543","다음 중 아래에서 JOIN에 대한 설명으로 올바르지 않은 것은?","가) 마스터 테이블과 슬레이브 테이블 간의 조인은 일반적으로 기본키와 외래키 사이에서 발생한다.
나) EQUI JOIN은 두 개의 테이블 간에 칼럼 값이 일치하는 것을 조회한다.
다) EQUI JOIN은 "">"", ""<"", "">="", ""<=""를 사용한다.
라) EQUI JOIN은 두 개의 테이블에서 교집합을 찾는다.","2","1","라"
"543","다음 중 아래에서 JOIN에 대한 설명으로 올바르지 않은 것은?","가) 마스터 테이블과 슬레이브 테이블 간의 조인은 일반적으로 기본키와 외래키 사이에서 발생한다.
나) EQUI JOIN은 두 개의 테이블 간에 칼럼 값이 일치하는 것을 조회한다.
다) EQUI JOIN은 "">"", ""<"", "">="", ""<=""를 사용한다.
라) EQUI JOIN은 두 개의 테이블에서 교집합을 찾는다.","2","2","다"
"543","다음 중 아래에서 JOIN에 대한 설명으로 올바르지 않은 것은?","가) 마스터 테이블과 슬레이브 테이블 간의 조인은 일반적으로 기본키와 외래키 사이에서 발생한다.
나) EQUI JOIN은 두 개의 테이블 간에 칼럼 값이 일치하는 것을 조회한다.
다) EQUI JOIN은 "">"", ""<"", "">="", ""<=""를 사용한다.
라) EQUI JOIN은 두 개의 테이블에서 교집합을 찾는다.","2","3","나"
"543","다음 중 아래에서 JOIN에 대한 설명으로 올바르지 않은 것은?","가) 마스터 테이블과 슬레이브 테이블 간의 조인은 일반적으로 기본키와 외래키 사이에서 발생한다.
나) EQUI JOIN은 두 개의 테이블 간에 칼럼 값이 일치하는 것을 조회한다.
다) EQUI JOIN은 "">"", ""<"", "">="", ""<=""를 사용한다.
라) EQUI JOIN은 두 개의 테이블에서 교집합을 찾는다.","2","4","가"
"544","다음 중 아래의 SQL에 대한 설명으로 가장 올바른 것은?","SELECT 분류코드
AVG(상품가격) AS 상품가격,
COUNT(*) OVER(ORDER BY AVG(상품가격)
RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS CNT
FROM 상품
GROUP BY 분류코드;","2","1","CNT 칼럼은 상품전체의 평균상품가격을 서로 비교하여 -10000 ~ +10000사이에 존재하는 상품의 개수를 구한 것이다."
"544","다음 중 아래의 SQL에 대한 설명으로 가장 올바른 것은?","SELECT 분류코드
AVG(상품가격) AS 상품가격,
COUNT(*) OVER(ORDER BY AVG(상품가격)
RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS CNT
FROM 상품
GROUP BY 분류코드;","2","2","CNT 칼럼은 분류코드별 평균상품가격을 서로 비교하여 -10000 ~ 10000 사이에 존재하는 분류코드의 개수를 구한 것이다."
"544","다음 중 아래의 SQL에 대한 설명으로 가장 올바른 것은?","SELECT 분류코드
AVG(상품가격) AS 상품가격,
COUNT(*) OVER(ORDER BY AVG(상품가격)
RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS CNT
FROM 상품
GROUP BY 분류코드;","2","3","WINDOW FUNCTION의 ORDER BY 절로 인하여 문법오류이다. "
"544","다음 중 아래의 SQL에 대한 설명으로 가장 올바른 것은?","SELECT 분류코드
AVG(상품가격) AS 상품가격,
COUNT(*) OVER(ORDER BY AVG(상품가격)
RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS CNT
FROM 상품
GROUP BY 분류코드;","2","4","WINDOW FUNCTION을 GROUP BY(분류코드)절과 함께 사용하였으므로 위의 SQL은 오류가 발생한다."
"564","View 사용시 장점이 아닌 것을 고르시오.","","1","1","논리적 데이터에 독립성을 제공하지 않는다."
"564","View 사용시 장점이 아닌 것을 고르시오.","","1","2","동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해 준다."
"564","View 사용시 장점이 아닌 것을 고르시오.","","1","3","사용자의 데이터관리를 간단하게 해준다."
"564","View 사용시 장점이 아닌 것을 고르시오.","","1","4","접근 제어를 통한 자동 보안이 제공된다."
"594","다음 중 GROUP BY절 대한 설명 중 틀린 것은?","","1","1","GROUP BY절에 나열되는 컬럼 순서에 따라 SELECT절의 그룹함수의 연산 결과가 달라질 수 있다."
"594","다음 중 GROUP BY절 대한 설명 중 틀린 것은?","","1","2","GROUP BY절에 명시되지 않은 컬럼을 그룹함수 없이 SELECT절에 사용할 수 없다."
"594","다음 중 GROUP BY절 대한 설명 중 틀린 것은?","","1","3","GROUP BY절에는 SUM, COUNT 함수를 사용할 수 없다."
"594","다음 중 GROUP BY절 대한 설명 중 틀린 것은?","","1","4","GROUP BY절에는 컬럼 별칭을 사용할 수 없다."
"611","아래의 계층형 SQL 에서 리프 데이터이면 1, 그렇지 않으면 0 을 출력하고 싶을 때 사용하는 키워드로 알맞은 것은? 
","SELECT LEVEL, 
 EMPNO, 
 MGR, 
 _____________ AS 리프노드여부 
 FROM SCOTT.EMP 
 START WITH MGR IS NULL 
CONNECT BY PRIOR EMPNO = MGR; 
","4","1","CONNECT_BY_ROOT"
"611","아래의 계층형 SQL 에서 리프 데이터이면 1, 그렇지 않으면 0 을 출력하고 싶을 때 사용하는 키워드로 알맞은 것은? 
","SELECT LEVEL, 
 EMPNO, 
 MGR, 
 _____________ AS 리프노드여부 
 FROM SCOTT.EMP 
 START WITH MGR IS NULL 
CONNECT BY PRIOR EMPNO = MGR; 
","4","2","SYS_CONNECT_BY_PATH"
"611","아래의 계층형 SQL 에서 리프 데이터이면 1, 그렇지 않으면 0 을 출력하고 싶을 때 사용하는 키워드로 알맞은 것은? 
","SELECT LEVEL, 
 EMPNO, 
 MGR, 
 _____________ AS 리프노드여부 
 FROM SCOTT.EMP 
 START WITH MGR IS NULL 
CONNECT BY PRIOR EMPNO = MGR; 
","4","3","CONNECT_BY_ISCYCLE"
"611","아래의 계층형 SQL 에서 리프 데이터이면 1, 그렇지 않으면 0 을 출력하고 싶을 때 사용하는 키워드로 알맞은 것은? 
","SELECT LEVEL, 
 EMPNO, 
 MGR, 
 _____________ AS 리프노드여부 
 FROM SCOTT.EMP 
 START WITH MGR IS NULL 
CONNECT BY PRIOR EMPNO = MGR; 
","4","4","CONNECT_BY_ISLEAF"
"613","다음 SQL 구문 결과와 같은 결과를 갖는 SQL은? ","SELECT COUNT(DECODE(DEPTNO,10,1)) AS ""10"", 
COUNT(DECODE(DEPTNO,20,1)) AS ""20"", 
COUNT(DECODE(DEPTNO,30,1)) AS ""30"" 
 FROM EMP; 
","4","1"," SELECT * FROM EMP 
 UNPIVOT (COUNT(*) FOR DEPTNO IN (10,20,30));"
"613","다음 SQL 구문 결과와 같은 결과를 갖는 SQL은? ","SELECT COUNT(DECODE(DEPTNO,10,1)) AS ""10"", 
COUNT(DECODE(DEPTNO,20,1)) AS ""20"", 
COUNT(DECODE(DEPTNO,30,1)) AS ""30"" 
 FROM EMP; 
","4","2","SELECT * FROM EMP 
 UNPIVOT (COUNT(DEPTNO) FOR DEPTNO IN (10,20,30));"
"613","다음 SQL 구문 결과와 같은 결과를 갖는 SQL은? ","SELECT COUNT(DECODE(DEPTNO,10,1)) AS ""10"", 
COUNT(DECODE(DEPTNO,20,1)) AS ""20"", 
COUNT(DECODE(DEPTNO,30,1)) AS ""30"" 
 FROM EMP; 
","4","3","SELECT * FROM (SELECT EMPNO, JOB, DEPTNO FROM EMP) 
    PIVOT (COUNT(DEPTNO) FOR EMPNO IN (10,20,30)); "
"613","다음 SQL 구문 결과와 같은 결과를 갖는 SQL은? ","SELECT COUNT(DECODE(DEPTNO,10,1)) AS ""10"", 
COUNT(DECODE(DEPTNO,20,1)) AS ""20"", 
COUNT(DECODE(DEPTNO,30,1)) AS ""30"" 
 FROM EMP; 
","4","4","SELECT * FROM (SELECT EMPNO, DEPTNO FROM EMP) 
    PIVOT (COUNT(EMPNO) FOR DEPTNO IN (10,20,30));"
"618","비교연산자의 어느 한쪽이 VARCHAR 유형 타입인 경우 문자 유형 비교에 대한 설명 중 가장 알맞지 않은 것은?","","1","1","길이가 다르다면 작은 쪽에 SPACE 를 추가하여 길이를 같게 한 후에 비교한다"
"618","비교연산자의 어느 한쪽이 VARCHAR 유형 타입인 경우 문자 유형 비교에 대한 설명 중 가장 알맞지 않은 것은?","","1","2","길이가 같고 다른 것이 없다면 같다고 판단한다"
"618","비교연산자의 어느 한쪽이 VARCHAR 유형 타입인 경우 문자 유형 비교에 대한 설명 중 가장 알맞지 않은 것은?","","1","3","길이가 다르다면 짧은 것이 끝날 때까지만 비교한 후에 길이가 긴 것이 크다고 판단한다 "
"618","비교연산자의 어느 한쪽이 VARCHAR 유형 타입인 경우 문자 유형 비교에 대한 설명 중 가장 알맞지 않은 것은?","","1","4","서로 다른 문자가 나올 때까지 비교한다 "
"643","다음 중 틀린 설명은? (단, DBMS는 ORACLE)","","1","1","ORDER BY COMM DESC NULLS LAST 시 NULL이 맨 앞에 배치된다."
"643","다음 중 틀린 설명은? (단, DBMS는 ORACLE)","","1","2","ORDER BY COMM DESC 시 NULL이 맨 앞에 배치된다."
"643","다음 중 틀린 설명은? (단, DBMS는 ORACLE)","","1","3","ORDER BY COMM NULLS FIRST 시 NULL이 맨 앞에 배치된다. "
"643","다음 중 틀린 설명은? (단, DBMS는 ORACLE)","","1","4","ORDER BY COMM 시 NULL이 마지막에 배치된다."
"647","다음 표준조인에 대한 설명 중 가장 적절하지 않은 것은? ","","2","1","INNER JOIN은 줄여서 JOIN으로 전달할 수 있다."
"647","다음 표준조인에 대한 설명 중 가장 적절하지 않은 것은? ","","2","2","NATURAL JOIN시 같은 이름의 컬럼이 여러 개인 경우 USING절을 사용하여 원하는 컬럼을 선택할 수 있다."
"647","다음 표준조인에 대한 설명 중 가장 적절하지 않은 것은? ","","2","3","FULL OUTER JOIN은 LEFT OUTER JOIN 결과와 RIGHT OUTER JOIN 결과를 UNION한 것과 같다."
"647","다음 표준조인에 대한 설명 중 가장 적절하지 않은 것은? ","","2","4","CROSS JOIN인 두 테이블의 조인 컬럼의 값과 상관없이 항상 모든 경우의 수를 출력한다."
"672","엔터티  - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오. ","","2","1","하나의 엔터티의 인스턴스는 다른 엔터티의 인스턴스간의 관계인 Paring을 가진다."
"672","엔터티  - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오. ","","2","2","하나의 속성은 하나 이상의 속성값을 가진다."
"672","엔터티  - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오. ","","2","3","한 개의 엔터티는 두 개 이상의 속성을 갖는다."
"672","엔터티  - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오. ","","2","4","한 개의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다."
"675","다음 주식별자에 대한 설명 중 가장 적절하지 않은 것은?","","3","1","지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다."
"675","다음 주식별자에 대한 설명 중 가장 적절하지 않은 것은?","","3","2","주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다."
"675","다음 주식별자에 대한 설명 중 가장 적절하지 않은 것은?","","3","3","주식별자로 지정되더라도 속성 값으로 NULL이 들어갈 수 있다."
"675","다음 주식별자에 대한 설명 중 가장 적절하지 않은 것은?","","3","4","주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다."
"680","다음이 설명하는 식별자로 가장 적절한 것은? ","다른 엔터티 참조 없이 엔터티 내부에서 스스로 생성되는 식별자","1","1","내부식별자"
"680","다음이 설명하는 식별자로 가장 적절한 것은? ","다른 엔터티 참조 없이 엔터티 내부에서 스스로 생성되는 식별자","1","2","본질식별자"
"680","다음이 설명하는 식별자로 가장 적절한 것은? ","다른 엔터티 참조 없이 엔터티 내부에서 스스로 생성되는 식별자","1","3","인조식별자"
"680","다음이 설명하는 식별자로 가장 적절한 것은? ","다른 엔터티 참조 없이 엔터티 내부에서 스스로 생성되는 식별자","1","4","보조식별자"
"681","다음 중 DBMS 특징이 아닌 것은?","","4","1","인증된 사용자만이 참조 할 수 있는 보안기능이 제공된다."
"681","다음 중 DBMS 특징이 아닌 것은?","","4","2","실시간 접근, 자료의 계속적인 변화의 적용에 유리하다."
"681","다음 중 DBMS 특징이 아닌 것은?","","4","3","데이터 무결성을 유지 할 수 있다."
"681","다음 중 DBMS 특징이 아닌 것은?","","4","4","DBMS에 저장된 데이터는 다른 사용자에게 공유될 수 없다."
"692","다음 SQL 문장 중 COL1 값이 널(NULL)이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","1","SELECT * FROM TAB1 WHERE COL1 NOT NULL;"
"692","다음 SQL 문장 중 COL1 값이 널(NULL)이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","2","SELECT * FROM TAB1 WHERE COL1 != NULL;"
"692","다음 SQL 문장 중 COL1 값이 널(NULL)이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","3","SELECT * FROM TAB1 WHERE COL1 <> NULL;"
"692","다음 SQL 문장 중 COL1 값이 널(NULL)이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","4","SELECT * FROM TAB1 WHERE COL1 IS NOT NULL;"
"697","다음 FROM 절의 JOIN 형태에 대한 설명 중 올바르지 못한 것은? ","","2","1","RIGHT OUTER JOIN, LEFT OUTER JOIN에서 OUTER는 생략 가능하다."
"697","다음 FROM 절의 JOIN 형태에 대한 설명 중 올바르지 못한 것은? ","","2","2","RIGHT OUTER JOIN 결과와 LEFT OUTER JOIN 결과는 항상 다르다."
"697","다음 FROM 절의 JOIN 형태에 대한 설명 중 올바르지 못한 것은? ","","2","3","INNER JOIN 사용 시, USING 조건절이나 ON 조건절을 반드시 사용해야 한다."
"697","다음 FROM 절의 JOIN 형태에 대한 설명 중 올바르지 못한 것은? ","","2","4","INNER JOIN은 WHERE 절에서 사용하던 JOIN 조건을 FROM 절에서 정의하겠다는 표시이다."
"706","순위관련 WINDOW 함수에 대한 설명 중 가장 적절하지 않은 것은? ","","2","1","RANK 함수가 동일한 값에 대해서는 동일한 순위를 부여하는데 반해, ROW_NUMBER 함수는 고유한 순위를 부여한다."
"706","순위관련 WINDOW 함수에 대한 설명 중 가장 적절하지 않은 것은? ","","2","2","PERCENT_RANK 함수는 각 값의 누적된 순위를 부여할 수 있다."
"706","순위관련 WINDOW 함수에 대한 설명 중 가장 적절하지 않은 것은? ","","2","3","DENSE_RANK 함수는 RANK 함수처럼 동일한 값에 대해 동일한 순위를 부여하나, 동순위가 여럿 존재하더라도 다음 순위가 이어진다."
"706","순위관련 WINDOW 함수에 대한 설명 중 가장 적절하지 않은 것은? ","","2","4","RANK함수는 동일한 값에 대해서는 동일한 순위를 부여한다."
"708","다음 중 Top N Query에 대한 설명 중 틀린 것은?","","1","1","SQL-Server의 TOP(N) 쿼리를 사용하면 정렬 순서대로 상위 N개 데이터만 출력 가능하다."
"708","다음 중 Top N Query에 대한 설명 중 틀린 것은?","","1","2","FETCH 절을 사용하면 단일 Query로도 정렬 순서대로의 상위 N개에 대한 값을 추출할 수 있다."
"708","다음 중 Top N Query에 대한 설명 중 틀린 것은?","","1","3","ROWNUM을 사용한 방식은 ROWNUM 할당 전에 먼저 순서대로 데이터를 정렬한 뒤 ROWNUM을 부여 후 추출하는 것이 좋다."
"708","다음 중 Top N Query에 대한 설명 중 틀린 것은?","","1","4","윈도우 함수를 사용하여 상위 N개에 대한 값을 추출할 수 있으나 단일 Query로 표현 불가하다."
"713","DML에 대한 설명으로 가장 적절한 것은?","","2","1","UPDATE 사용 시 동시에 여러 컬럼 수정은 불가능하다."
"713","DML에 대한 설명으로 가장 적절한 것은?","","2","2","DML은 반드시 COMMIT 또는 ROLLBACK을 입력하여 TRANSACTION을 종료해야 한다."
"713","DML에 대한 설명으로 가장 적절한 것은?","","2","3","원하는 데이터 DELETE 시 WHERE 절은 반드시 붙이지 않아도 된다."
"713","DML에 대한 설명으로 가장 적절한 것은?","","2","4","DELETE 사용 시 FROM 문구는 생략이 불가능하다."
"722","엔터티 분류 중 유형과 무형에 따른 분류가 아닌 것은?","","1","1","행위엔터티"
"722","엔터티 분류 중 유형과 무형에 따른 분류가 아닌 것은?","","1","2","사건엔터티"
"722","엔터티 분류 중 유형과 무형에 따른 분류가 아닌 것은?","","1","3","개념엔터티"
"722","엔터티 분류 중 유형과 무형에 따른 분류가 아닌 것은?","","1","4","유형엔터티"
"745","다음의 오라클 표준을 ANSI로 가장 잘 표현한 것은?","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;","2","1","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E LEFT JOIN DEPT D ON E.DEPTNO = D.DEPTNO WHERE E.SAL > 3000 ORDER BY E.ENAME;"
"745","다음의 오라클 표준을 ANSI로 가장 잘 표현한 것은?","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;","2","2","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO WHERE E.SAL > 3000 ORDER BY E.ENAME;"
"745","다음의 오라클 표준을 ANSI로 가장 잘 표현한 것은?","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;","2","3","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E INNER JOIN DEPT D USING DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;"
"745","다음의 오라클 표준을 ANSI로 가장 잘 표현한 것은?","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;","2","4","SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;"
"784","다음의 컬럼 별칭 정의가 가장 적절하지 않은 것은?","","3","1","SELECT ENAME, SAL, COMM AS SAL_COMM"
"784","다음의 컬럼 별칭 정의가 가장 적절하지 않은 것은?","","3","2","SELECT ENAME, SAL, JOB AS ""JOB**"""
"784","다음의 컬럼 별칭 정의가 가장 적절하지 않은 것은?","","3","3","SELECT ENAME, SAL, DEPTNO AS DEPT NUMBER"
"784","다음의 컬럼 별칭 정의가 가장 적절하지 않은 것은?","","3","4","SELECT ENAME 이름, SAL AS Salary"
"785","다음 날짜 연산의 결과로 가장 적절한 것은?","SELECT ADD_MONTHS(TO_DATE('2024/08/24 10:00:00', 'YYYY/MM/DD HH24:MI:SS') - 10, -3) + 10/24/60 FROM DUAL;","4","1","2024/05/24 10:10:00"
"785","다음 날짜 연산의 결과로 가장 적절한 것은?","SELECT ADD_MONTHS(TO_DATE('2024/08/24 10:00:00', 'YYYY/MM/DD HH24:MI:SS') - 10, -3) + 10/24/60 FROM DUAL;","4","2","2024/05/24 10:00:10"
"785","다음 날짜 연산의 결과로 가장 적절한 것은?","SELECT ADD_MONTHS(TO_DATE('2024/08/24 10:00:00', 'YYYY/MM/DD HH24:MI:SS') - 10, -3) + 10/24/60 FROM DUAL;","4","3","2024/05/14 11:00:00"
"785","다음 날짜 연산의 결과로 가장 적절한 것은?","SELECT ADD_MONTHS(TO_DATE('2024/08/24 10:00:00', 'YYYY/MM/DD HH24:MI:SS') - 10, -3) + 10/24/60 FROM DUAL;","4","4","2024/05/14 10:10:00"
"787","아래 함수 결과로 가장 적절하지 않은 것은?","","1","1","RTRIM('ABCAA', ‘A’) : BC"
"787","아래 함수 결과로 가장 적절하지 않은 것은?","","1","2","TO_CHAR(1000,'9,999') : 1,000"
"787","아래 함수 결과로 가장 적절하지 않은 것은?","","1","3","SUBSTR('Sql Developer', -5, 2) : lo"
"787","아래 함수 결과로 가장 적절하지 않은 것은?","","1","4","UPPER('Sql Developer') : SQL DEVELOPER"
"791","아래 SQL 중 출력 결과가 다른 것은?","","3","1","SELECT * FROM EMP WHERE (DEPTNO = 10 OR DEPTNO = 20) AND JOB = 'CLERK' OR SAL > 3000;"
"791","아래 SQL 중 출력 결과가 다른 것은?","","3","2","SELECT * FROM EMP WHERE (DEPTNO = 10 AND JOB = 'CLERK') OR (DEPTNO = 20 AND JOB = 'CLERK') OR SAL > 3000;"
"791","아래 SQL 중 출력 결과가 다른 것은?","","3","3","SELECT * FROM EMP WHERE DEPTNO = 10 OR DEPTNO = 20 AND JOB = 'CLERK' OR SAL > 3000;"
"791","아래 SQL 중 출력 결과가 다른 것은?","","3","4","SELECT * FROM EMP WHERE DEPTNO IN (10,20) AND JOB = 'CLERK' OR SAL > 3000;"
"797","학생과 교수 테이블을 사용하여 지도교수가 없는 학생 정보도 출력을 하고자 할 때, 아래 빈칸으로 가장 적절한 것은?","SELECT 학생.이름 학생명, 교수.이름 교수명 
  FROM 학생 _________ 교수 
     ON 학생.교수번호 = 교수.교수번호;","4","1","INNER JOIN"
"797","학생과 교수 테이블을 사용하여 지도교수가 없는 학생 정보도 출력을 하고자 할 때, 아래 빈칸으로 가장 적절한 것은?","SELECT 학생.이름 학생명, 교수.이름 교수명 
  FROM 학생 _________ 교수 
     ON 학생.교수번호 = 교수.교수번호;","4","2","FULL OUTER JOIN"
"797","학생과 교수 테이블을 사용하여 지도교수가 없는 학생 정보도 출력을 하고자 할 때, 아래 빈칸으로 가장 적절한 것은?","SELECT 학생.이름 학생명, 교수.이름 교수명 
  FROM 학생 _________ 교수 
     ON 학생.교수번호 = 교수.교수번호;","4","3","RIGHT OUTER JOIN"
"797","학생과 교수 테이블을 사용하여 지도교수가 없는 학생 정보도 출력을 하고자 할 때, 아래 빈칸으로 가장 적절한 것은?","SELECT 학생.이름 학생명, 교수.이름 교수명 
  FROM 학생 _________ 교수 
     ON 학생.교수번호 = 교수.교수번호;","4","4","LEFT OUTER JOIN"
"235","다음 7개의 SQL 문장이 성공적으로 수행되었을 때, 세 개의 SQL 문장이 성공적으로 실행되면 select 문장의 결과는 각각 무엇인가?","create table 학과
(학과번호 char(10) primary key,
학과명 char(10));

create table 학생
(학번 char(10) primary key,
소속학과 char(10),
foreign key (소속학과) references 학과(학과번호)
on delete cascade
on updatde set null);
insert into 학과 values ('1', '전산과');
insert into 학과 values ('2', '전기과');
insert into 학생 values ('100', '1');
insert into 학생 values ('200', '2');
insert into 학생 values ('300', '2');

select count(학번) from 학생;
delete from 학과 where 학과번호 = '2';
select count(학번) from 학생;","4","1","3,null"
"235","다음 7개의 SQL 문장이 성공적으로 수행되었을 때, 세 개의 SQL 문장이 성공적으로 실행되면 select 문장의 결과는 각각 무엇인가?","create table 학과
(학과번호 char(10) primary key,
학과명 char(10));

create table 학생
(학번 char(10) primary key,
소속학과 char(10),
foreign key (소속학과) references 학과(학과번호)
on delete cascade
on updatde set null);
insert into 학과 values ('1', '전산과');
insert into 학과 values ('2', '전기과');
insert into 학생 values ('100', '1');
insert into 학생 values ('200', '2');
insert into 학생 values ('300', '2');

select count(학번) from 학생;
delete from 학과 where 학과번호 = '2';
select count(학번) from 학생;","4","2","3,3"
"235","다음 7개의 SQL 문장이 성공적으로 수행되었을 때, 세 개의 SQL 문장이 성공적으로 실행되면 select 문장의 결과는 각각 무엇인가?","create table 학과
(학과번호 char(10) primary key,
학과명 char(10));

create table 학생
(학번 char(10) primary key,
소속학과 char(10),
foreign key (소속학과) references 학과(학과번호)
on delete cascade
on updatde set null);
insert into 학과 values ('1', '전산과');
insert into 학과 values ('2', '전기과');
insert into 학생 values ('100', '1');
insert into 학생 values ('200', '2');
insert into 학생 values ('300', '2');

select count(학번) from 학생;
delete from 학과 where 학과번호 = '2';
select count(학번) from 학생;","4","3","3,2"
"235","다음 7개의 SQL 문장이 성공적으로 수행되었을 때, 세 개의 SQL 문장이 성공적으로 실행되면 select 문장의 결과는 각각 무엇인가?","create table 학과
(학과번호 char(10) primary key,
학과명 char(10));

create table 학생
(학번 char(10) primary key,
소속학과 char(10),
foreign key (소속학과) references 학과(학과번호)
on delete cascade
on updatde set null);
insert into 학과 values ('1', '전산과');
insert into 학과 values ('2', '전기과');
insert into 학생 values ('100', '1');
insert into 학생 values ('200', '2');
insert into 학생 values ('300', '2');

select count(학번) from 학생;
delete from 학과 where 학과번호 = '2';
select count(학번) from 학생;","4","4","3,1"
"266","데이터베이스 모델링 관점 중에서 CRUD 메트릭스와 관련이 있는 것은?","","1","1","데이터와 프로세스의 상관 관점"
"266","데이터베이스 모델링 관점 중에서 CRUD 메트릭스와 관련이 있는 것은?","","1","2","데이터와 데이터 간의 상관 관점"
"266","데이터베이스 모델링 관점 중에서 CRUD 메트릭스와 관련이 있는 것은?","","1","3","데이터 관점"
"266","데이터베이스 모델링 관점 중에서 CRUD 메트릭스와 관련이 있는 것은?","","1","4","프로세스 관점"
