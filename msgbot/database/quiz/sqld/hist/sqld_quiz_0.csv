220,그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.,,2,1,LAG
220,그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.,,2,2,RANK
220,그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.,,2,3,LAST_VALUE
220,그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.,,2,4,FIRST_VALUE
222,CONNECT BY에 대한 설명으로 맞지 않은 것은?,,4,1,SYS_CONNECT_BY_PATH는 하위 레벨의 칼럼까지 모두 표시한다.
222,CONNECT BY에 대한 설명으로 맞지 않은 것은?,,4,2,CONNECT_BY_ROOT는 ROOT 노드의 정보를 표시한다.
222,CONNECT BY에 대한 설명으로 맞지 않은 것은?,,4,3,CONNECT_BY_ISCYCLE는 ROOT까지의 경로에 존재하는 데이터를 의미한다.
222,CONNECT BY에 대한 설명으로 맞지 않은 것은?,,4,4,CONNECT_BY_ISLEAF는 전개과정에서 LEAF 데이터이면 0, 아니면 1을 가진다.
224,다음은 Order by에 대한 설명이다. 올바르지 않은 것은?,,1,1,날짜형 데이터 타입을 오름차순으로 정렬하면 날짜 값이 가장 늦은 날짜가 먼저 출력된다.
224,다음은 Order by에 대한 설명이다. 올바르지 않은 것은?,,1,2,SQL Server에서 오름차순으로 정렬하면 NULL 값이 가장 먼저 나온다.
224,다음은 Order by에 대한 설명이다. 올바르지 않은 것은?,,1,3,오름차순으로 숫자형 데이터 타입을 정렬하면 가장 작은 값부터 출력된다.
224,다음은 Order by에 대한 설명이다. 올바르지 않은 것은?,,1,4,기본적으로 정렬순서는 오름차순으로 정렬되지만 DESC를 사용하면 내림차순으로 정렬한다.
226,다음의 SQL문과 동일한 것을 고르시오.,Select NVL(Name,'없음') From Emp;,2,1,Select Case When Name IS NULL THEN '없음' ELSE '0' END AS USER_NAME
FROM Emp;
226,다음의 SQL문과 동일한 것을 고르시오.,Select NVL(Name,'없음') From Emp;,2,2,Select Case When Name IS NULL THEN '없음' ELSE NAME END AS USER_NAME
FROM Emp;
226,다음의 SQL문과 동일한 것을 고르시오.,Select NVL(Name,'없음') From Emp;,2,3,Select Case When Name IS NOT NULL THEN '0' ELSE NAME END AS USER_NAME
FROM Emp;
226,다음의 SQL문과 동일한 것을 고르시오.,Select NVL(Name,'없음') From Emp;,2,4,Select Case When Name IS NOT NULL THEN NAME ELSE '0' END AS USER_NAME
FROM Emp;
228,서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?,,3,1,Access Subquery
228,서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?,,3,2,Associative Subquery
228,서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?,,3,3,Scala Subquery
228,서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?,,3,4,Looping
276,다음 주어진 CUBE문과 동일한 것은?,GROUP BY CUBE(DEPTNO, JOB);,3,1,GROUP BY (DEPTNO, JOB, (DEPTNO, JOB), 0);
276,다음 주어진 CUBE문과 동일한 것은?,GROUP BY CUBE(DEPTNO, JOB);,3,2,GROUP BY DEPTNO UNION GROUP BY JOB UNION GROUP BY (DEPTNO, JOB)
276,다음 주어진 CUBE문과 동일한 것은?,GROUP BY CUBE(DEPTNO, JOB);,3,3,GROUP BY GROUPING SETS(DEPTNO, JOB, (DEPTNO, JOB), ());
276,다음 주어진 CUBE문과 동일한 것은?,GROUP BY CUBE(DEPTNO, JOB);,3,4,GROUP BY ROLLUP(DEPTNO, JOB);
286,다음 중 DROP TABLE 테이블명 [CASCADE CONSTRAINT]에 대한 설명으로 옳은 것은?,,1,1,CASCADE CONSTRAINT 옵션은 해당 테이블에서 참조되는 제약조건도삭제를 수행한다. 
286,다음 중 DROP TABLE 테이블명 [CASCADE CONSTRAINT]에 대한 설명으로 옳은 것은?,,1,2,SQL Server에서는 테이블을 먼저 삭제 한 뒤 참조하는 FOREIGN KEY 제약조건, 참조하는 테이블을 삭제한다.
286,다음 중 DROP TABLE 테이블명 [CASCADE CONSTRAINT]에 대한 설명으로 옳은 것은?,,1,3,CASCADE는 ORACLE, SQL Server, MySQL, PostgreSQL 모두 지원한다.
286,다음 중 DROP TABLE 테이블명 [CASCADE CONSTRAINT]에 대한 설명으로 옳은 것은?,,1,4,테이블의 구조만 삭제된다.
328,PL/SQL에서 FETCH 이후에 수행해야 하는 것은?,,2,1,EXIT
328,PL/SQL에서 FETCH 이후에 수행해야 하는 것은?,,2,2,Cursor CLOSE
328,PL/SQL에서 FETCH 이후에 수행해야 하는 것은?,,2,3,Cursor EXPTION
328,PL/SQL에서 FETCH 이후에 수행해야 하는 것은?,,2,4,Cursor DEFINE
331,다음 중 HASH 조인의 순서로 올바른 것은?,가. 선행 테이블에서 조건에 만족하는 데이터에 대해서 필터링을 수행한다.
나. 선행 테이블의 조인 키를 해시 함수의 입력으로 넣고 해시 테이블을 생성한다.
다. 가와 나의 작업은 선행 테이블에서 조건을 만족하는 모든 행에 대해서 실행한다.
라. 후행 테이블에 조건이 있으면 데이터에 대해서 필터링한다.
마. 후행 테이블의 조인 키를 해시 함수의 입력에 넣어서 해시값을 생성하고 선행 테이블의 해시 값과 비교해서 검색한다.,4,1,가 -> 라 -> 나 -> 마 -> 다
331,다음 중 HASH 조인의 순서로 올바른 것은?,가. 선행 테이블에서 조건에 만족하는 데이터에 대해서 필터링을 수행한다.
나. 선행 테이블의 조인 키를 해시 함수의 입력으로 넣고 해시 테이블을 생성한다.
다. 가와 나의 작업은 선행 테이블에서 조건을 만족하는 모든 행에 대해서 실행한다.
라. 후행 테이블에 조건이 있으면 데이터에 대해서 필터링한다.
마. 후행 테이블의 조인 키를 해시 함수의 입력에 넣어서 해시값을 생성하고 선행 테이블의 해시 값과 비교해서 검색한다.,4,2,나 -> 가 -> 마 -> 라 -> 다
331,다음 중 HASH 조인의 순서로 올바른 것은?,가. 선행 테이블에서 조건에 만족하는 데이터에 대해서 필터링을 수행한다.
나. 선행 테이블의 조인 키를 해시 함수의 입력으로 넣고 해시 테이블을 생성한다.
다. 가와 나의 작업은 선행 테이블에서 조건을 만족하는 모든 행에 대해서 실행한다.
라. 후행 테이블에 조건이 있으면 데이터에 대해서 필터링한다.
마. 후행 테이블의 조인 키를 해시 함수의 입력에 넣어서 해시값을 생성하고 선행 테이블의 해시 값과 비교해서 검색한다.,4,3,가 -> 나 -> 라 -> 마 -> 다
331,다음 중 HASH 조인의 순서로 올바른 것은?,가. 선행 테이블에서 조건에 만족하는 데이터에 대해서 필터링을 수행한다.
나. 선행 테이블의 조인 키를 해시 함수의 입력으로 넣고 해시 테이블을 생성한다.
다. 가와 나의 작업은 선행 테이블에서 조건을 만족하는 모든 행에 대해서 실행한다.
라. 후행 테이블에 조건이 있으면 데이터에 대해서 필터링한다.
마. 후행 테이블의 조인 키를 해시 함수의 입력에 넣어서 해시값을 생성하고 선행 테이블의 해시 값과 비교해서 검색한다.,4,4,가 -> 나 -> 다 -> 라 -> 마
339,다음 중 데이터베이스 관리 언어에 대한 설명으로 올바르지 않은 것은?,,1,1,DML은 비절차형 언어로 데이터를 조작할 수 있다.
339,다음 중 데이터베이스 관리 언어에 대한 설명으로 올바르지 않은 것은?,,1,2,COMMIT과 ROLLBACK, SAVEPOINT는 TCL 명령어이다.
339,다음 중 데이터베이스 관리 언어에 대한 설명으로 올바르지 않은 것은?,,1,3,DML은 질의를 실행하여 데이터를 조작할 수 있으며 INSERT, UPDATE, SELECT, DELETE구가 있다.
339,다음 중 데이터베이스 관리 언어에 대한 설명으로 올바르지 않은 것은?,,1,4,DDL은 테이블, 뷰, 인덱스 등을 생성하거나 변경하는 것으로 CREATE, ALTER, DROP, RENAME 등이 있다.
342,다음의 계층형 질의에서 리프 노드 여부를 출력하려고 한다. (    )에 올바른 것은?,SELECT LEVEL, LPAD(' ',4 + (LEVEL -1) )|| EMPNO, MGR, (    ) AS ISLEAF
FROM Mytest
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;,2,1,CONNECT_BY_LEAF
342,다음의 계층형 질의에서 리프 노드 여부를 출력하려고 한다. (    )에 올바른 것은?,SELECT LEVEL, LPAD(' ',4 + (LEVEL -1) )|| EMPNO, MGR, (    ) AS ISLEAF
FROM Mytest
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;,2,2,SYS_CONNECT_BY_PATH
342,다음의 계층형 질의에서 리프 노드 여부를 출력하려고 한다. (    )에 올바른 것은?,SELECT LEVEL, LPAD(' ',4 + (LEVEL -1) )|| EMPNO, MGR, (    ) AS ISLEAF
FROM Mytest
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;,2,3,CONNECT_BY_ISCYCLE
342,다음의 계층형 질의에서 리프 노드 여부를 출력하려고 한다. (    )에 올바른 것은?,SELECT LEVEL, LPAD(' ',4 + (LEVEL -1) )|| EMPNO, MGR, (    ) AS ISLEAF
FROM Mytest
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;,2,4,CONNECT_BY_ISLEAF
346,다음 중 데이터베이스 관리 언어를 올바르게 매핑한 것은?,,3,1,DML - ALTER
346,다음 중 데이터베이스 관리 언어를 올바르게 매핑한 것은?,,3,2,DCL - DROP
346,다음 중 데이터베이스 관리 언어를 올바르게 매핑한 것은?,,3,3,TCL - COMMIT
346,다음 중 데이터베이스 관리 언어를 올바르게 매핑한 것은?,,3,4,DML - RENAME
351,다음은 Oracle 데이터베이스의 계층형 질의에 대한 것이다. 올바르지 않은 것은?,,1,1,루트 노드의 LEVEL 값은 1이 아니다.
351,다음은 Oracle 데이터베이스의 계층형 질의에 대한 것이다. 올바르지 않은 것은?,,1,2,순방향 전개란 부모 노드로부터 자식 노드로 전개하는 것이고 역방향 전개는 자식 노드에서 부모 노드로 전개하는 것이다.
351,다음은 Oracle 데이터베이스의 계층형 질의에 대한 것이다. 올바르지 않은 것은?,,1,3,ORDER SIBILINGS BY구는 형제 노드 사이에 정렬을 수행한다.
351,다음은 Oracle 데이터베이스의 계층형 질의에 대한 것이다. 올바르지 않은 것은?,,1,4,START WITH절은 계층 구조의 시작점을 지정하는 구문이다.
364,다음 중 주식별자의 특징으로 올바르지 않은 것은?,,1,1,존재성 : 주식별자로 지정되면 데이터값이 존재하지 않을 수 있다.
364,다음 중 주식별자의 특징으로 올바르지 않은 것은?,,1,2,불변성 : 식별자의 값은 변하지 않아야 한다.
364,다음 중 주식별자의 특징으로 올바르지 않은 것은?,,1,3,최소성 : 속성의 수는 유일성을 만족해야 하고 최소의 수가 되어야 한다.
364,다음 중 주식별자의 특징으로 올바르지 않은 것은?,,1,4,유일성 : 엔터티 내에서 모든 인스턴스들은 유일해야 한다.
417,다음은 WINDOW FUNCTION에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?,,2,1,SUM(급여) OVER(PARTITION BY JOB ORDER BY JOB RANGE BETWEEN UNBOUNDED
PRECEDING AND CURRENT ROW) SAL
417,다음은 WINDOW FUNCTION에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?,,2,2,SUM(급여) OVER(PARTITION BY JOB ORDER BY EMPNO RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED PRECEDING) SAL
417,다음은 WINDOW FUNCTION에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?,,2,3,SUM(급여) OVER(PARTITION BY JOB ORDER BY EMPNO RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SAL
417,다음은 WINDOW FUNCTION에 대한 사용 방법이다. 가장 올바르지 않은 SQL문은 무엇인가?,,2,4,SUM(급여)  OVER()
419,다음 중 서브쿼리를 올바르게 구분한 것은?,SELECT (A)
FROM (B) a
WHERE a.col = (C),2,1,A : 인라인 뷰
B : 스칼라 서브쿼리
C : 서브쿼리
419,다음 중 서브쿼리를 올바르게 구분한 것은?,SELECT (A)
FROM (B) a
WHERE a.col = (C),2,2,A : 스칼라 서브쿼리
B : 인라인 뷰
C : 서브쿼리
419,다음 중 서브쿼리를 올바르게 구분한 것은?,SELECT (A)
FROM (B) a
WHERE a.col = (C),2,3,A : 서브쿼리
B : 스칼라 서브쿼리
C : 인라인 뷰
419,다음 중 서브쿼리를 올바르게 구분한 것은?,SELECT (A)
FROM (B) a
WHERE a.col = (C),2,4,A : 스칼라 서브쿼리
B : 서브쿼리
C : 인라인 뷰
449,식별자 중에서 비즈니스 프로세스에 의하여 만들어지는 식별자로 대체 여부로 분리되는 식별자는 무엇인가?,,4,1,인조 식별자
449,식별자 중에서 비즈니스 프로세스에 의하여 만들어지는 식별자로 대체 여부로 분리되는 식별자는 무엇인가?,,4,2,내부 식별자
449,식별자 중에서 비즈니스 프로세스에 의하여 만들어지는 식별자로 대체 여부로 분리되는 식별자는 무엇인가?,,4,3,단일 식별자
449,식별자 중에서 비즈니스 프로세스에 의하여 만들어지는 식별자로 대체 여부로 분리되는 식별자는 무엇인가?,,4,4,본질 식별자
456,아래의 SQL문을 실행했을 때 조회되는 행 수가 가장 많이 나오는 SQL문과 가장 적게 나오는 SQL문은?,insert into a1 values(1,4);
insert into a1 values(2,5);
insert into a1 values(3,6);
insert into a1 values(4,7);

insert into a2 values(1,4);
insert into a2 values(2,5);
insert into a2 values(null,6);
insert into a2 values(null,7);

(1)select * from a1,a2
     where a1.col1=a2.col1;

(2)select * from a1 left outer join a2
     on a1.col1=a2.col1;

(3)select * from a1 right outer join a2
     on a1.col1=a2.col1;

(4)select * from a1 full outer join a2
     on a1.col1=a2.col1;,1,1,(4), (1)
456,아래의 SQL문을 실행했을 때 조회되는 행 수가 가장 많이 나오는 SQL문과 가장 적게 나오는 SQL문은?,insert into a1 values(1,4);
insert into a1 values(2,5);
insert into a1 values(3,6);
insert into a1 values(4,7);

insert into a2 values(1,4);
insert into a2 values(2,5);
insert into a2 values(null,6);
insert into a2 values(null,7);

(1)select * from a1,a2
     where a1.col1=a2.col1;

(2)select * from a1 left outer join a2
     on a1.col1=a2.col1;

(3)select * from a1 right outer join a2
     on a1.col1=a2.col1;

(4)select * from a1 full outer join a2
     on a1.col1=a2.col1;,1,2,(3), (4)
456,아래의 SQL문을 실행했을 때 조회되는 행 수가 가장 많이 나오는 SQL문과 가장 적게 나오는 SQL문은?,insert into a1 values(1,4);
insert into a1 values(2,5);
insert into a1 values(3,6);
insert into a1 values(4,7);

insert into a2 values(1,4);
insert into a2 values(2,5);
insert into a2 values(null,6);
insert into a2 values(null,7);

(1)select * from a1,a2
     where a1.col1=a2.col1;

(2)select * from a1 left outer join a2
     on a1.col1=a2.col1;

(3)select * from a1 right outer join a2
     on a1.col1=a2.col1;

(4)select * from a1 full outer join a2
     on a1.col1=a2.col1;,1,3,(2), (3)
456,아래의 SQL문을 실행했을 때 조회되는 행 수가 가장 많이 나오는 SQL문과 가장 적게 나오는 SQL문은?,insert into a1 values(1,4);
insert into a1 values(2,5);
insert into a1 values(3,6);
insert into a1 values(4,7);

insert into a2 values(1,4);
insert into a2 values(2,5);
insert into a2 values(null,6);
insert into a2 values(null,7);

(1)select * from a1,a2
     where a1.col1=a2.col1;

(2)select * from a1 left outer join a2
     on a1.col1=a2.col1;

(3)select * from a1 right outer join a2
     on a1.col1=a2.col1;

(4)select * from a1 full outer join a2
     on a1.col1=a2.col1;,1,4,(1), (2)
463,다음 SQL문의 (     )에 들어가는 것으로 올바르지 않은 것은?,SELECT (         ), Count(Empno)
FROM EMP
WHERE EMPNO > 0
GROUP BY DEPTNO, SAL;,4,1,Deptno 와 Sal
463,다음 SQL문의 (     )에 들어가는 것으로 올바르지 않은 것은?,SELECT (         ), Count(Empno)
FROM EMP
WHERE EMPNO > 0
GROUP BY DEPTNO, SAL;,4,2,Sal
463,다음 SQL문의 (     )에 들어가는 것으로 올바르지 않은 것은?,SELECT (         ), Count(Empno)
FROM EMP
WHERE EMPNO > 0
GROUP BY DEPTNO, SAL;,4,3,Deptno 
463,다음 SQL문의 (     )에 들어가는 것으로 올바르지 않은 것은?,SELECT (         ), Count(Empno)
FROM EMP
WHERE EMPNO > 0
GROUP BY DEPTNO, SAL;,4,4,Empno
472,오라클 데이터베이스에서 내일 날짜를 조회하는 방법으로 올바른 것은?,,3,1,SELECT TO_CHAR(SYSDATE-1, 'YYYYMMDD') FROM DUAL;
472,오라클 데이터베이스에서 내일 날짜를 조회하는 방법으로 올바른 것은?,,3,2,SELECT TO_DATE(SYSDATE-1, 'YYYYMMDD') FROM DUAL;
472,오라클 데이터베이스에서 내일 날짜를 조회하는 방법으로 올바른 것은?,,3,3,SELECT TO_CHAR(SYSDATE+1, 'YYYYMMDD') FROM DUAL;
472,오라클 데이터베이스에서 내일 날짜를 조회하는 방법으로 올바른 것은?,,3,4,SELECT TO_DATE(SYSDATE+1, 'YYYYMMDD') FROM DUAL;
515,아래의 SQL문에 대해서 실행 순서를 올바르게 나열한 것은?,SELECT DEPTNO, COUNT(EMPNO)
FROM SCOTT.EMP
WHERE SAL >= 400
GROUP BY DEPTNO
HAVING COUNT(EMPNO) >= 3
ORDER BY DEPTNO;,1,1,FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY
515,아래의 SQL문에 대해서 실행 순서를 올바르게 나열한 것은?,SELECT DEPTNO, COUNT(EMPNO)
FROM SCOTT.EMP
WHERE SAL >= 400
GROUP BY DEPTNO
HAVING COUNT(EMPNO) >= 3
ORDER BY DEPTNO;,1,2,FROM -> WHERE -> GROUP BY -> SELECT -> HAVING -> ORDER BY
515,아래의 SQL문에 대해서 실행 순서를 올바르게 나열한 것은?,SELECT DEPTNO, COUNT(EMPNO)
FROM SCOTT.EMP
WHERE SAL >= 400
GROUP BY DEPTNO
HAVING COUNT(EMPNO) >= 3
ORDER BY DEPTNO;,1,3,FROM -> WHERE -> HAVING -> GROUP BY -> ORDER BY -> SELECT
515,아래의 SQL문에 대해서 실행 순서를 올바르게 나열한 것은?,SELECT DEPTNO, COUNT(EMPNO)
FROM SCOTT.EMP
WHERE SAL >= 400
GROUP BY DEPTNO
HAVING COUNT(EMPNO) >= 3
ORDER BY DEPTNO;,1,4,FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> SELECT
522,다음에서 설명하는 것은 ER 모델 중 어떤 항목에 대한 설명인가?,1) 모든 릴레이션은 원자값을 가져야 한다.
2) 어떤 릴레이션에서 속성 값이 가질 수 있는 값의 범위를 의미한다.
3) 실제 속성값이 올바르게 되었는지 확인한다
4) 속성명과 반드시 동일할필요는 없다. ,3,1,차수
522,다음에서 설명하는 것은 ER 모델 중 어떤 항목에 대한 설명인가?,1) 모든 릴레이션은 원자값을 가져야 한다.
2) 어떤 릴레이션에서 속성 값이 가질 수 있는 값의 범위를 의미한다.
3) 실제 속성값이 올바르게 되었는지 확인한다
4) 속성명과 반드시 동일할필요는 없다. ,3,2,인스턴스
522,다음에서 설명하는 것은 ER 모델 중 어떤 항목에 대한 설명인가?,1) 모든 릴레이션은 원자값을 가져야 한다.
2) 어떤 릴레이션에서 속성 값이 가질 수 있는 값의 범위를 의미한다.
3) 실제 속성값이 올바르게 되었는지 확인한다
4) 속성명과 반드시 동일할필요는 없다. ,3,3,도메인
522,다음에서 설명하는 것은 ER 모델 중 어떤 항목에 대한 설명인가?,1) 모든 릴레이션은 원자값을 가져야 한다.
2) 어떤 릴레이션에서 속성 값이 가질 수 있는 값의 범위를 의미한다.
3) 실제 속성값이 올바르게 되었는지 확인한다
4) 속성명과 반드시 동일할필요는 없다. ,3,4,카디날리티
540,다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?,,1,1,PL/SQL문의 기본 구조로 DECLARE, BEGIN ~ END, EXCEPTION은 필수적으로 써야 한다.
540,다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?,,1,2,Procedure 내부에 작성된 절차적 코드는 PL/SQL엔진이 처리하고 일반적인 SQL 문장은 SQL실행기가 처리한다. 
540,다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?,,1,3,Procedure, User Defined Function, Trigger 객체를 PL/SQL로 작성할 수 있다.
540,다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?,,1,4,변수와 상수 등을 사용하여 일반 SQL문장을 실행할 때 WHERE절의 조건 등으로 대입할 수 있다.
543,다음 중 아래에서 JOIN에 대한 설명으로 올바르지 않은 것은?,가) 마스터 테이블과 슬레이브 테이블 간의 조인은 일반적으로 기본키와 외래키 사이에서 발생한다.
나) EQUI JOIN은 두 개의 테이블 간에 칼럼 값이 일치하는 것을 조회한다.
다) EQUI JOIN은 >, <, >=, <=를 사용한다.
라) EQUI JOIN은 두 개의 테이블에서 교집합을 찾는다.,2,1,라
543,다음 중 아래에서 JOIN에 대한 설명으로 올바르지 않은 것은?,가) 마스터 테이블과 슬레이브 테이블 간의 조인은 일반적으로 기본키와 외래키 사이에서 발생한다.
나) EQUI JOIN은 두 개의 테이블 간에 칼럼 값이 일치하는 것을 조회한다.
다) EQUI JOIN은 >, <, >=, <=를 사용한다.
라) EQUI JOIN은 두 개의 테이블에서 교집합을 찾는다.,2,2,다
543,다음 중 아래에서 JOIN에 대한 설명으로 올바르지 않은 것은?,가) 마스터 테이블과 슬레이브 테이블 간의 조인은 일반적으로 기본키와 외래키 사이에서 발생한다.
나) EQUI JOIN은 두 개의 테이블 간에 칼럼 값이 일치하는 것을 조회한다.
다) EQUI JOIN은 >, <, >=, <=를 사용한다.
라) EQUI JOIN은 두 개의 테이블에서 교집합을 찾는다.,2,3,나
543,다음 중 아래에서 JOIN에 대한 설명으로 올바르지 않은 것은?,가) 마스터 테이블과 슬레이브 테이블 간의 조인은 일반적으로 기본키와 외래키 사이에서 발생한다.
나) EQUI JOIN은 두 개의 테이블 간에 칼럼 값이 일치하는 것을 조회한다.
다) EQUI JOIN은 >, <, >=, <=를 사용한다.
라) EQUI JOIN은 두 개의 테이블에서 교집합을 찾는다.,2,4,가
544,다음 중 아래의 SQL에 대한 설명으로 가장 올바른 것은?,SELECT 분류코드
AVG(상품가격) AS 상품가격,
COUNT(*) OVER(ORDER BY AVG(상품가격)
RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS CNT
FROM 상품
GROUP BY 분류코드;,2,1,CNT 칼럼은 상품전체의 평균상품가격을 서로 비교하여 -10000 ~ +10000사이에 존재하는 상품의 개수를 구한 것이다.
544,다음 중 아래의 SQL에 대한 설명으로 가장 올바른 것은?,SELECT 분류코드
AVG(상품가격) AS 상품가격,
COUNT(*) OVER(ORDER BY AVG(상품가격)
RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS CNT
FROM 상품
GROUP BY 분류코드;,2,2,CNT 칼럼은 분류코드별 평균상품가격을 서로 비교하여 -10000 ~ 10000 사이에 존재하는 분류코드의 개수를 구한 것이다.
544,다음 중 아래의 SQL에 대한 설명으로 가장 올바른 것은?,SELECT 분류코드
AVG(상품가격) AS 상품가격,
COUNT(*) OVER(ORDER BY AVG(상품가격)
RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS CNT
FROM 상품
GROUP BY 분류코드;,2,3,WINDOW FUNCTION의 ORDER BY 절로 인하여 문법오류이다. 
544,다음 중 아래의 SQL에 대한 설명으로 가장 올바른 것은?,SELECT 분류코드
AVG(상품가격) AS 상품가격,
COUNT(*) OVER(ORDER BY AVG(상품가격)
RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING) AS CNT
FROM 상품
GROUP BY 분류코드;,2,4,WINDOW FUNCTION을 GROUP BY(분류코드)절과 함께 사용하였으므로 위의 SQL은 오류가 발생한다.
564,View 사용시 장점이 아닌 것을 고르시오.,,1,1,논리적 데이터에 독립성을 제공하지 않는다.
564,View 사용시 장점이 아닌 것을 고르시오.,,1,2,동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해 준다.
564,View 사용시 장점이 아닌 것을 고르시오.,,1,3,사용자의 데이터관리를 간단하게 해준다.
564,View 사용시 장점이 아닌 것을 고르시오.,,1,4,접근 제어를 통한 자동 보안이 제공된다.
594,다음 중 GROUP BY절 대한 설명 중 틀린 것은?,,1,1,GROUP BY절에 나열되는 컬럼 순서에 따라 SELECT절의 그룹함수의 연산 결과가 달라질 수 있다.
594,다음 중 GROUP BY절 대한 설명 중 틀린 것은?,,1,2,GROUP BY절에 명시되지 않은 컬럼을 그룹함수 없이 SELECT절에 사용할 수 없다.
594,다음 중 GROUP BY절 대한 설명 중 틀린 것은?,,1,3,GROUP BY절에는 SUM, COUNT 함수를 사용할 수 없다.
594,다음 중 GROUP BY절 대한 설명 중 틀린 것은?,,1,4,GROUP BY절에는 컬럼 별칭을 사용할 수 없다.
611,아래의 계층형 SQL 에서 리프 데이터이면 1, 그렇지 않으면 0 을 출력하고 싶을 때 사용하는 키워드로 알맞은 것은? 
,SELECT LEVEL, 
 EMPNO, 
 MGR, 
 _____________ AS 리프노드여부 
 FROM SCOTT.EMP 
 START WITH MGR IS NULL 
CONNECT BY PRIOR EMPNO = MGR; 
,4,1,CONNECT_BY_ROOT
611,아래의 계층형 SQL 에서 리프 데이터이면 1, 그렇지 않으면 0 을 출력하고 싶을 때 사용하는 키워드로 알맞은 것은? 
,SELECT LEVEL, 
 EMPNO, 
 MGR, 
 _____________ AS 리프노드여부 
 FROM SCOTT.EMP 
 START WITH MGR IS NULL 
CONNECT BY PRIOR EMPNO = MGR; 
,4,2,SYS_CONNECT_BY_PATH
611,아래의 계층형 SQL 에서 리프 데이터이면 1, 그렇지 않으면 0 을 출력하고 싶을 때 사용하는 키워드로 알맞은 것은? 
,SELECT LEVEL, 
 EMPNO, 
 MGR, 
 _____________ AS 리프노드여부 
 FROM SCOTT.EMP 
 START WITH MGR IS NULL 
CONNECT BY PRIOR EMPNO = MGR; 
,4,3,CONNECT_BY_ISCYCLE
611,아래의 계층형 SQL 에서 리프 데이터이면 1, 그렇지 않으면 0 을 출력하고 싶을 때 사용하는 키워드로 알맞은 것은? 
,SELECT LEVEL, 
 EMPNO, 
 MGR, 
 _____________ AS 리프노드여부 
 FROM SCOTT.EMP 
 START WITH MGR IS NULL 
CONNECT BY PRIOR EMPNO = MGR; 
,4,4,CONNECT_BY_ISLEAF
613,다음 SQL 구문 결과와 같은 결과를 갖는 SQL은? ,SELECT COUNT(DECODE(DEPTNO,10,1)) AS 10, 
COUNT(DECODE(DEPTNO,20,1)) AS 20, 
COUNT(DECODE(DEPTNO,30,1)) AS 30 
 FROM EMP; 
,4,1, SELECT * FROM EMP 
 UNPIVOT (COUNT(*) FOR DEPTNO IN (10,20,30));
613,다음 SQL 구문 결과와 같은 결과를 갖는 SQL은? ,SELECT COUNT(DECODE(DEPTNO,10,1)) AS 10, 
COUNT(DECODE(DEPTNO,20,1)) AS 20, 
COUNT(DECODE(DEPTNO,30,1)) AS 30 
 FROM EMP; 
,4,2,SELECT * FROM EMP 
 UNPIVOT (COUNT(DEPTNO) FOR DEPTNO IN (10,20,30));
613,다음 SQL 구문 결과와 같은 결과를 갖는 SQL은? ,SELECT COUNT(DECODE(DEPTNO,10,1)) AS 10, 
COUNT(DECODE(DEPTNO,20,1)) AS 20, 
COUNT(DECODE(DEPTNO,30,1)) AS 30 
 FROM EMP; 
,4,3,SELECT * FROM (SELECT EMPNO, JOB, DEPTNO FROM EMP) 
    PIVOT (COUNT(DEPTNO) FOR EMPNO IN (10,20,30)); 
613,다음 SQL 구문 결과와 같은 결과를 갖는 SQL은? ,SELECT COUNT(DECODE(DEPTNO,10,1)) AS 10, 
COUNT(DECODE(DEPTNO,20,1)) AS 20, 
COUNT(DECODE(DEPTNO,30,1)) AS 30 
 FROM EMP; 
,4,4,SELECT * FROM (SELECT EMPNO, DEPTNO FROM EMP) 
    PIVOT (COUNT(EMPNO) FOR DEPTNO IN (10,20,30));
618,비교연산자의 어느 한쪽이 VARCHAR 유형 타입인 경우 문자 유형 비교에 대한 설명 중 가장 알맞지 않은 것은?,,1,1,길이가 다르다면 작은 쪽에 SPACE 를 추가하여 길이를 같게 한 후에 비교한다
618,비교연산자의 어느 한쪽이 VARCHAR 유형 타입인 경우 문자 유형 비교에 대한 설명 중 가장 알맞지 않은 것은?,,1,2,길이가 같고 다른 것이 없다면 같다고 판단한다
618,비교연산자의 어느 한쪽이 VARCHAR 유형 타입인 경우 문자 유형 비교에 대한 설명 중 가장 알맞지 않은 것은?,,1,3,길이가 다르다면 짧은 것이 끝날 때까지만 비교한 후에 길이가 긴 것이 크다고 판단한다 
618,비교연산자의 어느 한쪽이 VARCHAR 유형 타입인 경우 문자 유형 비교에 대한 설명 중 가장 알맞지 않은 것은?,,1,4,서로 다른 문자가 나올 때까지 비교한다 
643,다음 중 틀린 설명은? (단, DBMS는 ORACLE),,1,1,ORDER BY COMM DESC NULLS LAST 시 NULL이 맨 앞에 배치된다.
643,다음 중 틀린 설명은? (단, DBMS는 ORACLE),,1,2,ORDER BY COMM DESC 시 NULL이 맨 앞에 배치된다.
643,다음 중 틀린 설명은? (단, DBMS는 ORACLE),,1,3,ORDER BY COMM NULLS FIRST 시 NULL이 맨 앞에 배치된다. 
643,다음 중 틀린 설명은? (단, DBMS는 ORACLE),,1,4,ORDER BY COMM 시 NULL이 마지막에 배치된다.
647,다음 표준조인에 대한 설명 중 가장 적절하지 않은 것은? ,,2,1,INNER JOIN은 줄여서 JOIN으로 전달할 수 있다.
647,다음 표준조인에 대한 설명 중 가장 적절하지 않은 것은? ,,2,2,NATURAL JOIN시 같은 이름의 컬럼이 여러 개인 경우 USING절을 사용하여 원하는 컬럼을 선택할 수 있다.
647,다음 표준조인에 대한 설명 중 가장 적절하지 않은 것은? ,,2,3,FULL OUTER JOIN은 LEFT OUTER JOIN 결과와 RIGHT OUTER JOIN 결과를 UNION한 것과 같다.
647,다음 표준조인에 대한 설명 중 가장 적절하지 않은 것은? ,,2,4,CROSS JOIN인 두 테이블의 조인 컬럼의 값과 상관없이 항상 모든 경우의 수를 출력한다.
672,엔터티  - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오. ,,2,1,하나의 엔터티의 인스턴스는 다른 엔터티의 인스턴스간의 관계인 Paring을 가진다.
672,엔터티  - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오. ,,2,2,하나의 속성은 하나 이상의 속성값을 가진다.
672,엔터티  - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오. ,,2,3,한 개의 엔터티는 두 개 이상의 속성을 갖는다.
672,엔터티  - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오. ,,2,4,한 개의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다.
675,다음 주식별자에 대한 설명 중 가장 적절하지 않은 것은?,,3,1,지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
675,다음 주식별자에 대한 설명 중 가장 적절하지 않은 것은?,,3,2,주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
675,다음 주식별자에 대한 설명 중 가장 적절하지 않은 것은?,,3,3,주식별자로 지정되더라도 속성 값으로 NULL이 들어갈 수 있다.
675,다음 주식별자에 대한 설명 중 가장 적절하지 않은 것은?,,3,4,주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.
680,다음이 설명하는 식별자로 가장 적절한 것은? ,다른 엔터티 참조 없이 엔터티 내부에서 스스로 생성되는 식별자,1,1,내부식별자
680,다음이 설명하는 식별자로 가장 적절한 것은? ,다른 엔터티 참조 없이 엔터티 내부에서 스스로 생성되는 식별자,1,2,본질식별자
680,다음이 설명하는 식별자로 가장 적절한 것은? ,다른 엔터티 참조 없이 엔터티 내부에서 스스로 생성되는 식별자,1,3,인조식별자
680,다음이 설명하는 식별자로 가장 적절한 것은? ,다른 엔터티 참조 없이 엔터티 내부에서 스스로 생성되는 식별자,1,4,보조식별자
681,다음 중 DBMS 특징이 아닌 것은?,,4,1,인증된 사용자만이 참조 할 수 있는 보안기능이 제공된다.
681,다음 중 DBMS 특징이 아닌 것은?,,4,2,실시간 접근, 자료의 계속적인 변화의 적용에 유리하다.
681,다음 중 DBMS 특징이 아닌 것은?,,4,3,데이터 무결성을 유지 할 수 있다.
681,다음 중 DBMS 특징이 아닌 것은?,,4,4,DBMS에 저장된 데이터는 다른 사용자에게 공유될 수 없다.
692,다음 SQL 문장 중 COL1 값이 널(NULL)이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?,,4,1,SELECT * FROM TAB1 WHERE COL1 NOT NULL;
692,다음 SQL 문장 중 COL1 값이 널(NULL)이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?,,4,2,SELECT * FROM TAB1 WHERE COL1 != NULL;
692,다음 SQL 문장 중 COL1 값이 널(NULL)이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?,,4,3,SELECT * FROM TAB1 WHERE COL1 <> NULL;
692,다음 SQL 문장 중 COL1 값이 널(NULL)이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?,,4,4,SELECT * FROM TAB1 WHERE COL1 IS NOT NULL;
697,다음 FROM 절의 JOIN 형태에 대한 설명 중 올바르지 못한 것은? ,,2,1,RIGHT OUTER JOIN, LEFT OUTER JOIN에서 OUTER는 생략 가능하다.
697,다음 FROM 절의 JOIN 형태에 대한 설명 중 올바르지 못한 것은? ,,2,2,RIGHT OUTER JOIN 결과와 LEFT OUTER JOIN 결과는 항상 다르다.
697,다음 FROM 절의 JOIN 형태에 대한 설명 중 올바르지 못한 것은? ,,2,3,INNER JOIN 사용 시, USING 조건절이나 ON 조건절을 반드시 사용해야 한다.
697,다음 FROM 절의 JOIN 형태에 대한 설명 중 올바르지 못한 것은? ,,2,4,INNER JOIN은 WHERE 절에서 사용하던 JOIN 조건을 FROM 절에서 정의하겠다는 표시이다.
706,순위관련 WINDOW 함수에 대한 설명 중 가장 적절하지 않은 것은? ,,2,1,RANK 함수가 동일한 값에 대해서는 동일한 순위를 부여하는데 반해, ROW_NUMBER 함수는 고유한 순위를 부여한다.
706,순위관련 WINDOW 함수에 대한 설명 중 가장 적절하지 않은 것은? ,,2,2,PERCENT_RANK 함수는 각 값의 누적된 순위를 부여할 수 있다.
706,순위관련 WINDOW 함수에 대한 설명 중 가장 적절하지 않은 것은? ,,2,3,DENSE_RANK 함수는 RANK 함수처럼 동일한 값에 대해 동일한 순위를 부여하나, 동순위가 여럿 존재하더라도 다음 순위가 이어진다.
706,순위관련 WINDOW 함수에 대한 설명 중 가장 적절하지 않은 것은? ,,2,4,RANK함수는 동일한 값에 대해서는 동일한 순위를 부여한다.
708,다음 중 Top N Query에 대한 설명 중 틀린 것은?,,1,1,SQL-Server의 TOP(N) 쿼리를 사용하면 정렬 순서대로 상위 N개 데이터만 출력 가능하다.
708,다음 중 Top N Query에 대한 설명 중 틀린 것은?,,1,2,FETCH 절을 사용하면 단일 Query로도 정렬 순서대로의 상위 N개에 대한 값을 추출할 수 있다.
708,다음 중 Top N Query에 대한 설명 중 틀린 것은?,,1,3,ROWNUM을 사용한 방식은 ROWNUM 할당 전에 먼저 순서대로 데이터를 정렬한 뒤 ROWNUM을 부여 후 추출하는 것이 좋다.
708,다음 중 Top N Query에 대한 설명 중 틀린 것은?,,1,4,윈도우 함수를 사용하여 상위 N개에 대한 값을 추출할 수 있으나 단일 Query로 표현 불가하다.
713,DML에 대한 설명으로 가장 적절한 것은?,,2,1,UPDATE 사용 시 동시에 여러 컬럼 수정은 불가능하다.
713,DML에 대한 설명으로 가장 적절한 것은?,,2,2,DML은 반드시 COMMIT 또는 ROLLBACK을 입력하여 TRANSACTION을 종료해야 한다.
713,DML에 대한 설명으로 가장 적절한 것은?,,2,3,원하는 데이터 DELETE 시 WHERE 절은 반드시 붙이지 않아도 된다.
713,DML에 대한 설명으로 가장 적절한 것은?,,2,4,DELETE 사용 시 FROM 문구는 생략이 불가능하다.
722,엔터티 분류 중 유형과 무형에 따른 분류가 아닌 것은?,,1,1,행위엔터티
722,엔터티 분류 중 유형과 무형에 따른 분류가 아닌 것은?,,1,2,사건엔터티
722,엔터티 분류 중 유형과 무형에 따른 분류가 아닌 것은?,,1,3,개념엔터티
722,엔터티 분류 중 유형과 무형에 따른 분류가 아닌 것은?,,1,4,유형엔터티
745,다음의 오라클 표준을 ANSI로 가장 잘 표현한 것은?,SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;,2,1,SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E LEFT JOIN DEPT D ON E.DEPTNO = D.DEPTNO WHERE E.SAL > 3000 ORDER BY E.ENAME;
745,다음의 오라클 표준을 ANSI로 가장 잘 표현한 것은?,SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;,2,2,SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO WHERE E.SAL > 3000 ORDER BY E.ENAME;
745,다음의 오라클 표준을 ANSI로 가장 잘 표현한 것은?,SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;,2,3,SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E INNER JOIN DEPT D USING DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;
745,다음의 오라클 표준을 ANSI로 가장 잘 표현한 것은?,SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;,2,4,SELECT E.ENAME, E.SAL, E.DEPTNO, D.DNAME FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO AND E.SAL > 3000 ORDER BY E.ENAME;
784,다음의 컬럼 별칭 정의가 가장 적절하지 않은 것은?,,3,1,SELECT ENAME, SAL, COMM AS SAL_COMM
784,다음의 컬럼 별칭 정의가 가장 적절하지 않은 것은?,,3,2,SELECT ENAME, SAL, JOB AS JOB**
784,다음의 컬럼 별칭 정의가 가장 적절하지 않은 것은?,,3,3,SELECT ENAME, SAL, DEPTNO AS DEPT NUMBER
784,다음의 컬럼 별칭 정의가 가장 적절하지 않은 것은?,,3,4,SELECT ENAME 이름, SAL AS Salary
785,다음 날짜 연산의 결과로 가장 적절한 것은?,SELECT ADD_MONTHS(TO_DATE('2024/08/24 10:00:00', 'YYYY/MM/DD HH24:MI:SS') - 10, -3) + 10/24/60 FROM DUAL;,4,1,2024/05/24 10:10:00
785,다음 날짜 연산의 결과로 가장 적절한 것은?,SELECT ADD_MONTHS(TO_DATE('2024/08/24 10:00:00', 'YYYY/MM/DD HH24:MI:SS') - 10, -3) + 10/24/60 FROM DUAL;,4,2,2024/05/24 10:00:10
785,다음 날짜 연산의 결과로 가장 적절한 것은?,SELECT ADD_MONTHS(TO_DATE('2024/08/24 10:00:00', 'YYYY/MM/DD HH24:MI:SS') - 10, -3) + 10/24/60 FROM DUAL;,4,3,2024/05/14 11:00:00
785,다음 날짜 연산의 결과로 가장 적절한 것은?,SELECT ADD_MONTHS(TO_DATE('2024/08/24 10:00:00', 'YYYY/MM/DD HH24:MI:SS') - 10, -3) + 10/24/60 FROM DUAL;,4,4,2024/05/14 10:10:00
787,아래 함수 결과로 가장 적절하지 않은 것은?,,1,1,RTRIM('ABCAA', ‘A’) : BC
787,아래 함수 결과로 가장 적절하지 않은 것은?,,1,2,TO_CHAR(1000,'9,999') : 1,000
787,아래 함수 결과로 가장 적절하지 않은 것은?,,1,3,SUBSTR('Sql Developer', -5, 2) : lo
787,아래 함수 결과로 가장 적절하지 않은 것은?,,1,4,UPPER('Sql Developer') : SQL DEVELOPER
791,아래 SQL 중 출력 결과가 다른 것은?,,3,1,SELECT * FROM EMP WHERE (DEPTNO = 10 OR DEPTNO = 20) AND JOB = 'CLERK' OR SAL > 3000;
791,아래 SQL 중 출력 결과가 다른 것은?,,3,2,SELECT * FROM EMP WHERE (DEPTNO = 10 AND JOB = 'CLERK') OR (DEPTNO = 20 AND JOB = 'CLERK') OR SAL > 3000;
791,아래 SQL 중 출력 결과가 다른 것은?,,3,3,SELECT * FROM EMP WHERE DEPTNO = 10 OR DEPTNO = 20 AND JOB = 'CLERK' OR SAL > 3000;
791,아래 SQL 중 출력 결과가 다른 것은?,,3,4,SELECT * FROM EMP WHERE DEPTNO IN (10,20) AND JOB = 'CLERK' OR SAL > 3000;
797,학생과 교수 테이블을 사용하여 지도교수가 없는 학생 정보도 출력을 하고자 할 때, 아래 빈칸으로 가장 적절한 것은?,SELECT 학생.이름 학생명, 교수.이름 교수명 
  FROM 학생 _________ 교수 
     ON 학생.교수번호 = 교수.교수번호;,4,1,INNER JOIN
797,학생과 교수 테이블을 사용하여 지도교수가 없는 학생 정보도 출력을 하고자 할 때, 아래 빈칸으로 가장 적절한 것은?,SELECT 학생.이름 학생명, 교수.이름 교수명 
  FROM 학생 _________ 교수 
     ON 학생.교수번호 = 교수.교수번호;,4,2,FULL OUTER JOIN
797,학생과 교수 테이블을 사용하여 지도교수가 없는 학생 정보도 출력을 하고자 할 때, 아래 빈칸으로 가장 적절한 것은?,SELECT 학생.이름 학생명, 교수.이름 교수명 
  FROM 학생 _________ 교수 
     ON 학생.교수번호 = 교수.교수번호;,4,3,RIGHT OUTER JOIN
797,학생과 교수 테이블을 사용하여 지도교수가 없는 학생 정보도 출력을 하고자 할 때, 아래 빈칸으로 가장 적절한 것은?,SELECT 학생.이름 학생명, 교수.이름 교수명 
  FROM 학생 _________ 교수 
     ON 학생.교수번호 = 교수.교수번호;,4,4,LEFT OUTER JOIN
235,다음 7개의 SQL 문장이 성공적으로 수행되었을 때, 세 개의 SQL 문장이 성공적으로 실행되면 select 문장의 결과는 각각 무엇인가?,create table 학과
(학과번호 char(10) primary key,
학과명 char(10));

create table 학생
(학번 char(10) primary key,
소속학과 char(10),
foreign key (소속학과) references 학과(학과번호)
on delete cascade
on updatde set null);
insert into 학과 values ('1', '전산과');
insert into 학과 values ('2', '전기과');
insert into 학생 values ('100', '1');
insert into 학생 values ('200', '2');
insert into 학생 values ('300', '2');

select count(학번) from 학생;
delete from 학과 where 학과번호 = '2';
select count(학번) from 학생;,4,1,3,null
235,다음 7개의 SQL 문장이 성공적으로 수행되었을 때, 세 개의 SQL 문장이 성공적으로 실행되면 select 문장의 결과는 각각 무엇인가?,create table 학과
(학과번호 char(10) primary key,
학과명 char(10));

create table 학생
(학번 char(10) primary key,
소속학과 char(10),
foreign key (소속학과) references 학과(학과번호)
on delete cascade
on updatde set null);
insert into 학과 values ('1', '전산과');
insert into 학과 values ('2', '전기과');
insert into 학생 values ('100', '1');
insert into 학생 values ('200', '2');
insert into 학생 values ('300', '2');

select count(학번) from 학생;
delete from 학과 where 학과번호 = '2';
select count(학번) from 학생;,4,2,3,3
235,다음 7개의 SQL 문장이 성공적으로 수행되었을 때, 세 개의 SQL 문장이 성공적으로 실행되면 select 문장의 결과는 각각 무엇인가?,create table 학과
(학과번호 char(10) primary key,
학과명 char(10));

create table 학생
(학번 char(10) primary key,
소속학과 char(10),
foreign key (소속학과) references 학과(학과번호)
on delete cascade
on updatde set null);
insert into 학과 values ('1', '전산과');
insert into 학과 values ('2', '전기과');
insert into 학생 values ('100', '1');
insert into 학생 values ('200', '2');
insert into 학생 values ('300', '2');

select count(학번) from 학생;
delete from 학과 where 학과번호 = '2';
select count(학번) from 학생;,4,3,3,2
235,다음 7개의 SQL 문장이 성공적으로 수행되었을 때, 세 개의 SQL 문장이 성공적으로 실행되면 select 문장의 결과는 각각 무엇인가?,create table 학과
(학과번호 char(10) primary key,
학과명 char(10));

create table 학생
(학번 char(10) primary key,
소속학과 char(10),
foreign key (소속학과) references 학과(학과번호)
on delete cascade
on updatde set null);
insert into 학과 values ('1', '전산과');
insert into 학과 values ('2', '전기과');
insert into 학생 values ('100', '1');
insert into 학생 values ('200', '2');
insert into 학생 values ('300', '2');

select count(학번) from 학생;
delete from 학과 where 학과번호 = '2';
select count(학번) from 학생;,4,4,3,1
266,데이터베이스 모델링 관점 중에서 CRUD 메트릭스와 관련이 있는 것은?,,1,1,데이터와 프로세스의 상관 관점
266,데이터베이스 모델링 관점 중에서 CRUD 메트릭스와 관련이 있는 것은?,,1,2,데이터와 데이터 간의 상관 관점
266,데이터베이스 모델링 관점 중에서 CRUD 메트릭스와 관련이 있는 것은?,,1,3,데이터 관점
266,데이터베이스 모델링 관점 중에서 CRUD 메트릭스와 관련이 있는 것은?,,1,4,프로세스 관점
