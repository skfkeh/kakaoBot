1,모델링은 현실세계에 대해서 표현하는 것으로 이해할 수 있다. 다음 중 모델링의 특징으로 가장 부적절한 것은?,Unnamed: 2,3,1.1,애매모호함을 배제하고 누구나 이해가 가능하도록 정확하게 현상을 기술하는 정확화의 의미를 가짐
395.0,다음 중 Window Function에 대한 설명으로 알맞은 것은?,,3,2,Window Function 처리로 인해 결과 건수가 줄어들 수 있어 성능이 빠르다.
395.0,다음 중 Window Function에 대한 설명으로 알맞은 것은?,,3,3,"sum, min, max 등과 같은 집계 Window Function을 사용할 때 window 절과 함께 사용하면 집계의 대상이 되는 레코드 범위를 지정할 수 있다."
395.0,다음 중 Window Function에 대한 설명으로 알맞은 것은?,,3,4,Window Function은 내부적으로 자동 튜닝을 실시한다.
416.0,다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?,,2,1,intersect
416.0,다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?,,2,2,except
416.0,다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?,,2,3,union all
416.0,다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?,,2,4,union
423.0,"다음의 SQL문의 실행 결과로 올바른 것은?(단,오늘의 날짜는 2022년 4월 30일이고 시간은 무시)","SELECT SYSDATE,
TO_DATE(SYSDATE,'YYYY')
FROM DUAL;",1,1,에러가 발생한다.
423.0,"다음의 SQL문의 실행 결과로 올바른 것은?(단,오늘의 날짜는 2022년 4월 30일이고 시간은 무시)","SELECT SYSDATE,
TO_DATE(SYSDATE,'YYYY')
FROM DUAL;",1,2,22 - 04 - 30 00 : 00 : 00 2022
423.0,"다음의 SQL문의 실행 결과로 올바른 것은?(단,오늘의 날짜는 2022년 4월 30일이고 시간은 무시)","SELECT SYSDATE,
TO_DATE(SYSDATE,'YYYY')
FROM DUAL;",1,3,2022/04/30 00 : 00 : 00 2022
423.0,"다음의 SQL문의 실행 결과로 올바른 것은?(단,오늘의 날짜는 2022년 4월 30일이고 시간은 무시)","SELECT SYSDATE,
TO_DATE(SYSDATE,'YYYY')
FROM DUAL;",1,4,2022 - 04 - 30 00 : 00 : 00 2022
424.0,다음 SQL문 중에서 결괏값이 다른 하나는?,,3,1,"SELECT CONCAT('0', '5') FROM DUAL"
424.0,다음 SQL문 중에서 결괏값이 다른 하나는?,,3,2,SELECT TRIM('05') FROM DUAL
424.0,다음 SQL문 중에서 결괏값이 다른 하나는?,,3,3,SELECT EXTRACT(MONTH FROM DATE '2022 - 05 - 01') FROM DUAL;
424.0,다음 SQL문 중에서 결괏값이 다른 하나는?,,3,4,"SELECT SUBSTR(TO_CHAR ('20220504'), 5,2) FROM DUAL"
433.0,다음 보기와 동일한 SQL문은?,SELECT * FROM MYTEST WHERE COL1 BETWEEN :A AND :B,4,1,"SELECT * FROM MYTEST
WHERE COL1 <= :A
OR COL1 >= B"
433.0,다음 보기와 동일한 SQL문은?,SELECT * FROM MYTEST WHERE COL1 BETWEEN :A AND :B,4,2,"SELECT * FROM MYTEST
WHERE COL1 >= :A
OR COL1 <= :B"
433.0,다음 보기와 동일한 SQL문은?,SELECT * FROM MYTEST WHERE COL1 BETWEEN :A AND :B,4,3,"SELECT * FROM MYTEST
WHERE COL1 <= :A
AND COL1 >= :B"
433.0,다음 보기와 동일한 SQL문은?,SELECT * FROM MYTEST WHERE COL1 BETWEEN :A AND :B,4,4,"SELECT * FROM MYTEST
WHERE COL1 >= :A
AND COL1 <= :B"
441.0,다음의 SQL문을 실행하면 조회되는 칼럼의 헤더명은 무엇인가?,"SELECT EMPNO, deptno, SALARY AS ""salary""
FROM Mytest
WHERE EMPNO < 1000;",4,1,"EMP, DEPT, SALARY"
441.0,다음의 SQL문을 실행하면 조회되는 칼럼의 헤더명은 무엇인가?,"SELECT EMPNO, deptno, SALARY AS ""salary""
FROM Mytest
WHERE EMPNO < 1000;",4,2,"EMPNO, DEPTNO, SALARY"
441.0,다음의 SQL문을 실행하면 조회되는 칼럼의 헤더명은 무엇인가?,"SELECT EMPNO, deptno, SALARY AS ""salary""
FROM Mytest
WHERE EMPNO < 1000;",4,3,"EMP, DEPT, SAL"
441.0,다음의 SQL문을 실행하면 조회되는 칼럼의 헤더명은 무엇인가?,"SELECT EMPNO, deptno, SALARY AS ""salary""
FROM Mytest
WHERE EMPNO < 1000;",4,4,"EMPNO, DEPTNO, salary"
483.0,다음 중 데이터베이스 논리 모델에 대한 설명으로 올바르지 않은 것은?,,2,1,데이터가 물리적으로 저장되는 방법을 정의하는 것이 물리적 모델이다.
483.0,다음 중 데이터베이스 논리 모델에 대한 설명으로 올바르지 않은 것은?,,2,2,논리 모델은 데이터베이스 구축을 위해서만 사용되는 것이다.
483.0,다음 중 데이터베이스 논리 모델에 대한 설명으로 올바르지 않은 것은?,,2,3,"논리 데이터 모델은 M:N 관계형 식별자 확정, 정규화, 무결성 정의 등을 수행한다."
483.0,다음 중 데이터베이스 논리 모델에 대한 설명으로 올바르지 않은 것은?,,2,4,개념 데이터 모델은 사용자 관점에서 데이터 요구사항을 식별한다.
511.0,"주어진 테이블 test32에는 COL1과 COL2칼럼이 있다. 아래의 SQL문을 실행한 결과로 올바른 것은? (ㄱ은 COUNT(COL1)의 결괏값을, ㄴ과 ㄷ은 출력되는 결과의 행의 수를 고르시오.)","insert into test32 values (null,10);
insert into test32 values (12,null);
insert into test32 values (null,null);
insert into test32 values (10,12);

ㄱ. SELECT COUNT(COL1) FROM test32;
ㄴ. SELECT * FROM test32 WHERE COL1 IN (12,10,null);
ㄷ. SELECT COL1, COUNT(*) FROM test32 GROUP BY COL1;",2,1,"4,2,3"
511.0,"주어진 테이블 test32에는 COL1과 COL2칼럼이 있다. 아래의 SQL문을 실행한 결과로 올바른 것은? (ㄱ은 COUNT(COL1)의 결괏값을, ㄴ과 ㄷ은 출력되는 결과의 행의 수를 고르시오.)","insert into test32 values (null,10);
insert into test32 values (12,null);
insert into test32 values (null,null);
insert into test32 values (10,12);

ㄱ. SELECT COUNT(COL1) FROM test32;
ㄴ. SELECT * FROM test32 WHERE COL1 IN (12,10,null);
ㄷ. SELECT COL1, COUNT(*) FROM test32 GROUP BY COL1;",2,2,"2,2,3"
511.0,"주어진 테이블 test32에는 COL1과 COL2칼럼이 있다. 아래의 SQL문을 실행한 결과로 올바른 것은? (ㄱ은 COUNT(COL1)의 결괏값을, ㄴ과 ㄷ은 출력되는 결과의 행의 수를 고르시오.)","insert into test32 values (null,10);
insert into test32 values (12,null);
insert into test32 values (null,null);
insert into test32 values (10,12);

ㄱ. SELECT COUNT(COL1) FROM test32;
ㄴ. SELECT * FROM test32 WHERE COL1 IN (12,10,null);
ㄷ. SELECT COL1, COUNT(*) FROM test32 GROUP BY COL1;",2,3,"2,1,3"
511.0,"주어진 테이블 test32에는 COL1과 COL2칼럼이 있다. 아래의 SQL문을 실행한 결과로 올바른 것은? (ㄱ은 COUNT(COL1)의 결괏값을, ㄴ과 ㄷ은 출력되는 결과의 행의 수를 고르시오.)","insert into test32 values (null,10);
insert into test32 values (12,null);
insert into test32 values (null,null);
insert into test32 values (10,12);

ㄱ. SELECT COUNT(COL1) FROM test32;
ㄴ. SELECT * FROM test32 WHERE COL1 IN (12,10,null);
ㄷ. SELECT COL1, COUNT(*) FROM test32 GROUP BY COL1;",2,4,"2,3,4"
514.0,다음 중 NUMERIC(숫자) 형이 아닌 하나는?,,3,1,DECIMAL
514.0,다음 중 NUMERIC(숫자) 형이 아닌 하나는?,,3,2,FLOAT
514.0,다음 중 NUMERIC(숫자) 형이 아닌 하나는?,,3,3,CHAR
514.0,다음 중 NUMERIC(숫자) 형이 아닌 하나는?,,3,4,INT
530.0,다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로 가장 적절한 것은?,"가. 쇼핑몰 사이트에서는 회원번호가 쇼핑몰 사이트를 운영할 때 자주 이용되는 속성이므로 주식별자로 지정한다.
나. 엔터티 내에서 고객 리스트, 상품 리스트 등과 같은 것을 주식별자로 지정한다.
다. 주식별자로 지정할 때 자주 변경되는 속성을 지정한다.
라. 여러 개의 속성으로 구성된 복합 속성의 경우 주식별자에 너무 많은 속성이 포함되지 않게 한다.",3,1,"가,다"
530.0,다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로 가장 적절한 것은?,"가. 쇼핑몰 사이트에서는 회원번호가 쇼핑몰 사이트를 운영할 때 자주 이용되는 속성이므로 주식별자로 지정한다.
나. 엔터티 내에서 고객 리스트, 상품 리스트 등과 같은 것을 주식별자로 지정한다.
다. 주식별자로 지정할 때 자주 변경되는 속성을 지정한다.
라. 여러 개의 속성으로 구성된 복합 속성의 경우 주식별자에 너무 많은 속성이 포함되지 않게 한다.",3,2,"나,라"
530.0,다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로 가장 적절한 것은?,"가. 쇼핑몰 사이트에서는 회원번호가 쇼핑몰 사이트를 운영할 때 자주 이용되는 속성이므로 주식별자로 지정한다.
나. 엔터티 내에서 고객 리스트, 상품 리스트 등과 같은 것을 주식별자로 지정한다.
다. 주식별자로 지정할 때 자주 변경되는 속성을 지정한다.
라. 여러 개의 속성으로 구성된 복합 속성의 경우 주식별자에 너무 많은 속성이 포함되지 않게 한다.",3,3,"가,라"
530.0,다음 중 아래에서 엔터티 내에 주식별자를 도출하는 기준을 묶은 것으로 가장 적절한 것은?,"가. 쇼핑몰 사이트에서는 회원번호가 쇼핑몰 사이트를 운영할 때 자주 이용되는 속성이므로 주식별자로 지정한다.
나. 엔터티 내에서 고객 리스트, 상품 리스트 등과 같은 것을 주식별자로 지정한다.
다. 주식별자로 지정할 때 자주 변경되는 속성을 지정한다.
라. 여러 개의 속성으로 구성된 복합 속성의 경우 주식별자에 너무 많은 속성이 포함되지 않게 한다.",3,4,"가,나"
554.0,주어진 SQL문에서 ORDER BY로 사용할 수 없는 것은?,"SELECT JOB, COUNT(*) AS ROWCNT
FROM TEST40
GROUP BY JOB;",1,1,ORDER BY 3
554.0,주어진 SQL문에서 ORDER BY로 사용할 수 없는 것은?,"SELECT JOB, COUNT(*) AS ROWCNT
FROM TEST40
GROUP BY JOB;",1,2,ORDER BY COUNT(*)
554.0,주어진 SQL문에서 ORDER BY로 사용할 수 없는 것은?,"SELECT JOB, COUNT(*) AS ROWCNT
FROM TEST40
GROUP BY JOB;",1,3,ORDER BY CNT DESC
554.0,주어진 SQL문에서 ORDER BY로 사용할 수 없는 것은?,"SELECT JOB, COUNT(*) AS ROWCNT
FROM TEST40
GROUP BY JOB;",1,4,ORDER BY JOB
566.0,VIew의 개념 및 정의 중 틀린 것을 고르시오.,,3,1,"뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다."
566.0,VIew의 개념 및 정의 중 틀린 것을 고르시오.,,3,2,뷰는 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주된다.
566.0,VIew의 개념 및 정의 중 틀린 것을 고르시오.,,3,3,"뷰는 데이터 보정작업, 처리과정 시험 등 영구적인 작업을 위한 용도로 활용된다."
566.0,VIew의 개념 및 정의 중 틀린 것을 고르시오.,,3,4,뷰는 조인문의 사용 최소화로 사용상의 편의성을 최대화 한다.
571.0,다음은 어떤 데이터 모델링에 대한 설명인가?,추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링,1,1,개념적 데이터 모델링
571.0,다음은 어떤 데이터 모델링에 대한 설명인가?,추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링,1,2,개괄적 데이터 모델링
571.0,다음은 어떤 데이터 모델링에 대한 설명인가?,추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링,1,3,물리적 데이터 모델링
571.0,다음은 어떤 데이터 모델링에 대한 설명인가?,추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링,1,4,논리적 데이터 모델링
577.0,관계에 대한 설명으로 가장 적절하지 않은 것은?,"회원은 반드시 개인회원 또는 법인회원으로 회원가입을 한다. 
회원 가입 후 개인회원 또는 법인회원으로 로그인하여 서비스를 이용할 수 있다. ",1,1,개인회원 또는 법인회원 둘 중 하나로 주문 가능할 경우 고객과 주문 엔터티는 상호포함적 관계이다.
577.0,관계에 대한 설명으로 가장 적절하지 않은 것은?,"회원은 반드시 개인회원 또는 법인회원으로 회원가입을 한다. 
회원 가입 후 개인회원 또는 법인회원으로 로그인하여 서비스를 이용할 수 있다. ",1,2,고객과 주문내역 엔터티 간의 '주문' 관계는 행위에 의한 관계이다. 
577.0,관계에 대한 설명으로 가장 적절하지 않은 것은?,"회원은 반드시 개인회원 또는 법인회원으로 회원가입을 한다. 
회원 가입 후 개인회원 또는 법인회원으로 로그인하여 서비스를 이용할 수 있다. ",1,3,부서와 사원 엔터티 간의 '소속' 관계는 존재적 관계이다
577.0,관계에 대한 설명으로 가장 적절하지 않은 것은?,"회원은 반드시 개인회원 또는 법인회원으로 회원가입을 한다. 
회원 가입 후 개인회원 또는 법인회원으로 로그인하여 서비스를 이용할 수 있다. ",1,4,관계는 존재적 관계와 행위에 의한 관계로 나누어 볼 수 있다. 
581.0,SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ,,2,1,SELECT절에 DISTINCT는 항상 SELECT 바로 뒤에 위치한다.
581.0,SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ,,2,2,FROM 절은 모든 DBMS에서 생략 가능하다. 
581.0,SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ,,2,3,"ORDER BY절은 문법 순서도 맨 마지막에 위치하며, 실행 순서 역시 마지막이다. "
581.0,SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ,,2,4,오라클에서는 GROUP BY절 위에 HAVING절을 명시할 수 있다.
614.0,다음 출력 결과로 가장 알맞은 것은? ,"SELECT REGEXP_COUNT('abc1004 zz1234', '\d{2}+') AS C1, REGEXP_COUNT('abc1004-zz1234-100', '\d{2,}+') AS C2 
 FROM DUAL;",3,1,"8,3"
614.0,다음 출력 결과로 가장 알맞은 것은? ,"SELECT REGEXP_COUNT('abc1004 zz1234', '\d{2}+') AS C1, REGEXP_COUNT('abc1004-zz1234-100', '\d{2,}+') AS C2 
 FROM DUAL;",3,2,"8,1"
614.0,다음 출력 결과로 가장 알맞은 것은? ,"SELECT REGEXP_COUNT('abc1004 zz1234', '\d{2}+') AS C1, REGEXP_COUNT('abc1004-zz1234-100', '\d{2,}+') AS C2 
 FROM DUAL;",3,3,"2,3"
614.0,다음 출력 결과로 가장 알맞은 것은? ,"SELECT REGEXP_COUNT('abc1004 zz1234', '\d{2}+') AS C1, REGEXP_COUNT('abc1004-zz1234-100', '\d{2,}+') AS C2 
 FROM DUAL;",3,4,"2,1"
623.0,속성에 대한 설명으로 가장 적절하지 않은 것은?,,2,1,속성은 정해진 주식별자에 함수적 종속성을 가져야 한다.
623.0,속성에 대한 설명으로 가장 적절하지 않은 것은?,,2,2,하나의 인스턴스에서 각각의 속성은 하나 이상의 속성값을 가질 수 있다.
623.0,속성에 대한 설명으로 가장 적절하지 않은 것은?,,2,3,하나의 엔터티는 두 개 이상의 속성을 갖는다.
623.0,속성에 대한 설명으로 가장 적절하지 않은 것은?,,2,4,업무상 인스턴스로 관리하고자 하는 더 이상 분리되지 않는 최소 데이터 단위를 나타낸다.
658.0,부서내에서의 급여의 비율을 출력하는 구문으로 가장 적절하지 않은 것은? ,,1,1,"SELECT ENAME, SAL, DEPTNO, 
         ROUND(PERCENT_RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL) * 100, 2) AS SAL_RATIO 
    FROM EMP E1 
   ORDER BY DEPTNO, SAL DESC;"
658.0,부서내에서의 급여의 비율을 출력하는 구문으로 가장 적절하지 않은 것은? ,,1,2,"SELECT E1.ENAME, E1.SAL, E1.DEPTNO, 
         ROUND(E1.SAL/I.SUM_SAL * 100, 2) AS SAL_RATIO 
    FROM EMP E1, (SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
                    FROM EMP  
                   GROUP BY DEPTNO) I 
   WHERE E1.DEPTNO = I.DEPTNO                 
   ORDER BY DEPTNO, SAL DESC;"
658.0,부서내에서의 급여의 비율을 출력하는 구문으로 가장 적절하지 않은 것은? ,,1,3,"SELECT ENAME, SAL, DEPTNO, 
         ROUND(RATIO_TO_REPORT(SAL) OVER(PARTITION BY DEPTNO) * 100, 2) AS SAL_RATIO 
    FROM EMP E1 
   ORDER BY DEPTNO, SAL DESC;"
658.0,부서내에서의 급여의 비율을 출력하는 구문으로 가장 적절하지 않은 것은? ,,1,4,"SELECT ENAME, SAL, DEPTNO, 
           ROUND(SAL/(SELECT SUM(SAL)  
FROM EMP E2  
WHERE E1.DEPTNO = E2.DEPTNO) * 100, 2) AS SAL_RATIO 
    FROM EMP E1 
   ORDER BY DEPTNO, SAL DESC;"
665.0,다음 SQL중 입력오류가 발생할 문장으로 가장 적절한 것은?,"CREATE TABLE TAB1( 
COL1    VARCHAR(10) PRIMARY KEY, 
COL2 NUMBER NOT NULL,    
COL3 CHAR(10) NOT NULL,     
COL4   DATE NOT NULL);  ",1,1,"INSERT INTO TAB1 VALUES('0003', 40, 'CCC', '2024/01/01');"
665.0,다음 SQL중 입력오류가 발생할 문장으로 가장 적절한 것은?,"CREATE TABLE TAB1( 
COL1    VARCHAR(10) PRIMARY KEY, 
COL2 NUMBER NOT NULL,    
COL3 CHAR(10) NOT NULL,     
COL4   DATE NOT NULL);  ",1,2,"INSERT INTO TAB1 VALUES('0002', '30', '1000', CURRENT_DATE);"
665.0,다음 SQL중 입력오류가 발생할 문장으로 가장 적절한 것은?,"CREATE TABLE TAB1( 
COL1    VARCHAR(10) PRIMARY KEY, 
COL2 NUMBER NOT NULL,    
COL3 CHAR(10) NOT NULL,     
COL4   DATE NOT NULL);  ",1,3,"INSERT INTO TAB1 VALUES('0001', '20', 'BBB', SYSTIMESTAMP);"
665.0,다음 SQL중 입력오류가 발생할 문장으로 가장 적절한 것은?,"CREATE TABLE TAB1( 
COL1    VARCHAR(10) PRIMARY KEY, 
COL2 NUMBER NOT NULL,    
COL3 CHAR(10) NOT NULL,     
COL4   DATE NOT NULL);  ",1,4,"INSERT INTO TAB1 VALUES(1, 10, 'AAA', SYSDATE);"
688.0,다음 SQL중 실행 결과가 다른 하나는?,,3,1,"SELECT CASE DEPTNO WHEN 10 THEN CASE WHEN JOB = 'CLERK' THEN 'A' ELSE 'B' END 
                          WHEN 20 THEN 'C' ELSE 'D'  
            END FROM EMP;"
688.0,다음 SQL중 실행 결과가 다른 하나는?,,3,2,"SELECT CASE WHEN DEPTNO = 10 THEN CASE WHEN JOB = 'CLERK' THEN 'A' ELSE 'B' END 
                 WHEN DEPTNO = 20 THEN 'C' ELSE 'D'  
            END FROM EMP; "
688.0,다음 SQL중 실행 결과가 다른 하나는?,,3,3,"SELECT CASE WHEN (DEPTNO = 10 AND JOB = 'CLERK') THEN 'A' ELSE 'B' 
                 WHEN DEPTNO = 20 THEN 'C' ELSE 'D'  
            END FROM EMP;"
688.0,다음 SQL중 실행 결과가 다른 하나는?,,3,4,"SELECT DECODE(DEPTNO, 10, DECODE(JOB, 'CLERK', 'A', 'B'), 20, 'C', 'D') 
    FROM EMP;"
704.0,"다음 집합 연산자에 대한 설명 중 틀린 것은 무엇인가? (단, DBMS는 오라클)  ",,3,1,MINUS 연산자는 조회 결과에 대한 차집합을 의미한다.
704.0,"다음 집합 연산자에 대한 설명 중 틀린 것은 무엇인가? (단, DBMS는 오라클)  ",,3,2,INTERSECT 연산자는 조회 결과에 대한 교집합을 의미한다. 
704.0,"다음 집합 연산자에 대한 설명 중 틀린 것은 무엇인가? (단, DBMS는 오라클)  ",,3,3,UNION ALL 연산자는 조회 결과를 정렬하고 중복되는 데이터를 한 번만 표현한다.
704.0,"다음 집합 연산자에 대한 설명 중 틀린 것은 무엇인가? (단, DBMS는 오라클)  ",,3,4,UNION 연산자는 조회 결과에 대한 합집합을 나타내며 정렬된 결과를 출력해준다.
705.0,아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은? ,"SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY DEPTNO 
UNION ALL 
SELECT NULL DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP; 
SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY _______________; ",4,1,"ROLLUP(DEPTNO, ())"
705.0,아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은? ,"SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY DEPTNO 
UNION ALL 
SELECT NULL DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP; 
SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY _______________; ",4,2,"ROLLUP(DEPTNO, SAL)"
705.0,아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은? ,"SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY DEPTNO 
UNION ALL 
SELECT NULL DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP; 
SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY _______________; ",4,3,ROLLUP(SAL)
705.0,아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은? ,"SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY DEPTNO 
UNION ALL 
SELECT NULL DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP; 
SELECT DEPTNO, SUM(SAL) AS SUM_SAL 
FROM EMP 
GROUP BY _______________; ",4,4,ROLLUP(DEPTNO)
727.0,관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?,,3,1,행위 관계는 엔터티 간의 어떤 행위가 있는 것을 의미한다.
727.0,관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?,,3,2,관계를 맺는 엔터티를 다시 연결하는 과정을 조인이라고 한다.
727.0,관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?,,3,3,정규화를 거쳐 분리된 엔터티는 서로 관계를 맺지 않아도 된다.
727.0,관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?,,3,4,관계란 엔터티의 인스턴스 사이의 논리적인 연관성을 의미한다.
754.0,아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은?,,2,1,"CUBE(DEPTNO, JOB)"
754.0,아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은?,,2,2,"GROUPING SETS(DEPTNO, JOB, NULL)"
754.0,아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은?,,2,3,"GROUPING SETS(DEPTNO, JOB)"
754.0,아래 쿼리 결과와 같은 결과를 갖는 빈칸에 들어갈 문장으로 가장 적절한 것은?,,2,4,"ROLLUP(DEPTNO, JOB)"
773.0,다음 중 단일 속성이 아닌 것은?,,1,1,주소
773.0,다음 중 단일 속성이 아닌 것은?,,1,2,핸드폰번호
773.0,다음 중 단일 속성이 아닌 것은?,,1,3,성별
773.0,다음 중 단일 속성이 아닌 것은?,,1,4,이름
775.0,다음 중 주식별자의 특징이 아닌 것은?,,1,1,종속성
775.0,다음 중 주식별자의 특징이 아닌 것은?,,1,2,불변성
775.0,다음 중 주식별자의 특징이 아닌 것은?,,1,3,최소성
775.0,다음 중 주식별자의 특징이 아닌 것은?,,1,4,유일성
779.0,다음 중 NULL만으로 구성된 컬럼을 계산하여 NULL이 리턴되지 않는 함수는?,,4,1,MIN
779.0,다음 중 NULL만으로 구성된 컬럼을 계산하여 NULL이 리턴되지 않는 함수는?,,4,2,AVG
779.0,다음 중 NULL만으로 구성된 컬럼을 계산하여 NULL이 리턴되지 않는 함수는?,,4,3,SUM
779.0,다음 중 NULL만으로 구성된 컬럼을 계산하여 NULL이 리턴되지 않는 함수는?,,4,4,COUNT
783.0,다음 중 SQL 분류로 적절하지 않은 것은?,,2,1,DML - UPDATE 
783.0,다음 중 SQL 분류로 적절하지 않은 것은?,,2,2,DCL - COMMIT
783.0,다음 중 SQL 분류로 적절하지 않은 것은?,,2,3,TCL - ROLLBACK
783.0,다음 중 SQL 분류로 적절하지 않은 것은?,,2,4,DDL - ALTER
793.0,ORDER BY에 대한 설명으로 가장 적절한 것은?,,4,1,ORDER BY 절에는 컬럼명과 숫자를 동시에 사용할 수 없다.
793.0,ORDER BY에 대한 설명으로 가장 적절한 것은?,,4,2,ORDER BY 절에는 컬럼 별칭을 사용할 수 없다.
793.0,ORDER BY에 대한 설명으로 가장 적절한 것은?,,4,3,ORDER BY 절의 기본 정렬 순서는 내림차순이다.
793.0,ORDER BY에 대한 설명으로 가장 적절한 것은?,,4,4,ORDER BY 절을 사용하지 않으면 입력된 데이터의 순서대로 출력된다.
245.0,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,"SELECT JOB, ENAME, SAL,
RANK() OVER(ORDER BY SAL DESC)
ALL_RANK,
RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK 
FROM EMP;",2,1,PARTITION문을 사용해서 해당 파티션 내에서 순위를 계산한다.
245.0,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,"SELECT JOB, ENAME, SAL,
RANK() OVER(ORDER BY SAL DESC)
ALL_RANK,
RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK 
FROM EMP;",2,2,"RANK() 함수를 사용했으므로 급여가 동일한 사람이 있다면, 조회 순서에 따라서 1등과 2등으로 표시된다."
245.0,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,"SELECT JOB, ENAME, SAL,
RANK() OVER(ORDER BY SAL DESC)
ALL_RANK,
RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK 
FROM EMP;",2,3,JOB별로 SAL이 큰 등수가 조회된다.
245.0,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,"SELECT JOB, ENAME, SAL,
RANK() OVER(ORDER BY SAL DESC)
ALL_RANK,
RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK 
FROM EMP;",2,4,SAL칼럼은 급여가 큰 순으로 조회된다.
246.0,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,"SELECT ENAME,SAL, NTILE(4) OVER (ORDER BY SAL DESC) as DATA
FROM EMP;",4,1,SAL의 마지막 행은 급여가 가장 작은 사람이다.
246.0,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,"SELECT ENAME,SAL, NTILE(4) OVER (ORDER BY SAL DESC) as DATA
FROM EMP;",4,2,SAL의 값에 따라서 데이터를 4등분으로 분류해서 DATA 필드로 조회된다.
246.0,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,"SELECT ENAME,SAL, NTILE(4) OVER (ORDER BY SAL DESC) as DATA
FROM EMP;",4,3,SAL이 큰 순으로 조회된다.
246.0,다음의 SQL문에 대한 설명으로 올바르지 않은 것은?,"SELECT ENAME,SAL, NTILE(4) OVER (ORDER BY SAL DESC) as DATA
FROM EMP;",4,4,DATA 필드가 가질 수 있는 값의 범위는 0~3까지이다.
251.0,"도서(도서번호, 도서제목, 출판사명, 발행연도) 테이블에서, 2000년 이후에 10권 이상의 책을 발행한 출판사의 이름을 중복 없이 출력하는 SQL문으로 옳은 것은?(단, 출판사명이 동일한 출판사는 존재하지 않는 것으로 가정한다. 도서번호는 도서 테이블의 기본키이다)",,1,1,"SELECT 출판사명 FROM 도서
WHERE 발행연도 >= 2000
GROUP BY 출판사명
HAVING  COUNT(도서번호) >= 10;"
251.0,"도서(도서번호, 도서제목, 출판사명, 발행연도) 테이블에서, 2000년 이후에 10권 이상의 책을 발행한 출판사의 이름을 중복 없이 출력하는 SQL문으로 옳은 것은?(단, 출판사명이 동일한 출판사는 존재하지 않는 것으로 가정한다. 도서번호는 도서 테이블의 기본키이다)",,1,2,"SELECT 출판사명 FROM 도서
WHERE COUNT(도서번호) >= 10
GROUP BY 출판사명
HAVING  발행연도 >= 2000;"
251.0,"도서(도서번호, 도서제목, 출판사명, 발행연도) 테이블에서, 2000년 이후에 10권 이상의 책을 발행한 출판사의 이름을 중복 없이 출력하는 SQL문으로 옳은 것은?(단, 출판사명이 동일한 출판사는 존재하지 않는 것으로 가정한다. 도서번호는 도서 테이블의 기본키이다)",,1,3,"SELECT 출판사명 FROM 도서
WHERE 발행연도 >= 2000
AND  COUNT(도서번호) >= 10
GROUP BY 출판사명;"
251.0,"도서(도서번호, 도서제목, 출판사명, 발행연도) 테이블에서, 2000년 이후에 10권 이상의 책을 발행한 출판사의 이름을 중복 없이 출력하는 SQL문으로 옳은 것은?(단, 출판사명이 동일한 출판사는 존재하지 않는 것으로 가정한다. 도서번호는 도서 테이블의 기본키이다)",,1,4,"SELECT 출판사명 FROM 도서
WHERE 발행연도 >= 2000
ORDER BY  COUNT(도서번호) >= 10;"
252.0,다음의 NOT EXISTS 구문을 동일한 결과가 출력되게 SQL문을 변경하시오.,"SELECT ... FROM 급여이력 S
WHERE NOT EXISTS
(SELECT 'X' FROM 사원 P
WHERE P.사원번호 = S.사원번호)

[SQL문]
SELECT .... FROM 급여이력 S
LEFT OUTER JOIN 사원 P
ON(S.사원번호=P.사원번호) WHERE (         );",1,1,P.사원번호 IS NULL
252.0,다음의 NOT EXISTS 구문을 동일한 결과가 출력되게 SQL문을 변경하시오.,"SELECT ... FROM 급여이력 S
WHERE NOT EXISTS
(SELECT 'X' FROM 사원 P
WHERE P.사원번호 = S.사원번호)

[SQL문]
SELECT .... FROM 급여이력 S
LEFT OUTER JOIN 사원 P
ON(S.사원번호=P.사원번호) WHERE (         );",1,2,P.사원번호 IS NOT NULL
252.0,다음의 NOT EXISTS 구문을 동일한 결과가 출력되게 SQL문을 변경하시오.,"SELECT ... FROM 급여이력 S
WHERE NOT EXISTS
(SELECT 'X' FROM 사원 P
WHERE P.사원번호 = S.사원번호)

[SQL문]
SELECT .... FROM 급여이력 S
LEFT OUTER JOIN 사원 P
ON(S.사원번호=P.사원번호) WHERE (         );",1,3,P.사원번호 > 0
252.0,다음의 NOT EXISTS 구문을 동일한 결과가 출력되게 SQL문을 변경하시오.,"SELECT ... FROM 급여이력 S
WHERE NOT EXISTS
(SELECT 'X' FROM 사원 P
WHERE P.사원번호 = S.사원번호)

[SQL문]
SELECT .... FROM 급여이력 S
LEFT OUTER JOIN 사원 P
ON(S.사원번호=P.사원번호) WHERE (         );",1,4,P.사원번호 = NULL
259.0,"학생(STUDENT) 테이블에 영문학과 학생 50명, 법학과 학생 100명, 수학과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과 튜플 수는 각각 얼마인가? (단, DEPT필드는 학과명, NAME필드는 이름을 의미한다)","ㄱ : SELECT DEPT FROM SUDENT;
ㄴ : SELECT DISTINCT DEPT
       FROM STUDENT;
ㄷ : SELECT NAME FROM STUDENT 
       WHERE DEPT = '영문학과';",2,1,"ㄱ:200, ㄴ:200, ㄷ:50"
259.0,"학생(STUDENT) 테이블에 영문학과 학생 50명, 법학과 학생 100명, 수학과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과 튜플 수는 각각 얼마인가? (단, DEPT필드는 학과명, NAME필드는 이름을 의미한다)","ㄱ : SELECT DEPT FROM SUDENT;
ㄴ : SELECT DISTINCT DEPT
       FROM STUDENT;
ㄷ : SELECT NAME FROM STUDENT 
       WHERE DEPT = '영문학과';",2,2,"ㄱ:200, ㄴ:3, ㄷ:50"
259.0,"학생(STUDENT) 테이블에 영문학과 학생 50명, 법학과 학생 100명, 수학과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과 튜플 수는 각각 얼마인가? (단, DEPT필드는 학과명, NAME필드는 이름을 의미한다)","ㄱ : SELECT DEPT FROM SUDENT;
ㄴ : SELECT DISTINCT DEPT
       FROM STUDENT;
ㄷ : SELECT NAME FROM STUDENT 
       WHERE DEPT = '영문학과';",2,3,"ㄱ:200, ㄴ:3, ㄷ:1"
259.0,"학생(STUDENT) 테이블에 영문학과 학생 50명, 법학과 학생 100명, 수학과 학생 50명의 정보가 저장되어 있을 때, 다음 SQL문의 실행 결과 튜플 수는 각각 얼마인가? (단, DEPT필드는 학과명, NAME필드는 이름을 의미한다)","ㄱ : SELECT DEPT FROM SUDENT;
ㄴ : SELECT DISTINCT DEPT
       FROM STUDENT;
ㄷ : SELECT NAME FROM STUDENT 
       WHERE DEPT = '영문학과';",2,4,"ㄱ:3, ㄴ:3, ㄷ:1"
265.0,다음은 분리되어 네트워크로 연결된 분산 데이터베이스에 대한 설명이다. 올바르지 않은 것은?,,2,1,장애 시에 다른 데이터베이스가 서비스하게 하여 가용성이 좋아진다.
265.0,다음은 분리되어 네트워크로 연결된 분산 데이터베이스에 대한 설명이다. 올바르지 않은 것은?,,2,2,보안 통제가 쉽고 비용이 절감된다.
265.0,다음은 분리되어 네트워크로 연결된 분산 데이터베이스에 대한 설명이다. 올바르지 않은 것은?,,2,3,여러 개의 데이터베이스가 존재하므로 관리하기가 어렵다. 
265.0,다음은 분리되어 네트워크로 연결된 분산 데이터베이스에 대한 설명이다. 올바르지 않은 것은?,,2,4,지역 데이터베이스에서 사용자 Query를 실행하고 빠르게 응답할 수 있다.
802.0,개념적 데이터 모델링에서 주로 사용되는 모델은 무엇인가?,,2,1,관계형 모델
802.0,개념적 데이터 모델링에서 주로 사용되는 모델은 무엇인가?,,2,2,ER 모델
802.0,개념적 데이터 모델링에서 주로 사용되는 모델은 무엇인가?,,2,3,계층형 모델
802.0,개념적 데이터 모델링에서 주로 사용되는 모델은 무엇인가?,,2,4,네트워크 모델
817.0,비즈니스 룰(Business Rule)의 역할은?,,3,1,하드웨어 선택 기준 제공
817.0,비즈니스 룰(Business Rule)의 역할은?,,3,2,UI 설계 기준
817.0,비즈니스 룰(Business Rule)의 역할은?,,3,3,데이터 모델 작성 기준 제공
817.0,비즈니스 룰(Business Rule)의 역할은?,,3,4,서버 트래픽 분석
8.0,다음 중 ERD에 대한 설명으로 가장 부적절한 것은?,,1,1,가장 중요한 엔터티를 오른쪽 상단에 배치하고 추가 발생되는 엔터티들을 왼쪽 편과 하단에 배치하는 것이 원칙이다.
8.0,다음 중 ERD에 대한 설명으로 가장 부적절한 것은?,,1,2,관계의 명칭은 관계 표현에 있어서 매우 중요한 부분에 해당한다.
8.0,다음 중 ERD에 대한 설명으로 가장 부적절한 것은?,,1,3,일반적으로 ERD를 작성하는 방법은 엔터티 도출 -> 엔터티 배치 -> 관계 설정 -> 관계명 기술의 흐름으로 작업을 진행한다.
8.0,다음 중 ERD에 대한 설명으로 가장 부적절한 것은?,,1,4,1976년 피터첸(Peter Chen)에 의해 Entity-Relationship Model(E-R Model) 이라는 표기법이 만들어졌다.
15.0,다음 중 아래와 같은 사례에서 속성에 대한 설명으로 가장 부적절한 것은?,"우리은행은 예금분류(일반예금, 특별예금 등)의 원금, 예치기간, 이자율을 관리할 필요가 있다. 또한 원금에 대한 이자율을 적용하여 계산된 이자에 대해서도 속성으로 관리하고자 한다. 예를 들어 원금이 1000원이고 예치기간이 5개월이며 이자율이 5.0%라는 속성을 관리하고 계산된 이자도 관리한다. 일반예금이나 특별예금 등에 대해서는 코드를 부여(예. 01-일반예금, 02-특별예금 등)하여 관리한다.",2,1,예금분류는 설계(DESIGNED)속성이다.
15.0,다음 중 아래와 같은 사례에서 속성에 대한 설명으로 가장 부적절한 것은?,"우리은행은 예금분류(일반예금, 특별예금 등)의 원금, 예치기간, 이자율을 관리할 필요가 있다. 또한 원금에 대한 이자율을 적용하여 계산된 이자에 대해서도 속성으로 관리하고자 한다. 예를 들어 원금이 1000원이고 예치기간이 5개월이며 이자율이 5.0%라는 속성을 관리하고 계산된 이자도 관리한다. 일반예금이나 특별예금 등에 대해서는 코드를 부여(예. 01-일반예금, 02-특별예금 등)하여 관리한다.",2,2,이자와 이자율은 파생(DERIVED)속성이다.
15.0,다음 중 아래와 같은 사례에서 속성에 대한 설명으로 가장 부적절한 것은?,"우리은행은 예금분류(일반예금, 특별예금 등)의 원금, 예치기간, 이자율을 관리할 필요가 있다. 또한 원금에 대한 이자율을 적용하여 계산된 이자에 대해서도 속성으로 관리하고자 한다. 예를 들어 원금이 1000원이고 예치기간이 5개월이며 이자율이 5.0%라는 속성을 관리하고 계산된 이자도 관리한다. 일반예금이나 특별예금 등에 대해서는 코드를 부여(예. 01-일반예금, 02-특별예금 등)하여 관리한다.",2,3,"원금, 예치기간은 기본(BASIC)속성이다."
15.0,다음 중 아래와 같은 사례에서 속성에 대한 설명으로 가장 부적절한 것은?,"우리은행은 예금분류(일반예금, 특별예금 등)의 원금, 예치기간, 이자율을 관리할 필요가 있다. 또한 원금에 대한 이자율을 적용하여 계산된 이자에 대해서도 속성으로 관리하고자 한다. 예를 들어 원금이 1000원이고 예치기간이 5개월이며 이자율이 5.0%라는 속성을 관리하고 계산된 이자도 관리한다. 일반예금이나 특별예금 등에 대해서는 코드를 부여(예. 01-일반예금, 02-특별예금 등)하여 관리한다.",2,4,일반예금은 코드 엔터티를 별도로 구분하고 값에는 코드값만 포함한다.
19.0,다음 중 데이터모델링의 관계에 대한 설명으로 가장 부적절한 것을 2개 고르시오.,,1|2,1,UML(Unified Modeling Language)에는 클래스다이어그램의 관계 중 연관관계(Association)와 의존관계(Dependency)가 있고 있으나 구분 하지 않고 단일화된 표기법을 사용한다.
19.0,다음 중 데이터모델링의 관계에 대한 설명으로 가장 부적절한 것을 2개 고르시오.,,1|2,2,"관계는 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있고 ERD 에서는 관계를 연결할 때, 존재와 행위를 구분하여 실선과 점선의 표기법으로 다르게 표현한다."
19.0,다음 중 데이터모델링의 관계에 대한 설명으로 가장 부적절한 것을 2개 고르시오.,,1|2,3,UML(Unified Modeling Language)에는 클래스다이어그램의 관계 중 연관관계(Association)와 의존관계(Dependency)가 있고 이것은 실선과 점선의 표기법으로 다르게 표현이 된다.
19.0,다음 중 데이터모델링의 관계에 대한 설명으로 가장 부적절한 것을 2개 고르시오.,,1|2,4,"관계는 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있으나 ERD에서는 관계를 연결할 때, 존재와 행위를 구분하지 않고 단일화된 표기법을 사용한다."
22.0,다음 중 두 개의 엔터티 사이에 정의한 관계를 체크 할 사항으로 가장 부적절한 것은?,,2,1,"업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?"
22.0,다음 중 두 개의 엔터티 사이에 정의한 관계를 체크 할 사항으로 가장 부적절한 것은?,,2,2,"업무기술서, 장표에 관계연결을 가능하게 하는 명사(Noun)가 있는가?"
22.0,다음 중 두 개의 엔터티 사이에 정의한 관계를 체크 할 사항으로 가장 부적절한 것은?,,2,3,두 개의 엔터티 사이에 정보의 조합이 발생되는가?
22.0,다음 중 두 개의 엔터티 사이에 정의한 관계를 체크 할 사항으로 가장 부적절한 것은?,,2,4,두 개의 엔터티 사이에 관심 있는 연관규칙이 존재하는가?
24.0,다음 중 아래어서 주식별자를 자정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한것은?,"가. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.
나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.",1,1,"가,나,다,라"
24.0,다음 중 아래어서 주식별자를 자정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한것은?,"가. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.
나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.",1,2,"나,다,라"
24.0,다음 중 아래어서 주식별자를 자정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한것은?,"가. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.
나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.",1,3,"가,나,라"
24.0,다음 중 아래어서 주식별자를 자정할 때 고려해야 할 사항을 묶은 것으로 가장 적절한것은?,"가. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.
나. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
다. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
라. 주식별자가 지정이 되면 반드시 값이 들어와야 한다.",1,4,"가,나,다"
39.0,다음 중 아래 내용의 범주에 해당하는 SQL 명령어로 옳지 않은 것은?,"테이블의 구조를 생성, 변경, 삭제하는 등 데이터 구조를 정의하는데 사용되는 명령어이다.",3,1,DROP
39.0,다음 중 아래 내용의 범주에 해당하는 SQL 명령어로 옳지 않은 것은?,"테이블의 구조를 생성, 변경, 삭제하는 등 데이터 구조를 정의하는데 사용되는 명령어이다.",3,2,ALTER
39.0,다음 중 아래 내용의 범주에 해당하는 SQL 명령어로 옳지 않은 것은?,"테이블의 구조를 생성, 변경, 삭제하는 등 데이터 구조를 정의하는데 사용되는 명령어이다.",3,3,GRANT
39.0,다음 중 아래 내용의 범주에 해당하는 SQL 명령어로 옳지 않은 것은?,"테이블의 구조를 생성, 변경, 삭제하는 등 데이터 구조를 정의하는데 사용되는 명령어이다.",3,4,CREATE
46.0,다음 중 테이블 생성시 칼럼별 생성할 수 있는 제익조건(Constraints)에 대한 설명으로 가장 부적절한 것은?,,4,1,NOT NULL : 명시적으로 NULL 입력을 방지한다.
46.0,다음 중 테이블 생성시 칼럼별 생성할 수 있는 제익조건(Constraints)에 대한 설명으로 가장 부적절한 것은?,,4,2,FK  : 외래키로 테이블당 여러 개 생성이 가능하다.
46.0,다음 중 테이블 생성시 칼럼별 생성할 수 있는 제익조건(Constraints)에 대한 설명으로 가장 부적절한 것은?,,4,3,PK  : 주키로 테이블당 1개만 생성이 가능하다.
46.0,다음 중 테이블 생성시 칼럼별 생성할 수 있는 제익조건(Constraints)에 대한 설명으로 가장 부적절한 것은?,,4,4,UNIQUE : 테이블 내에서 중복되는 값이 없으며 NULL 입력이 불가능 하다.
47.0,다음 중 물리적 테이블 명으로 가장 적절한 것은?,,4,1,100_EMP
47.0,다음 중 물리적 테이블 명으로 가장 적절한 것은?,,4,2,EMP-100
47.0,다음 중 물리적 테이블 명으로 가장 적절한 것은?,,4,3,100-EMP
47.0,다음 중 물리적 테이블 명으로 가장 적절한 것은?,,4,4,EMP_10
60.0,데이터베이스 트랜잭션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점으로 가장 부적절한 것을 2개 고르시오.,,"1,4",1,isolation : 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다.
60.0,데이터베이스 트랜잭션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점으로 가장 부적절한 것을 2개 고르시오.,,"1,4",2,"Phantom Read : 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫번째 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상을 말한다."
60.0,데이터베이스 트랜잭션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점으로 가장 부적절한 것을 2개 고르시오.,,"1,4",3,"Non-Repeatable Read ： 한 트랜잭션 내에서 같은 쿼리를 두 번 수행 했는데, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상을 말한다."
60.0,데이터베이스 트랜잭션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점으로 가장 부적절한 것을 2개 고르시오.,,"1,4",4,Dirty Read : 다른 트랜잭션에 의해 수정되었고 이미 커밋된 데이터를 읽는 것을 말한다.
70.0,"다음 중 아래와 같은 2건의 데이터상황어서 SQL의 수행 결과로 가장 적절한 것은? (단, 이해를 돕기 위해 ↓ 는 줄바꿈을 의미 → 실제 저장값이 아님, CHR(10) ： ASCII 값 → 줄바꿈을 의미)",,2,1,6
70.0,"다음 중 아래와 같은 2건의 데이터상황어서 SQL의 수행 결과로 가장 적절한 것은? (단, 이해를 돕기 위해 ↓ 는 줄바꿈을 의미 → 실제 저장값이 아님, CHR(10) ： ASCII 값 → 줄바꿈을 의미)",,2,2,5
70.0,"다음 중 아래와 같은 2건의 데이터상황어서 SQL의 수행 결과로 가장 적절한 것은? (단, 이해를 돕기 위해 ↓ 는 줄바꿈을 의미 → 실제 저장값이 아님, CHR(10) ： ASCII 값 → 줄바꿈을 의미)",,2,3,3
70.0,"다음 중 아래와 같은 2건의 데이터상황어서 SQL의 수행 결과로 가장 적절한 것은? (단, 이해를 돕기 위해 ↓ 는 줄바꿈을 의미 → 실제 저장값이 아님, CHR(10) ： ASCII 값 → 줄바꿈을 의미)",,2,4,2
83.0,다음 중 ORDER BY 절에 대한 설명으로 가장 부적절한 것은?,,2,1,GROUP BY 절을 시용하는 경우 ORDER BY 절에 집계 함수를 사용할 수도 있다.
83.0,다음 중 ORDER BY 절에 대한 설명으로 가장 부적절한 것은?,,2,2,"ORDER BY 절에서 컬럼명 대신 Alias 명이나 컬럼 순서를 나타내는 정수도 사용이 가능하나, 이들을 혼용하여 사용할 수 없다."
83.0,다음 중 ORDER BY 절에 대한 설명으로 가장 부적절한 것은?,,2,3,DBMS마다 NULL 값에 대한 정렬 순서가 다를 수 있으므로 주의하여야 한다.
83.0,다음 중 ORDER BY 절에 대한 설명으로 가장 부적절한 것은?,,2,4,SQL 문장으로 조회된 데이터들을 다양한 목적에 맞게 특정 컬럼을 기준으로 정렬하는데 사용한다.
102.0,SET OPERATOR 중에서 수학의 교집합과 같은 가능을 하는 연산자로 가장 적절한 것은?,,3,1,EXCEPT
102.0,SET OPERATOR 중에서 수학의 교집합과 같은 가능을 하는 연산자로 가장 적절한 것은?,,3,2,MINUS
102.0,SET OPERATOR 중에서 수학의 교집합과 같은 가능을 하는 연산자로 가장 적절한 것은?,,3,3,INTERSECT
102.0,SET OPERATOR 중에서 수학의 교집합과 같은 가능을 하는 연산자로 가장 적절한 것은?,,3,4,UNION
106.0,"다음 중 아래와 같은 집합이 존재 할 때, 집합 A와 B에 대하여 집합연산을 수행한 결과 집합 C가 돠는 경우 이용돠는 데이터베이스 집합연산은?","집합 A = {가, 나, 다, 라},
집합 B = {다, 라, 마, 바},
집합 C = {다, 라}",2,1,Product
106.0,"다음 중 아래와 같은 집합이 존재 할 때, 집합 A와 B에 대하여 집합연산을 수행한 결과 집합 C가 돠는 경우 이용돠는 데이터베이스 집합연산은?","집합 A = {가, 나, 다, 라},
집합 B = {다, 라, 마, 바},
집합 C = {다, 라}",2,2,Intersection
106.0,"다음 중 아래와 같은 집합이 존재 할 때, 집합 A와 B에 대하여 집합연산을 수행한 결과 집합 C가 돠는 경우 이용돠는 데이터베이스 집합연산은?","집합 A = {가, 나, 다, 라},
집합 B = {다, 라, 마, 바},
집합 C = {다, 라}",2,3,Difference
106.0,"다음 중 아래와 같은 집합이 존재 할 때, 집합 A와 B에 대하여 집합연산을 수행한 결과 집합 C가 돠는 경우 이용돠는 데이터베이스 집합연산은?","집합 A = {가, 나, 다, 라},
집합 B = {다, 라, 마, 바},
집합 C = {다, 라}",2,4,Union
111.0,다음 중 SELF JOIN을 수행해야 할 경우로 가장 적절한 것은?,,4,1,한 테이블 내에서 연관된 칼럼은 없으나 JOIN을 해야 한다.
111.0,다음 중 SELF JOIN을 수행해야 할 경우로 가장 적절한 것은?,,4,2,두 테이블에 공통 칼럼이 존재하고 두 테이블이 연관 관계가 있다.
