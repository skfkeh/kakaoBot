1,모델링은 현실세계에 대해서 표현하는 것으로 이해할 수 있다. 다음 중 모델링의 특징으로 가장 부적절한 것은?,Unnamed: 2,3,1.1,애매모호함을 배제하고 누구나 이해가 가능하도록 정확하게 현상을 기술하는 정확화의 의미를 가짐
111.0,다음 중 SELF JOIN을 수행해야 할 경우로 가장 적절한 것은?,,4,3,두 테이블에 연관된 칼럼은 없으나 JOIN을 해야 한다.
111.0,다음 중 SELF JOIN을 수행해야 할 경우로 가장 적절한 것은?,,4,4,한 테이블 내에서 두 칼럼이 연관 관계가 있다.
114.0,아래는 서브쿼리에 대한 설명이다. 다음 중 올바른 것끼리 묶인 것은?,"가) 서브쿼리는 단일 행(Single Row) 또는 복수 행 (Multi Row) 비교연산자와 함께 사용할 수 있다.
나) 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절 등에서 사용이 가능하다.
다) 서브쿼리의 결과가 복수 행(Multi Row) 결과를 반환하는 경우에는
'=', '<=', '=〉' 등의 연산자와 함께 사용이 가능하다.
라) 연관(Correlated) 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다.
마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미하며 Oracle 및 SQL Server 등의 DBMS에서 사용 할 수 있다.",3,1,"가,나,마"
114.0,아래는 서브쿼리에 대한 설명이다. 다음 중 올바른 것끼리 묶인 것은?,"가) 서브쿼리는 단일 행(Single Row) 또는 복수 행 (Multi Row) 비교연산자와 함께 사용할 수 있다.
나) 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절 등에서 사용이 가능하다.
다) 서브쿼리의 결과가 복수 행(Multi Row) 결과를 반환하는 경우에는
'=', '<=', '=〉' 등의 연산자와 함께 사용이 가능하다.
라) 연관(Correlated) 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다.
마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미하며 Oracle 및 SQL Server 등의 DBMS에서 사용 할 수 있다.",3,2,"나,다,라"
114.0,아래는 서브쿼리에 대한 설명이다. 다음 중 올바른 것끼리 묶인 것은?,"가) 서브쿼리는 단일 행(Single Row) 또는 복수 행 (Multi Row) 비교연산자와 함께 사용할 수 있다.
나) 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절 등에서 사용이 가능하다.
다) 서브쿼리의 결과가 복수 행(Multi Row) 결과를 반환하는 경우에는
'=', '<=', '=〉' 등의 연산자와 함께 사용이 가능하다.
라) 연관(Correlated) 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다.
마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미하며 Oracle 및 SQL Server 등의 DBMS에서 사용 할 수 있다.",3,3,"가,나,라"
114.0,아래는 서브쿼리에 대한 설명이다. 다음 중 올바른 것끼리 묶인 것은?,"가) 서브쿼리는 단일 행(Single Row) 또는 복수 행 (Multi Row) 비교연산자와 함께 사용할 수 있다.
나) 서브쿼리는 SELECT 절, FROM 절, HAVING 절, ORDER BY 절 등에서 사용이 가능하다.
다) 서브쿼리의 결과가 복수 행(Multi Row) 결과를 반환하는 경우에는
'=', '<=', '=〉' 등의 연산자와 함께 사용이 가능하다.
라) 연관(Correlated) 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리이다.
마) 다중 컬럼 서브쿼리는 서브쿼리의 결과로 여러 개의 컬럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미하며 Oracle 및 SQL Server 등의 DBMS에서 사용 할 수 있다.",3,4,"나,라,마"
181.0,다음 SQL 문장에서 틀린 부분은 어디인가?,,1,1,"SELECT PLAYER, PLAYER_NAME
선수명, TEAM, TEAM_NAME 팀명"
181.0,다음 SQL 문장에서 틀린 부분은 어디인가?,,1,2,"FROM PLAYER P, TEAM T"
181.0,다음 SQL 문장에서 틀린 부분은 어디인가?,,1,3,WHERE P.TEAM_ID = T.TEAM_ID
181.0,다음 SQL 문장에서 틀린 부분은 어디인가?,,1,4,ORDER BY 선수명;
219.0,다음의 SQL문 실행 결과는 무엇인가?,SELECT * FROM dual WHERE NULL = NULL;,1,1,공집합
219.0,다음의 SQL문 실행 결과는 무엇인가?,SELECT * FROM dual WHERE NULL = NULL;,1,2,X
219.0,다음의 SQL문 실행 결과는 무엇인가?,SELECT * FROM dual WHERE NULL = NULL;,1,3,1
219.0,다음의 SQL문 실행 결과는 무엇인가?,SELECT * FROM dual WHERE NULL = NULL;,1,4,
229.0,다음의 내용 중에서 ROWNUM을 올바르게 사용하지 않은 것은?,,2,1,"SELECT DEPTNO FROM EMP
WHERE ROWNUM < 10;"
229.0,다음의 내용 중에서 ROWNUM을 올바르게 사용하지 않은 것은?,,2,2,"SELECT ENAME FROM EMP
WHERE ROWNUM = 2;"
229.0,다음의 내용 중에서 ROWNUM을 올바르게 사용하지 않은 것은?,,2,3,"SELECT EMPNO FROM EMP
WHERE ROWNUM = 1;"
229.0,다음의 내용 중에서 ROWNUM을 올바르게 사용하지 않은 것은?,,2,4,"SELECT ROWNUM, ENAME FROM EMP
WHERE ROWNUM = 2;"
287.0,다음 중 SQL에 대한 설명으로 올바르지 않은 것은?,,3,1,TCL : 트랜잭션을 제어하면 Commit 과 Rollback이 있다.
287.0,다음 중 SQL에 대한 설명으로 올바르지 않은 것은?,,3,2,"DML : 테이블에 데이터를 입력하거나 변경, 삭제한다."
287.0,다음 중 SQL에 대한 설명으로 올바르지 않은 것은?,,3,3,DCL : 데이터베이스의 테이블에 있는 데이터를 변경한다.
287.0,다음 중 SQL에 대한 설명으로 올바르지 않은 것은?,,3,4,DDL : 테이블과 같은 데이터 구조를 정의하거나 변경한다.
318.0,키 엔터티라고도 하며 발생 시점에 따라서 엔터티를 분류할 때 독립적으로 생성되는 엔터티는 무엇인가?,,4,1,종결 엔터티
318.0,키 엔터티라고도 하며 발생 시점에 따라서 엔터티를 분류할 때 독립적으로 생성되는 엔터티는 무엇인가?,,4,2,행위 엔터티
318.0,키 엔터티라고도 하며 발생 시점에 따라서 엔터티를 분류할 때 독립적으로 생성되는 엔터티는 무엇인가?,,4,3,중심 엔터티
318.0,키 엔터티라고도 하며 발생 시점에 따라서 엔터티를 분류할 때 독립적으로 생성되는 엔터티는 무엇인가?,,4,4,기본 엔터티
333.0,다음 SQL문과 동일한 결과를 반환하는 SQL문은?,"select * from Mytest
where (COL1 = 1 and COL2 = 3) or (COL1 = 1 and COL2 = 4);",4,1,select * from Mytest where COL1 = 1 or (COL2 = 3 or COL2 = 4);
333.0,다음 SQL문과 동일한 결과를 반환하는 SQL문은?,"select * from Mytest
where (COL1 = 1 and COL2 = 3) or (COL1 = 1 and COL2 = 4);",4,2,"select * from Mytest where COL1 in (1,3)  or COL2 in (1,4);"
333.0,다음 SQL문과 동일한 결과를 반환하는 SQL문은?,"select * from Mytest
where (COL1 = 1 and COL2 = 3) or (COL1 = 1 and COL2 = 4);",4,3,"select * from Mytest where COL1 in (1,3)  and COL2 in (1,4);"
333.0,다음 SQL문과 동일한 결과를 반환하는 SQL문은?,"select * from Mytest
where (COL1 = 1 and COL2 = 3) or (COL1 = 1 and COL2 = 4);",4,4,select * from Mytest where COL1 = 1 and  (COL2 = 3 or COL2 = 4);
355.0,다음 SQL문의 실행 결과는?,"SELECT COALESCE(nullif(1,1),200,300) as data from dual;",3,1,400
355.0,다음 SQL문의 실행 결과는?,"SELECT COALESCE(nullif(1,1),200,300) as data from dual;",3,2,300
355.0,다음 SQL문의 실행 결과는?,"SELECT COALESCE(nullif(1,1),200,300) as data from dual;",3,3,200
355.0,다음 SQL문의 실행 결과는?,"SELECT COALESCE(nullif(1,1),200,300) as data from dual;",3,4,100
362.0,다음은 주식별자에 대한 설명이다. 올바르지 않은 것은?,,1,1,자주 변경되는 값을 주식별자로 지정해야 한다.
362.0,다음은 주식별자에 대한 설명이다. 올바르지 않은 것은?,,1,2,계좌번호와 고객번호를 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 한다.
362.0,다음은 주식별자에 대한 설명이다. 올바르지 않은 것은?,,1,3,"명칭, 내역 등과 같이 이름으로 기술되는 것들은 주식별자로 지정하지 않는다."
362.0,다음은 주식별자에 대한 설명이다. 올바르지 않은 것은?,,1,4,어떤 업무에서 자주 이용되는 것을 주식별자로 한다.
371.0,"야구선수 테이블에서 선수명과 팀명은 오름차순, 연봉은 내림차순으로 정렬하는 결괏값을 반환하는 SQL문은?(단, 야구선수 테이블은 칼럼이 선수명, 팀명, 연봉 순으로 구성)",,4,1,"SELECT * FROM 야구선수 ORDER BY 선수명, 팀명, DESC, 연봉 ASC"
371.0,"야구선수 테이블에서 선수명과 팀명은 오름차순, 연봉은 내림차순으로 정렬하는 결괏값을 반환하는 SQL문은?(단, 야구선수 테이블은 칼럼이 선수명, 팀명, 연봉 순으로 구성)",,4,2,"SELECT * FROM 야구선수 ORDER BY 선수명 ASC, 팀명, ASC, 연봉 ASC"
371.0,"야구선수 테이블에서 선수명과 팀명은 오름차순, 연봉은 내림차순으로 정렬하는 결괏값을 반환하는 SQL문은?(단, 야구선수 테이블은 칼럼이 선수명, 팀명, 연봉 순으로 구성)",,4,3,"SELECT * FROM 야구선수 ORDER BY 선수명 DESC, 팀명, DESC, 연봉 ASC"
371.0,"야구선수 테이블에서 선수명과 팀명은 오름차순, 연봉은 내림차순으로 정렬하는 결괏값을 반환하는 SQL문은?(단, 야구선수 테이블은 칼럼이 선수명, 팀명, 연봉 순으로 구성)",,4,4,"SELECT * FROM 야구선수 ORDER BY 선수명 ASC, 팀명, 3 DESC"
373.0,다음 중 NULL 값을 반환하는 쿼리는 어떤 것인가?,,3,1,"SELECT NVL(null,'B') FROM DUAL"
373.0,다음 중 NULL 값을 반환하는 쿼리는 어떤 것인가?,,3,2,"SELECT NVL(null,0)+10 FROM DUAL"
373.0,다음 중 NULL 값을 반환하는 쿼리는 어떤 것인가?,,3,3,"SELECT NULLIF('B','B') FROM DUAL"
373.0,다음 중 NULL 값을 반환하는 쿼리는 어떤 것인가?,,3,4,"SELECT COALESCE(NULL,'20') FROM DUAL"
378.0,트랜잭션이 가지는 특징에 해당되지 않는 것은?,,1,1,통합성
378.0,트랜잭션이 가지는 특징에 해당되지 않는 것은?,,1,2,고립성
378.0,트랜잭션이 가지는 특징에 해당되지 않는 것은?,,1,3,일관성
378.0,트랜잭션이 가지는 특징에 해당되지 않는 것은?,,1,4,원자성
389.0,다음 중 반올림을 수행하는 함수는?,,4,1,NULLIF
389.0,다음 중 반올림을 수행하는 함수는?,,4,2,TRUNC
389.0,다음 중 반올림을 수행하는 함수는?,,4,3,CEIL
389.0,다음 중 반올림을 수행하는 함수는?,,4,4,ROUND
391.0,다음 중 ORDER BY에 대한 특징으로 옳지 않은 것은?,,1,1,ORDER BY 칼럼명에서 정렬 옵션을 주지 않은 경우에 내림차순이 된다.
391.0,다음 중 ORDER BY에 대한 특징으로 옳지 않은 것은?,,1,2,ORACLE은 NULL을 가장 큰 값으로 취급하고 SQL SERVER는 가장 작은 값으로 취급한다.
391.0,다음 중 ORDER BY에 대한 특징으로 옳지 않은 것은?,,1,3,SELECT 구문에 사용되지 않은 칼럼에도 ORDER BY 구문에서 사용할 수 있다.
391.0,다음 중 ORDER BY에 대한 특징으로 옳지 않은 것은?,,1,4,ORDER BY 속성에 숫자와 칼럼을 혼용하여 사용할 수 있다.
425.0,다음 SQL문 중에서 결괏값이 다른 하나는?,,3,1,"SELECT CONCAT('AB', 'CD') FROM DUAL;"
425.0,다음 SQL문 중에서 결괏값이 다른 하나는?,,3,2,"SELECT SUBSTR('ABCABCDED', 4, 4) FROM DUAL;"
425.0,다음 SQL문 중에서 결괏값이 다른 하나는?,,3,3,SELECT RTRIM(' ABCD') FROM DUAL;
425.0,다음 SQL문 중에서 결괏값이 다른 하나는?,,3,4,SELECT UPPER('abcd') FROM DUAL;
442.0,다음 중 3차 정규화에 대한 설명으로 올바른 것은?,,1,1,이행함수 종속성을 제거한다.
442.0,다음 중 3차 정규화에 대한 설명으로 올바른 것은?,,1,2,조인으로 발생하는 종속성을 제거한다.
442.0,다음 중 3차 정규화에 대한 설명으로 올바른 것은?,,1,3,기본키가 하나 이상의 키로 되어 있는 경우에 부분함수 종속성을 제거한다.
442.0,다음 중 3차 정규화에 대한 설명으로 올바른 것은?,,1,4,해당 릴레이션에 기본키를 식별한다.
453.0,다음의 설명에 해당하는 join은?,조인되는 N개의 테이블을 모두 정렬한 후에 조인을 수행한다.,3,1,INNER JOIN
453.0,다음의 설명에 해당하는 join은?,조인되는 N개의 테이블을 모두 정렬한 후에 조인을 수행한다.,3,2,NESTED LOOP JOIN
453.0,다음의 설명에 해당하는 join은?,조인되는 N개의 테이블을 모두 정렬한 후에 조인을 수행한다.,3,3,SORT MERGE JOIN
453.0,다음의 설명에 해당하는 join은?,조인되는 N개의 테이블을 모두 정렬한 후에 조인을 수행한다.,3,4,HASH JOIN
465.0,다음 보기의 Sub Query 유형은 무엇인가?,"SELECT A.EMPNO, A.ENAME
FROM EMP A
WHERE A.EMPNO=(SELECT 1 FROM EMP_T B WHERE A.EMPNO = B.EMPNO);",2,1,Looping Sub Query
465.0,다음 보기의 Sub Query 유형은 무엇인가?,"SELECT A.EMPNO, A.ENAME
FROM EMP A
WHERE A.EMPNO=(SELECT 1 FROM EMP_T B WHERE A.EMPNO = B.EMPNO);",2,2,Correlated Sub Query
465.0,다음 보기의 Sub Query 유형은 무엇인가?,"SELECT A.EMPNO, A.ENAME
FROM EMP A
WHERE A.EMPNO=(SELECT 1 FROM EMP_T B WHERE A.EMPNO = B.EMPNO);",2,3,Early Filter형 Sub Query
465.0,다음 보기의 Sub Query 유형은 무엇인가?,"SELECT A.EMPNO, A.ENAME
FROM EMP A
WHERE A.EMPNO=(SELECT 1 FROM EMP_T B WHERE A.EMPNO = B.EMPNO);",2,4,Service Sub Query
468.0,다음은 NULL 값에 대한 설명이다. 올바른 것은?,,1,1,NULL 값은 아직 알려지지 않은 미지의 값이다.
468.0,다음은 NULL 값에 대한 설명이다. 올바른 것은?,,1,2,ORACLE에서 NULL은 TRUE 혹은 FALSE의 의미이다.
468.0,다음은 NULL 값에 대한 설명이다. 올바른 것은?,,1,3,MS-SQL에서 NULL 값은 0이다.
468.0,다음은 NULL 값에 대한 설명이다. 올바른 것은?,,1,4,데이터베이스의 NULL 값의 의미는 DBMS 종류별로 다르게 해석한다.
525.0,다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?,"한림대학교 성심병원은 상급종합병원이고 국내에는 약 43개의 상급종합병원이 있다. 상급종합병원에서 진료를 받기 위해서는 예약을 해야 한다. 예약을 하기 위해서 환자로 등록해야 하는데, 환자 등록을 위해서는 환자이름, 주소, 전화번호, 나이, 최근 병력 등의 정보를 한림대학교 성심병원 웹사이트에 접속해서 입력해야 한다.",3,1,주소
525.0,다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?,"한림대학교 성심병원은 상급종합병원이고 국내에는 약 43개의 상급종합병원이 있다. 상급종합병원에서 진료를 받기 위해서는 예약을 해야 한다. 예약을 하기 위해서 환자로 등록해야 하는데, 환자 등록을 위해서는 환자이름, 주소, 전화번호, 나이, 최근 병력 등의 정보를 한림대학교 성심병원 웹사이트에 접속해서 입력해야 한다.",3,2,이름
525.0,다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?,"한림대학교 성심병원은 상급종합병원이고 국내에는 약 43개의 상급종합병원이 있다. 상급종합병원에서 진료를 받기 위해서는 예약을 해야 한다. 예약을 하기 위해서 환자로 등록해야 하는데, 환자 등록을 위해서는 환자이름, 주소, 전화번호, 나이, 최근 병력 등의 정보를 한림대학교 성심병원 웹사이트에 접속해서 입력해야 한다.",3,3,환자
525.0,다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?,"한림대학교 성심병원은 상급종합병원이고 국내에는 약 43개의 상급종합병원이 있다. 상급종합병원에서 진료를 받기 위해서는 예약을 해야 한다. 예약을 하기 위해서 환자로 등록해야 하는데, 환자 등록을 위해서는 환자이름, 주소, 전화번호, 나이, 최근 병력 등의 정보를 한림대학교 성심병원 웹사이트에 접속해서 입력해야 한다.",3,4,나이
529.0,다음은 데이터베이스 모델링 시에 성능을 고려한 모델링 활동이다. 성능을 고려한 데이터베이스 모델링 단계에서 가장 처음으로 수행해야 할 것과 가장 마지막으로 수행해야 할 것은? ,"가. 데이터베이스 모델링 시에 정규화를 수행한다.
나. 테이블에서 보관하는 데이터 용량과 트랜잭션의 유형에 따라서 반정규화를 한다.
다. 트랜잭션의 유형을 분석한다.
라. 데이터베이스 전체 용량을 산정해야 한다.
마. 성능관점에서 데이터 모델을 검증하고 확인한다.
바. 기본키와 외래키를 조정하거나, 슈퍼타입과 서브타입을 조정한다.",1,1,"가,마"
529.0,다음은 데이터베이스 모델링 시에 성능을 고려한 모델링 활동이다. 성능을 고려한 데이터베이스 모델링 단계에서 가장 처음으로 수행해야 할 것과 가장 마지막으로 수행해야 할 것은? ,"가. 데이터베이스 모델링 시에 정규화를 수행한다.
나. 테이블에서 보관하는 데이터 용량과 트랜잭션의 유형에 따라서 반정규화를 한다.
다. 트랜잭션의 유형을 분석한다.
라. 데이터베이스 전체 용량을 산정해야 한다.
마. 성능관점에서 데이터 모델을 검증하고 확인한다.
바. 기본키와 외래키를 조정하거나, 슈퍼타입과 서브타입을 조정한다.",1,2,"다,라"
529.0,다음은 데이터베이스 모델링 시에 성능을 고려한 모델링 활동이다. 성능을 고려한 데이터베이스 모델링 단계에서 가장 처음으로 수행해야 할 것과 가장 마지막으로 수행해야 할 것은? ,"가. 데이터베이스 모델링 시에 정규화를 수행한다.
나. 테이블에서 보관하는 데이터 용량과 트랜잭션의 유형에 따라서 반정규화를 한다.
다. 트랜잭션의 유형을 분석한다.
라. 데이터베이스 전체 용량을 산정해야 한다.
마. 성능관점에서 데이터 모델을 검증하고 확인한다.
바. 기본키와 외래키를 조정하거나, 슈퍼타입과 서브타입을 조정한다.",1,3,"다,마"
529.0,다음은 데이터베이스 모델링 시에 성능을 고려한 모델링 활동이다. 성능을 고려한 데이터베이스 모델링 단계에서 가장 처음으로 수행해야 할 것과 가장 마지막으로 수행해야 할 것은? ,"가. 데이터베이스 모델링 시에 정규화를 수행한다.
나. 테이블에서 보관하는 데이터 용량과 트랜잭션의 유형에 따라서 반정규화를 한다.
다. 트랜잭션의 유형을 분석한다.
라. 데이터베이스 전체 용량을 산정해야 한다.
마. 성능관점에서 데이터 모델을 검증하고 확인한다.
바. 기본키와 외래키를 조정하거나, 슈퍼타입과 서브타입을 조정한다.",1,4,"가,나"
549.0,다음 중 TEST 사용자가 아래의 작업을 수행할 수 있도록 권한을 부여하는 DCL로 올바른 것은?,"UPDATE A_User.TB_A
SET col1='TEST'
WHERE col2=100;",1,1,"GRANT SELECT, UPDATE ON A_User, TB_A TO TEST;"
549.0,다음 중 TEST 사용자가 아래의 작업을 수행할 수 있도록 권한을 부여하는 DCL로 올바른 것은?,"UPDATE A_User.TB_A
SET col1='TEST'
WHERE col2=100;",1,2,"REVOKE UPDATE ON A_User, TB_A TO TEST;"
549.0,다음 중 TEST 사용자가 아래의 작업을 수행할 수 있도록 권한을 부여하는 DCL로 올바른 것은?,"UPDATE A_User.TB_A
SET col1='TEST'
WHERE col2=100;",1,3,"REVOKE SELECT ON A_User, TB_A FROM TEST;"
549.0,다음 중 TEST 사용자가 아래의 작업을 수행할 수 있도록 권한을 부여하는 DCL로 올바른 것은?,"UPDATE A_User.TB_A
SET col1='TEST'
WHERE col2=100;",1,4,GRANT UPDATE TO TEST;
569.0,3층 스키마의 데이터베이스를 보는 관점이 아닌 사람은?,,2,1,사용자
569.0,3층 스키마의 데이터베이스를 보는 관점이 아닌 사람은?,,2,2,구조자
569.0,3층 스키마의 데이터베이스를 보는 관점이 아닌 사람은?,,2,3,설계자
569.0,3층 스키마의 데이터베이스를 보는 관점이 아닌 사람은?,,2,4,개발자
578.0,트랜잭션의 특징 중 보기는 무엇을 설명하고 있는가?,트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.,3,1,지속성
578.0,트랜잭션의 특징 중 보기는 무엇을 설명하고 있는가?,트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.,3,2,고립성
578.0,트랜잭션의 특징 중 보기는 무엇을 설명하고 있는가?,트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.,3,3,일관성
578.0,트랜잭션의 특징 중 보기는 무엇을 설명하고 있는가?,트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.,3,4,원자성
625.0,데이터 모델링에서 식별자 관계에 대한 설명 중 가장 적절하지 않은 것은? ,,2,1,자식 엔터티의 식별자가 부모 엔터티의 주식별자를 상속받아 생성하는 것보다 별도의 주식별자를 생성하는 것 이 더 유리하다고 판단되는 경우 비식별자 관계로 연결해야 한다.
625.0,데이터 모델링에서 식별자 관계에 대한 설명 중 가장 적절하지 않은 것은? ,,2,2,비식별 관계는 부모 엔터티가 소멸하면 자식 엔터티도 종속적으로 삭제되는 관계이다.
625.0,데이터 모델링에서 식별자 관계에 대한 설명 중 가장 적절하지 않은 것은? ,,2,3,"IE 표기법에서는 식별 관계는 실선으로, 비식별 관계는 점선으로 표시한다."
625.0,데이터 모델링에서 식별자 관계에 대한 설명 중 가장 적절하지 않은 것은? ,,2,4,식별 관계는 하나의 엔터티의 기본키를 다른 엔터티가 기본키의 하나로 공유하는 관계이다.
661.0,"계층형 질의에서 CONNECT BY 절에 사용되며, 현재 읽은 컬럼을 지정하는 구문은 무엇인가?",,3,1,ORDER SIBLINGS BY
661.0,"계층형 질의에서 CONNECT BY 절에 사용되며, 현재 읽은 컬럼을 지정하는 구문은 무엇인가?",,3,2,NOCYCLE
661.0,"계층형 질의에서 CONNECT BY 절에 사용되며, 현재 읽은 컬럼을 지정하는 구문은 무엇인가?",,3,3,PRIOR
661.0,"계층형 질의에서 CONNECT BY 절에 사용되며, 현재 읽은 컬럼을 지정하는 구문은 무엇인가?",,3,4,START WITH
673.0,속성에 대한 설명으로 가장 적절하지 않은 것은?,,1,1,엔터티에 속한 속성은 엔터티에 대한 추상적인 값을 갖는다.
673.0,속성에 대한 설명으로 가장 적절하지 않은 것은?,,1,2,업무상 인스턴스로 관리하고자 하는 더 이상 분리되지 않는 최소의 데이터 단위를 말한다.
673.0,속성에 대한 설명으로 가장 적절하지 않은 것은?,,1,3,정해진 주식별자에 함수적 종속성을 가져야 한다.
673.0,속성에 대한 설명으로 가장 적절하지 않은 것은?,,1,4,하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 엔터티를 이용하여 분리한다.
693.0,"다음 중 에러가 나지 않는 문장은? (단, DBMS는 오라클)",,1,1,"SELECT COL1 AS 컬럼1, AVG(COL2) AS 평균 
    FROM TAB1 
   GROUP BY COL1 
   HAVING AVG(COL2) >= 100;"
693.0,"다음 중 에러가 나지 않는 문장은? (단, DBMS는 오라클)",,1,2,"SELECT COL1 AS 컬럼1, AVG(COL2) AS 평균 
    FROM TAB1 
   WHERE AVG(COL2) >= 100 
   GROUP BY 컬럼1;"
693.0,"다음 중 에러가 나지 않는 문장은? (단, DBMS는 오라클)",,1,3,"SELECT COL1 컬럼1, AVG(COL2) 평균 
    FROM TAB1 
   GROUP BY COL2;"
693.0,"다음 중 에러가 나지 않는 문장은? (단, DBMS는 오라클)",,1,4,"SELECT COL1 컬럼1, AVG(COL2) 평 균 
    FROM TAB1;"
716.0,제약조건의 설명 중 가장 적절하지 않은 것은?  ,,2,1,NOT NULL 은 NULL 값의 삽입을 금지한다.
716.0,제약조건의 설명 중 가장 적절하지 않은 것은?  ,,2,2,기본키는 고유키와 외래키 제약을 합쳐놓은 것이다.
716.0,제약조건의 설명 중 가장 적절하지 않은 것은?  ,,2,3,테이블에 저장된 행 데이터를 고유하게 식별하기 위해 고유키를 정의한다.
716.0,제약조건의 설명 중 가장 적절하지 않은 것은?  ,,2,4,기본키는 테이블에 저장된 행 데이터를 고유하게 식별하기 위한 키이다.
731.0,테이블에 대한 설명 중 가장 적절한 것은?,,3,1,"테이블 생성 시 각 컬럼의 데이터 유형을 정의할 수 있고, 생성 이후에는 변경이 불가하다."
731.0,테이블에 대한 설명 중 가장 적절한 것은?,,3,2,하나의 행의 하나의 컬럼에는 둘 이상의 값이 삽입될 수 있다.
731.0,테이블에 대한 설명 중 가장 적절한 것은?,,3,3,"테이블명은 중복될 수 없지만, 소유자가 다른 경우 같은 이름으로 생성 가능하다."
731.0,테이블에 대한 설명 중 가장 적절한 것은?,,3,4,같은 테이블을 동시에 두 계정으로 소유할 수 있다.
733.0,"다음 중 SELECT문에 대한 설명으로 가장 적절하지 않은 것은? (단, DBMS는 오라클)",,2,1,일반적으로 SELECT 절에서는 * 와 컬럼명을 동시에 사용할 수 없다.
733.0,"다음 중 SELECT문에 대한 설명으로 가장 적절하지 않은 것은? (단, DBMS는 오라클)",,2,2,GROUP BY 절은 NULL 그룹을 출력하지 않는다.
733.0,"다음 중 SELECT문에 대한 설명으로 가장 적절하지 않은 것은? (단, DBMS는 오라클)",,2,3,FROM 절은 생략 불가하다.
733.0,"다음 중 SELECT문에 대한 설명으로 가장 적절하지 않은 것은? (단, DBMS는 오라클)",,2,4,실행 순서는 FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY 순 이다.
738.0,다음 SQL의 실행 결과에 대한 해석으로 가장 적절한 것은?,"SELECT NEXT_DAY(ADD_MONTHS(HIREDATE, 6),'월요일') FROM EMP;",2,1,각 직원의 입사날짜로부터 6개월 후 두 번째 월요일에 해당하는 날짜
738.0,다음 SQL의 실행 결과에 대한 해석으로 가장 적절한 것은?,"SELECT NEXT_DAY(ADD_MONTHS(HIREDATE, 6),'월요일') FROM EMP;",2,2,각 직원의 입사날짜로부터 6개월 후 첫 번째 월요일에 해당하는 날짜
738.0,다음 SQL의 실행 결과에 대한 해석으로 가장 적절한 것은?,"SELECT NEXT_DAY(ADD_MONTHS(HIREDATE, 6),'월요일') FROM EMP;",2,3,각 직원의 입사날짜로부터 6일 후 두 번째 월요일에 해당하는 날짜
738.0,다음 SQL의 실행 결과에 대한 해석으로 가장 적절한 것은?,"SELECT NEXT_DAY(ADD_MONTHS(HIREDATE, 6),'월요일') FROM EMP;",2,4,각 직원의 입사날짜로부터 6일 후 첫 번째 월요일에 해당하는 날짜
242.0,다음 설명 중 옳지 않은 것은?,,4,1,서브쿼리는 Order by절에 사용할 수 있다.
242.0,다음 설명 중 옳지 않은 것은?,,4,2,View는 실제 데이터를 가지고 있지 않는다.
242.0,다음 설명 중 옳지 않은 것은?,,4,3,Natural Join에 해당하는 칼럼은 테이블의 칼럼명이 동일하다.
242.0,다음 설명 중 옳지 않은 것은?,,4,4,Union 과 Union ALL은 성능 차이가 없다.
258.0,다음의 SQL문을 CASE문을 사용해서 변경하시오.,"SELECT DECODE(EMPNO, 1, 'A', 'B') FROM EMP;",3,1,SELECT CASE EMPNO WHEN 'A' ELSE 'B' END FROM EMP;
258.0,다음의 SQL문을 CASE문을 사용해서 변경하시오.,"SELECT DECODE(EMPNO, 1, 'A', 'B') FROM EMP;",3,2,SELECT CASE EMPNO WHEN 1 THEN 'B' ELSE 'A' END FROM EMP;
258.0,다음의 SQL문을 CASE문을 사용해서 변경하시오.,"SELECT DECODE(EMPNO, 1, 'A', 'B') FROM EMP;",3,3,SELECT CASE EMPNO WHEN 1 THEN 'A' ELSE 'B' END FROM EMP;
258.0,다음의 SQL문을 CASE문을 사용해서 변경하시오.,"SELECT DECODE(EMPNO, 1, 'A', 'B') FROM EMP;",3,4,SELECT CASE EMPNO WHEN 'A' THEN 'B' END FROM EMP;
269.0,다음 중 카디널리티를 계산하는 식으로 올바른 것은?,,2,1,Blevel * 전체 레코드 수
269.0,다음 중 카디널리티를 계산하는 식으로 올바른 것은?,,2,2,선택도 * 전체 레코드 수
269.0,다음 중 카디널리티를 계산하는 식으로 올바른 것은?,,2,3,0.5 * 전체 레코드 수
269.0,다음 중 카디널리티를 계산하는 식으로 올바른 것은?,,2,4,2 * 전체 레코드 수
535.0,다음 보기에서 SELECT 결과가 NULL이 아닌 경우는?,,4,1,"SELECT NULLIF('A','A') FROM DUAL;"
535.0,다음 보기에서 SELECT 결과가 NULL이 아닌 경우는?,,4,2,"SELECT DECODE('A','B','C',NULL) FROM DUAL;"
535.0,다음 보기에서 SELECT 결과가 NULL이 아닌 경우는?,,4,3,SELECT CASE 0 WHEN 1 THEN 2 ELSE NULL END FROM DUAL;
535.0,다음 보기에서 SELECT 결과가 NULL이 아닌 경우는?,,4,4,"SELECT COLAESCE(1,2,3) FROM DUAL;"
801.0,다음 중 데이터 모델링의 가장 주요한 목적은 무엇인가?,,3,1,데이터를 시각화하는 것
801.0,다음 중 데이터 모델링의 가장 주요한 목적은 무엇인가?,,3,2,데이터를 저장하는 것
801.0,다음 중 데이터 모델링의 가장 주요한 목적은 무엇인가?,,3,3,업무를 분석하고 시스템 구조를 설계하는 것
801.0,다음 중 데이터 모델링의 가장 주요한 목적은 무엇인가?,,3,4,데이터를 암호화하는 것
810.0,비식별 관계에서 자식 엔터티의 기본키 구성은?,,4,1,부모 엔터티의 키만으로 구성
810.0,비식별 관계에서 자식 엔터티의 기본키 구성은?,,4,2,자식 고유 키만 사용
810.0,비식별 관계에서 자식 엔터티의 기본키 구성은?,,4,3,부모와 무관한 외래 키
810.0,비식별 관계에서 자식 엔터티의 기본키 구성은?,,4,4,외래 키는 포함하지만 기본키에는 포함되지 않음
814.0,제2정규형(2NF)에서 제거해야 하는 종속성은?,,1,1,부분 함수 종속
814.0,제2정규형(2NF)에서 제거해야 하는 종속성은?,,1,2,중복 레코드
814.0,제2정규형(2NF)에서 제거해야 하는 종속성은?,,1,3,이행적 종속
814.0,제2정규형(2NF)에서 제거해야 하는 종속성은?,,1,4,기본키
11.0,다음 중 엔터티의 일반적인 특징으로 가장 부적절한 것은?,,4,1,엔터티는 반드시 속성을 포함해야 한다.
11.0,다음 중 엔터티의 일반적인 특징으로 가장 부적절한 것은?,,4,2,엔터티는 업무 프로세스에 의해 이용되어야 한다.
11.0,다음 중 엔터티의 일반적인 특징으로 가장 부적절한 것은?,,4,3,유일한 식별자에 의해 식별이 가능해야 한다.
11.0,다음 중 엔터티의 일반적인 특징으로 가장 부적절한 것은?,,4,4,다른 엔터티와의 관계를 가지지 않는다.
17.0,다음 중 아래 설명이 나타내는 데이터모델의 개념으로 가장 적절한 것은?,"주문이라는 엔터티가 있을 때 단가라는 속성 값의 범위는 100에서 10,000 사이의 실수 값이며 제품명이라는 속성은 길이가 20자리 이내의 문자열로 정의할 수 있다.",1,1,도메인(Domain)
17.0,다음 중 아래 설명이 나타내는 데이터모델의 개념으로 가장 적절한 것은?,"주문이라는 엔터티가 있을 때 단가라는 속성 값의 범위는 100에서 10,000 사이의 실수 값이며 제품명이라는 속성은 길이가 20자리 이내의 문자열로 정의할 수 있다.",1,2,속성사전(Attribute Dictionary)
17.0,다음 중 아래 설명이 나타내는 데이터모델의 개념으로 가장 적절한 것은?,"주문이라는 엔터티가 있을 때 단가라는 속성 값의 범위는 100에서 10,000 사이의 실수 값이며 제품명이라는 속성은 길이가 20자리 이내의 문자열로 정의할 수 있다.",1,3,용어사전(Word Dictionary)
17.0,다음 중 아래 설명이 나타내는 데이터모델의 개념으로 가장 적절한 것은?,"주문이라는 엔터티가 있을 때 단가라는 속성 값의 범위는 100에서 10,000 사이의 실수 값이며 제품명이라는 속성은 길이가 20자리 이내의 문자열로 정의할 수 있다.",1,4,시스템카탈로그(System Catalog)
44.0,다음 중 NULL의 설명으로 가장 부적절한 것은?,,2,1,NULL과의 모든 비교 (IS NULL 제외)는 알 수 없음 (Unknown) 을 반환한다.
44.0,다음 중 NULL의 설명으로 가장 부적절한 것은?,,2,2,공백문자 (Empty String)  혹은 숫자 0을 의미한다.
44.0,다음 중 NULL의 설명으로 가장 부적절한 것은?,,2,3,값의 부재를 의미한다.
44.0,다음 중 NULL의 설명으로 가장 부적절한 것은?,,2,4,모르는 값을 의미한다.
49.0,다음 중 외래키에 대한 설명으로 가장 부적절한 것을 2개 고르시오.,,"2,3",1,외래키 값은 참조 무결성 제약을 받을 수 있다.
49.0,다음 중 외래키에 대한 설명으로 가장 부적절한 것을 2개 고르시오.,,"2,3",2,한 테이블에 하나만 존재해야 한다.
49.0,다음 중 외래키에 대한 설명으로 가장 부적절한 것을 2개 고르시오.,,"2,3",3,외래키 값은 널 값을 가질 수 없다.
49.0,다음 중 외래키에 대한 설명으로 가장 부적절한 것을 2개 고르시오.,,"2,3",4,테이블 생성시 설정할 수 있다.
50.0,다음 중 데이터베이스 테이블의 제약조건(Constraint)에 대한 설명으로 가장 부적절한 것은?,,2,1,외래키(Foreign Key)는 테이블간의 관계를 정의하기 위해 기본키(Primary Key)를 다른 테이블의 외래키가 참조하도록 생성한다.
50.0,다음 중 데이터베이스 테이블의 제약조건(Constraint)에 대한 설명으로 가장 부적절한 것은?,,2,2,고유키(Unique Key)로 지정된 모든 컬럼들은 Null 값을 가질 수 없다
50.0,다음 중 데이터베이스 테이블의 제약조건(Constraint)에 대한 설명으로 가장 부적절한 것은?,,2,3,기본키(Primary Key)는 반드시 테이블 당 하나의 제약만을 정의할 수 있다.
50.0,다음 중 데이터베이스 테이블의 제약조건(Constraint)에 대한 설명으로 가장 부적절한 것은?,,2,4,Check 제약조건(Constraint)은 데이터베이스에서 데이터의 무결성을 유지하기 위하여 테이블의 특정 컬럼(Column)에 설정하는 제약이다.
66.0,"아래와 같은 DDL 문장으로 테이블 생성하고, SQL들을 수행하였을 때 다음 설명 중 옳은 것은?","CREATE TABLE 서비스
(서비스번호 VARCHAR2(10) PRIMARY KEY, 
서비스명 VARCHAR2(100) NULL,
개시일자 DATE NOT NULL  ); 
 [SQL]
(ㄱ)SELECT * FROM 서비스 WHERE 서비스번호 = 1；
(ㄴ)INSERT INTO 서비스 VALUES ('999', "", '2015-11-11')；
(ㄷ)SELECT * FROM 서비스 WHERE 서비스명 = ''；
(ㄹ) SELECT * FROM 서비스 WHERE 서비스명 IS NULL；",1,1,"SQL Server에서 (ㄴ)과같이 데이터를 입력하고, (ㄹ)과 같이 조회하였을 때, 데이터는 조회되지 않는다."
66.0,"아래와 같은 DDL 문장으로 테이블 생성하고, SQL들을 수행하였을 때 다음 설명 중 옳은 것은?","CREATE TABLE 서비스
(서비스번호 VARCHAR2(10) PRIMARY KEY, 
서비스명 VARCHAR2(100) NULL,
개시일자 DATE NOT NULL  ); 
 [SQL]
(ㄱ)SELECT * FROM 서비스 WHERE 서비스번호 = 1；
(ㄴ)INSERT INTO 서비스 VALUES ('999', "", '2015-11-11')；
(ㄷ)SELECT * FROM 서비스 WHERE 서비스명 = ''；
(ㄹ) SELECT * FROM 서비스 WHERE 서비스명 IS NULL；",1,2,"ORACLE에서 (ㄴ)과같이 데이터를 입력하고, (ㄷ)과 같이 조회하였을 때, 데이터는 조회된다."
66.0,"아래와 같은 DDL 문장으로 테이블 생성하고, SQL들을 수행하였을 때 다음 설명 중 옳은 것은?","CREATE TABLE 서비스
(서비스번호 VARCHAR2(10) PRIMARY KEY, 
서비스명 VARCHAR2(100) NULL,
개시일자 DATE NOT NULL  ); 
 [SQL]
(ㄱ)SELECT * FROM 서비스 WHERE 서비스번호 = 1；
(ㄴ)INSERT INTO 서비스 VALUES ('999', "", '2015-11-11')；
(ㄷ)SELECT * FROM 서비스 WHERE 서비스명 = ''；
(ㄹ) SELECT * FROM 서비스 WHERE 서비스명 IS NULL；",1,3,"ORACLE에서 (ㄴ)과같이 데이터를 입력하였을 때, 서비스명 컬럼에 공백문자 데이터가 입력된다."
66.0,"아래와 같은 DDL 문장으로 테이블 생성하고, SQL들을 수행하였을 때 다음 설명 중 옳은 것은?","CREATE TABLE 서비스
(서비스번호 VARCHAR2(10) PRIMARY KEY, 
서비스명 VARCHAR2(100) NULL,
개시일자 DATE NOT NULL  ); 
 [SQL]
(ㄱ)SELECT * FROM 서비스 WHERE 서비스번호 = 1；
(ㄴ)INSERT INTO 서비스 VALUES ('999', "", '2015-11-11')；
(ㄷ)SELECT * FROM 서비스 WHERE 서비스명 = ''；
(ㄹ) SELECT * FROM 서비스 WHERE 서비스명 IS NULL；",1,4,서비스번호 컬럼에 모든 레코드 중에서 ‘001’과 같은 숫자형식으로 하나의 레코드만이라도 입력되어 (ㄱ)은 오류 없이 실행된다.
69.0,아래와 같은 내장 함수에 대한 설명 중에서 옳은 것을 모두 묶은 것은?,"가) 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분할 수 있다.
나) 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET 절에 사용이 가능하다.
다) 1：M 관계의 두 테이블을 조인할 경우 이쪽에 다중행이 출력되므로 단일행 함수는 사용할 수 없다.
라) 단일행 함수는 다중행 함수와 다르게 여러 개의 인수가 입력 되어도 단일 값만을 반환한다.",3,1,"가,나,다,라"
69.0,아래와 같은 내장 함수에 대한 설명 중에서 옳은 것을 모두 묶은 것은?,"가) 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분할 수 있다.
나) 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET 절에 사용이 가능하다.
다) 1：M 관계의 두 테이블을 조인할 경우 이쪽에 다중행이 출력되므로 단일행 함수는 사용할 수 없다.
라) 단일행 함수는 다중행 함수와 다르게 여러 개의 인수가 입력 되어도 단일 값만을 반환한다.",3,2,"가,나,다"
69.0,아래와 같은 내장 함수에 대한 설명 중에서 옳은 것을 모두 묶은 것은?,"가) 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분할 수 있다.
나) 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET 절에 사용이 가능하다.
다) 1：M 관계의 두 테이블을 조인할 경우 이쪽에 다중행이 출력되므로 단일행 함수는 사용할 수 없다.
라) 단일행 함수는 다중행 함수와 다르게 여러 개의 인수가 입력 되어도 단일 값만을 반환한다.",3,3,"가,나"
69.0,아래와 같은 내장 함수에 대한 설명 중에서 옳은 것을 모두 묶은 것은?,"가) 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분할 수 있다.
나) 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET 절에 사용이 가능하다.
다) 1：M 관계의 두 테이블을 조인할 경우 이쪽에 다중행이 출력되므로 단일행 함수는 사용할 수 없다.
라) 단일행 함수는 다중행 함수와 다르게 여러 개의 인수가 입력 되어도 단일 값만을 반환한다.",3,4,가
72.0,"팀별 포지션별 FW, MF, DF, GK 포지션의 인원수와 팀별 전체 인원수를 SQL을 작성할 때 결과가 다른 것은? (보기 1은 SQL Server 환경이고, 보기 2,3,4는 ORACLE 환경이다.)",,1,1,"SELECT TEAM_ID,
 NVL(SUM(CASE  POSITION WHEN 'FW' THEN 1 ELSE 1 END), 0) FW,
 NVL(SUM(CASE  POSITION WHEN 'MF' THEN 1 ELSE 1 END), 0) MF,
 NVL(SUM(CASE  POSITION WHEN 'DF' THEN 1 ELSE 1 END), 0) DF,
 NVL(SUM(CASE  POSITION WHEN 'GK' THEN 1 ELSE 1 END), 0) GK,
 COUNT(*) SUM 
FROM PLAYER
GROUP BY TEAM_ID；"
72.0,"팀별 포지션별 FW, MF, DF, GK 포지션의 인원수와 팀별 전체 인원수를 SQL을 작성할 때 결과가 다른 것은? (보기 1은 SQL Server 환경이고, 보기 2,3,4는 ORACLE 환경이다.)",,1,2,"SELECT TEAM_ID,
 NVL(SUM(CASE  WHEN POSITION = 'FW' THEN 1  END), 0) FW,
 NVL(SUM(CASE  WHEN POSITION = 'MF' THEN 1  END), 0) MF,
 NVL(SUM(CASE  WHEN POSITION = 'DF' THEN 1  END), 0) DF,
 NVL(SUM(CASE  WHEN POSITION = 'GK' THEN 1  END), 0) GK,
 COUNT(*) SUM 
FROM PLAYER
GROUP BY TEAM_ID；"
72.0,"팀별 포지션별 FW, MF, DF, GK 포지션의 인원수와 팀별 전체 인원수를 SQL을 작성할 때 결과가 다른 것은? (보기 1은 SQL Server 환경이고, 보기 2,3,4는 ORACLE 환경이다.)",,1,3,"SELECT TEAM_ID,
 NVL(SUM(CASE  POSITION WHEN 'FW' THEN 1  END), 0) FW,
 NVL(SUM(CASE  POSITION WHEN 'MF' THEN 1  END), 0) MF,
 NVL(SUM(CASE  POSITION WHEN 'DF' THEN 1  END), 0) DF,
 NVL(SUM(CASE  POSITION WHEN 'GK' THEN 1  END), 0) GK,
 COUNT(*) SUM 
FROM PLAYER
GROUP BY TEAM_ID；"
72.0,"팀별 포지션별 FW, MF, DF, GK 포지션의 인원수와 팀별 전체 인원수를 SQL을 작성할 때 결과가 다른 것은? (보기 1은 SQL Server 환경이고, 보기 2,3,4는 ORACLE 환경이다.)",,1,4,"SELECT TEAM_ID,
 ISNULL(SUM(CASE WHEN POSITION = 'FW' THEN 1 END), 0) FW,
 ISNULL(SUM(CASE WHEN POSITION = 'MF' THEN 1 END), 0) MF,
 ISNULL(SUM(CASE WHEN POSITION = 'DF' THEN 1 END), 0) DF,
 ISNULL(SUM(CASE WHEN POSITION = 'GK' THEN 1 END), 0) GK,
 COUNT(*) SUM 
FROM PLAYER
GROUP BY TEAM_ID；"
148.0,"엔터티 간 1:1, 1:M과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가?",,4,1,관계정의
148.0,"엔터티 간 1:1, 1:M과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가?",,4,2,관계선택성
148.0,"엔터티 간 1:1, 1:M과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가?",,4,3,관계명
148.0,"엔터티 간 1:1, 1:M과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가?",,4,4,관계 차수
149.0,관계를 정의할 때 주요하게 체크해야 하는 사항과 거리가 먼 것은?,,3,1,두 개의 엔터티 사이에 정보의 조합이 발생되는가?
149.0,관계를 정의할 때 주요하게 체크해야 하는 사항과 거리가 먼 것은?,,3,2,"업무기술서, 장표에 관계연결 규칙이 서술되어 있는가?"
149.0,관계를 정의할 때 주요하게 체크해야 하는 사항과 거리가 먼 것은?,,3,3,"업무기술서, 장표에 관계연결을 가능하게 하는 명사가 있는가?"
149.0,관계를 정의할 때 주요하게 체크해야 하는 사항과 거리가 먼 것은?,,3,4,두 개의 엔터티 사이에 관심 있는 연관규칙이 존재하는가?
153.0,데이터 모델링에 대한 단계 중 아래에서 설명하는 단계는 어떤 단계의 모델링인가?,"-추상화 수준이 높고 업무 중심적이며 포괄적인 수준의 모델링을 진행한다.
-전시적 데이터 모델링 또는 EA 수립 시 많이 이용된다.",2,1,추상적 데이터 모델링
153.0,데이터 모델링에 대한 단계 중 아래에서 설명하는 단계는 어떤 단계의 모델링인가?,"-추상화 수준이 높고 업무 중심적이며 포괄적인 수준의 모델링을 진행한다.
-전시적 데이터 모델링 또는 EA 수립 시 많이 이용된다.",2,2,개념적 데이터 모델링
153.0,데이터 모델링에 대한 단계 중 아래에서 설명하는 단계는 어떤 단계의 모델링인가?,"-추상화 수준이 높고 업무 중심적이며 포괄적인 수준의 모델링을 진행한다.
-전시적 데이터 모델링 또는 EA 수립 시 많이 이용된다.",2,3,논리적 데이터 모델링
