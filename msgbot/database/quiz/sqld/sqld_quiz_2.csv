"788","다음 함수의 결과가 다른 것은?","","2","1","ISNULL(COMM, 100)"
"788","다음 함수의 결과가 다른 것은?","","2","2","NULLIF(COMM, 100)"
"788","다음 함수의 결과가 다른 것은?","","2","3","NVL2(COMM, COMM, 100)"
"788","다음 함수의 결과가 다른 것은?","","2","4","NVL(COMM, 100)"
"800","다음 중 순수 관계 연산자로 적절하지 않은 것은?","","1","1","PRODUCT"
"800","다음 중 순수 관계 연산자로 적절하지 않은 것은?","","1","2","JOIN"
"800","다음 중 순수 관계 연산자로 적절하지 않은 것은?","","1","3","DIVISION"
"800","다음 중 순수 관계 연산자로 적절하지 않은 것은?","","1","4","SELECT"
"239","다음 SQL문의 결과로 출력되는 데이터는 무엇인가?","SELECT NEXT_DAY
(ADD_MONTHS(sysdate,6),'월요일)
FROM dual;","2","1","오늘 날짜로부터 6일 후 두 번째 월요일을 출력한다."
"239","다음 SQL문의 결과로 출력되는 데이터는 무엇인가?","SELECT NEXT_DAY
(ADD_MONTHS(sysdate,6),'월요일)
FROM dual;","2","2","오늘 날짜로부터 6개월 후 첫 번째 월요일을 출력한다."
"239","다음 SQL문의 결과로 출력되는 데이터는 무엇인가?","SELECT NEXT_DAY
(ADD_MONTHS(sysdate,6),'월요일)
FROM dual;","2","3","오늘 날짜로부터 6개월 후 두 번째 월요일을 출력한다."
"239","다음 SQL문의 결과로 출력되는 데이터는 무엇인가?","SELECT NEXT_DAY
(ADD_MONTHS(sysdate,6),'월요일)
FROM dual;","2","4","오늘 날짜로부터 6일 후 첫 번째 월요일을 출력한다."
"255","다음의 SQL문을 사용할 때, 날짜형 변수를 문자형으로 바꿀 수 있는 것은?","SELECT SYSDATE FROM DUAL;","2","1","CONVERT"
"255","다음의 SQL문을 사용할 때, 날짜형 변수를 문자형으로 바꿀 수 있는 것은?","SELECT SYSDATE FROM DUAL;","2","2","TO_CHAR"
"255","다음의 SQL문을 사용할 때, 날짜형 변수를 문자형으로 바꿀 수 있는 것은?","SELECT SYSDATE FROM DUAL;","2","3","TO_DATE"
"255","다음의 SQL문을 사용할 때, 날짜형 변수를 문자형으로 바꿀 수 있는 것은?","SELECT SYSDATE FROM DUAL;","2","4","TO_NUMBER"
"256","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","ㄱ : SELECT SUM(SAL) FROM EMP
       GROUP BY DEPTNO;
ㄴ : SELECT SUM(SAL) FROM EMP
       GROUP BY ROLLUP(DEPTNO);","3","1","ㄱ의 SQL문은 전체합계는 출력되지 않는다."
"256","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","ㄱ : SELECT SUM(SAL) FROM EMP
       GROUP BY DEPTNO;
ㄴ : SELECT SUM(SAL) FROM EMP
       GROUP BY ROLLUP(DEPTNO);","3","2","ㄴ은 부서별 합계와 전체합계가 출력된다."
"256","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","ㄱ : SELECT SUM(SAL) FROM EMP
       GROUP BY DEPTNO;
ㄴ : SELECT SUM(SAL) FROM EMP
       GROUP BY ROLLUP(DEPTNO);","3","3","ㄱ과 ㄴ의 결과 행 수는 동일하다."
"256","다음의 SQL문에 대한 설명으로 올바르지 않은 것은?","ㄱ : SELECT SUM(SAL) FROM EMP
       GROUP BY DEPTNO;
ㄴ : SELECT SUM(SAL) FROM EMP
       GROUP BY ROLLUP(DEPTNO);","3","4","ㄱ은 부서별 합계를 출력한다."
"815","제3정규형(3NF)에서 제거해야 하는 종속성은?","","3","1","부분 종속"
"815","제3정규형(3NF)에서 제거해야 하는 종속성은?","","3","2","조인 종속"
"815","제3정규형(3NF)에서 제거해야 하는 종속성은?","","3","3","이행적 종속"
"815","제3정규형(3NF)에서 제거해야 하는 종속성은?","","3","4","기본키 종속"
"816","도메인이란 무엇을 의미하는가?","","2","1","속성의 이름"
"816","도메인이란 무엇을 의미하는가?","","2","2","속성 값의 유효 범위"
"816","도메인이란 무엇을 의미하는가?","","2","3","관계 유형"
"816","도메인이란 무엇을 의미하는가?","","2","4","외래 키 목록"
"820","외래 키(Foreign Key)의 주요 목적은?","","2","1","데이터를 암호화"
"820","외래 키(Foreign Key)의 주요 목적은?","","2","2","데이터 무결성 유지"
"820","외래 키(Foreign Key)의 주요 목적은?","","2","3","성능 향상"
"820","외래 키(Foreign Key)의 주요 목적은?","","2","4","정규화 방지"
"6","다음 중 ANSI-SPARC에서 정의한 3단계구조에서 아래 내용이 설명하는 스키마구조로 가장 적절한 것은?","- 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현 
- 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마","3","1","논리스키마"
"6","다음 중 ANSI-SPARC에서 정의한 3단계구조에서 아래 내용이 설명하는 스키마구조로 가장 적절한 것은?","- 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현 
- 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마","3","2","내부스키마"
"6","다음 중 ANSI-SPARC에서 정의한 3단계구조에서 아래 내용이 설명하는 스키마구조로 가장 적절한 것은?","- 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현 
- 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마","3","3","개념스키마"
"6","다음 중 ANSI-SPARC에서 정의한 3단계구조에서 아래 내용이 설명하는 스키마구조로 가장 적절한 것은?","- 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현 
- 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들 간의 관계를 표현하는 스키마","3","4","외부스키마"
"21","다음 중 엔터티간의 관계어서 1：1, 1：M과 같이 관계의 가수성을 나타내는 것으로 가장 적절한 것은?","","3","1","관계정의 (Relationship Definition)"
"21","다음 중 엔터티간의 관계어서 1：1, 1：M과 같이 관계의 가수성을 나타내는 것으로 가장 적절한 것은?","","3","2","관계선택사양(Relationship Optionality)"
"21","다음 중 엔터티간의 관계어서 1：1, 1：M과 같이 관계의 가수성을 나타내는 것으로 가장 적절한 것은?","","3","3","관계차수(Relationship Degree/Cardinality)"
"21","다음 중 엔터티간의 관계어서 1：1, 1：M과 같이 관계의 가수성을 나타내는 것으로 가장 적절한 것은?","","3","4","관계명 (Relationship Membership)"
"65","다음 SQL 문장중 COLUMN1의 값이 널(NULL) 이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은? (ANSI 표준 기준)","","4","1","SELECT * FROM MYTABLE WHERE COLUMN1 NOT NULL"
"65","다음 SQL 문장중 COLUMN1의 값이 널(NULL) 이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은? (ANSI 표준 기준)","","4","2","SELECT * FROM MYTABLE WHERE COLUMN1 != NULL"
"65","다음 SQL 문장중 COLUMN1의 값이 널(NULL) 이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은? (ANSI 표준 기준)","","4","3","SELECT * FROM MYTABLE WHERE COLUMN1〈〉NULL"
"65","다음 SQL 문장중 COLUMN1의 값이 널(NULL) 이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은? (ANSI 표준 기준)","","4","4","SELECT * FROM MYTABLE WHERE COLUMN1 IS NOT NULL"
"71","오라클환경에서 날찌형 데이터를 다룰 경우, 아래 SQL 결과로 가장 적절한 것은?","SELECT TO_CHAR(TO_DATE('2015.01.10 10', 'YYYY,MM,DD HH24') + 1/24/(60/10), 'YYYY,MM,DD HH24:MI:SS') FROM DUAL;","2","1","2015.01.10.10:30:00"
"71","오라클환경에서 날찌형 데이터를 다룰 경우, 아래 SQL 결과로 가장 적절한 것은?","SELECT TO_CHAR(TO_DATE('2015.01.10 10', 'YYYY,MM,DD HH24') + 1/24/(60/10), 'YYYY,MM,DD HH24:MI:SS') FROM DUAL;","2","2","2015.01.10.10:10:00"
"71","오라클환경에서 날찌형 데이터를 다룰 경우, 아래 SQL 결과로 가장 적절한 것은?","SELECT TO_CHAR(TO_DATE('2015.01.10 10', 'YYYY,MM,DD HH24') + 1/24/(60/10), 'YYYY,MM,DD HH24:MI:SS') FROM DUAL;","2","3","2015.01.10.10:05:00"
"71","오라클환경에서 날찌형 데이터를 다룰 경우, 아래 SQL 결과로 가장 적절한 것은?","SELECT TO_CHAR(TO_DATE('2015.01.10 10', 'YYYY,MM,DD HH24') + 1/24/(60/10), 'YYYY,MM,DD HH24:MI:SS') FROM DUAL;","2","4","2015.01.10.11:01:00"
"88","다음 중 아래에서 join에 대한 설명으로 가장 적절한 것은?","(가) 일반적으로 Join은 PK와 FK 값의 연관성에 의해 성립된다.
(나) DBMS 옵티마이져는 From 절에 나열된 테이블들을 임의로 3개 정도씩 묶어서 Join을 처리한다.
(다) EQUI Join은 Join에 관여하는 테이블 간의 컬럼 값들이 정확하게 일치하는 경우에 사용되는 방법이다.
(라) EQUI Join은 '=' 연산자에 의해서만 수행되며, 그 이외의 비교 연산자를 사용하는 경우에는 모두 Non EQUI Join이다.
(마) 대부분 Non EQUI Join을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.","1","1","가, 다, 라, 마"
"88","다음 중 아래에서 join에 대한 설명으로 가장 적절한 것은?","(가) 일반적으로 Join은 PK와 FK 값의 연관성에 의해 성립된다.
(나) DBMS 옵티마이져는 From 절에 나열된 테이블들을 임의로 3개 정도씩 묶어서 Join을 처리한다.
(다) EQUI Join은 Join에 관여하는 테이블 간의 컬럼 값들이 정확하게 일치하는 경우에 사용되는 방법이다.
(라) EQUI Join은 '=' 연산자에 의해서만 수행되며, 그 이외의 비교 연산자를 사용하는 경우에는 모두 Non EQUI Join이다.
(마) 대부분 Non EQUI Join을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.","1","2","가, 나, 다, 라"
"88","다음 중 아래에서 join에 대한 설명으로 가장 적절한 것은?","(가) 일반적으로 Join은 PK와 FK 값의 연관성에 의해 성립된다.
(나) DBMS 옵티마이져는 From 절에 나열된 테이블들을 임의로 3개 정도씩 묶어서 Join을 처리한다.
(다) EQUI Join은 Join에 관여하는 테이블 간의 컬럼 값들이 정확하게 일치하는 경우에 사용되는 방법이다.
(라) EQUI Join은 '=' 연산자에 의해서만 수행되며, 그 이외의 비교 연산자를 사용하는 경우에는 모두 Non EQUI Join이다.
(마) 대부분 Non EQUI Join을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.","1","3","가, 나, 다"
"88","다음 중 아래에서 join에 대한 설명으로 가장 적절한 것은?","(가) 일반적으로 Join은 PK와 FK 값의 연관성에 의해 성립된다.
(나) DBMS 옵티마이져는 From 절에 나열된 테이블들을 임의로 3개 정도씩 묶어서 Join을 처리한다.
(다) EQUI Join은 Join에 관여하는 테이블 간의 컬럼 값들이 정확하게 일치하는 경우에 사용되는 방법이다.
(라) EQUI Join은 '=' 연산자에 의해서만 수행되며, 그 이외의 비교 연산자를 사용하는 경우에는 모두 Non EQUI Join이다.
(마) 대부분 Non EQUI Join을 수행할 수 있지만, 때로는 설계상의 이유로 수행이 불가능한 경우도 있다.","1","4","가, 다, 라"
"96","다음 중 아래 (1), (2), (3)의 SQL에서 실행결과가 같은 것은?","(1) SELECT A.ID, B.ID
 FROM TBL1 A FULL OUTER JOIN TBL2 B
ON A.ID = B.ID
(2)  SELECT A.ID, B.ID
 FROM TBL1 A LEFT OUTER JOIN TBL2 B
 ON A.ID = B.ID
 UNION
 SELECT A.ID, B.ID
 FROM TBL1 A RIGHT OUTER JOIN TBL2 B
 ON A.ID = B.ID
(3)  SELECT A.ID, B.ID
 FROM TBL1 A, TBL2 B
 WHERE A.ID = B.ID
 UNION ALL
 SELECT A. ID, NULL
 FROM TBL1 A
 WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID)
 UNION ALL
 SELECT NULL, B.ID
 FROM TBL2 B
 WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A.ID)","2","1","1,2,3"
"96","다음 중 아래 (1), (2), (3)의 SQL에서 실행결과가 같은 것은?","(1) SELECT A.ID, B.ID
 FROM TBL1 A FULL OUTER JOIN TBL2 B
ON A.ID = B.ID
(2)  SELECT A.ID, B.ID
 FROM TBL1 A LEFT OUTER JOIN TBL2 B
 ON A.ID = B.ID
 UNION
 SELECT A.ID, B.ID
 FROM TBL1 A RIGHT OUTER JOIN TBL2 B
 ON A.ID = B.ID
(3)  SELECT A.ID, B.ID
 FROM TBL1 A, TBL2 B
 WHERE A.ID = B.ID
 UNION ALL
 SELECT A. ID, NULL
 FROM TBL1 A
 WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID)
 UNION ALL
 SELECT NULL, B.ID
 FROM TBL2 B
 WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A.ID)","2","2","2,3"
"96","다음 중 아래 (1), (2), (3)의 SQL에서 실행결과가 같은 것은?","(1) SELECT A.ID, B.ID
 FROM TBL1 A FULL OUTER JOIN TBL2 B
ON A.ID = B.ID
(2)  SELECT A.ID, B.ID
 FROM TBL1 A LEFT OUTER JOIN TBL2 B
 ON A.ID = B.ID
 UNION
 SELECT A.ID, B.ID
 FROM TBL1 A RIGHT OUTER JOIN TBL2 B
 ON A.ID = B.ID
(3)  SELECT A.ID, B.ID
 FROM TBL1 A, TBL2 B
 WHERE A.ID = B.ID
 UNION ALL
 SELECT A. ID, NULL
 FROM TBL1 A
 WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID)
 UNION ALL
 SELECT NULL, B.ID
 FROM TBL2 B
 WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A.ID)","2","3","1,3"
"96","다음 중 아래 (1), (2), (3)의 SQL에서 실행결과가 같은 것은?","(1) SELECT A.ID, B.ID
 FROM TBL1 A FULL OUTER JOIN TBL2 B
ON A.ID = B.ID
(2)  SELECT A.ID, B.ID
 FROM TBL1 A LEFT OUTER JOIN TBL2 B
 ON A.ID = B.ID
 UNION
 SELECT A.ID, B.ID
 FROM TBL1 A RIGHT OUTER JOIN TBL2 B
 ON A.ID = B.ID
(3)  SELECT A.ID, B.ID
 FROM TBL1 A, TBL2 B
 WHERE A.ID = B.ID
 UNION ALL
 SELECT A. ID, NULL
 FROM TBL1 A
 WHERE NOT EXISTS (SELECT 1 FROM TBL2 B WHERE A.ID = B.ID)
 UNION ALL
 SELECT NULL, B.ID
 FROM TBL2 B
 WHERE NOT EXISTS (SELECT 1 FROM TBL1 A WHERE B.ID = A.ID)","2","4","1,2"
"118","다음 중 서브쿼리에 대해 설명으로 가장 적절한 것은?","","3","1","서브 쿼리는 항상 메인쿼리에서 읽혀진 데이터에 대해 서브쿼리에서 해당 조건이 만족하는지를 확인하는 방식으로 수행된다."
"118","다음 중 서브쿼리에 대해 설명으로 가장 적절한 것은?","","3","2","연관 서브쿼리는 주로 메인쿼리에 값을 제공하기 위한 목적으로 사용한다."
"118","다음 중 서브쿼리에 대해 설명으로 가장 적절한 것은?","","3","3","다중 행 서브쿼리 비교 연산자는 단일 행 서브쿼리의 비교 연산자로도 사용할 수 있다."
"118","다음 중 서브쿼리에 대해 설명으로 가장 적절한 것은?","","3","4","단일 행 서브쿼리는 서브쿼리의 실행 결과가 항상 한 건 이하의 서브쿼리로서 IN, ALL 등의 비교 연산자를 사용하여야 한다."
"143","데이터 모델링의 세 가지 중요개념에 속하지 않는 것은?","","2","1","업무가 관여하는 어떤 것의 관계"
"143","데이터 모델링의 세 가지 중요개념에 속하지 않는 것은?","","2","2","업무가 관여하는 어떤 것의 행위"
"143","데이터 모델링의 세 가지 중요개념에 속하지 않는 것은?","","2","3","업무가 관여하는 어떤 것의 성격"
"143","데이터 모델링의 세 가지 중요개념에 속하지 않는 것은?","","2","4","업무가 관여하는 어떤 것"
"144","발생 시점에 따라 구분할 수 있는 엔터티의 유형이 아닌 것은?","","1","1","개념 엔터티"
"144","발생 시점에 따라 구분할 수 있는 엔터티의 유형이 아닌 것은?","","1","2","기본 엔터티"
"144","발생 시점에 따라 구분할 수 있는 엔터티의 유형이 아닌 것은?","","1","3","중심 엔터티"
"144","발생 시점에 따라 구분할 수 있는 엔터티의 유형이 아닌 것은?","","1","4","행위 엔터티"
"167","분산 데이터베이스의 특징 중 저장 장소 명시가 불필요하다는 특성은 무엇인가?","","3","1","분할 투명성"
"167","분산 데이터베이스의 특징 중 저장 장소 명시가 불필요하다는 특성은 무엇인가?","","3","2","병행 투명성"
"167","분산 데이터베이스의 특징 중 저장 장소 명시가 불필요하다는 특성은 무엇인가?","","3","3","위치 투명성"
"167","분산 데이터베이스의 특징 중 저장 장소 명시가 불필요하다는 특성은 무엇인가?","","3","4","지역 사상 투명성"
"171","다음은 ERD 작성 순서이다. 올바른 것을 고르시오.","가)엔터티를 그린다.
나)엔터티를 적절하게 배치한다.
다)엔터티 간에 관계를 설정한다.
라)관계명을 기술한다.
마)관계의 참여도를 기술한다.
바)관계의 필수 여부를 기술한다.","3","1","가->나->다->마->바->라"
"171","다음은 ERD 작성 순서이다. 올바른 것을 고르시오.","가)엔터티를 그린다.
나)엔터티를 적절하게 배치한다.
다)엔터티 간에 관계를 설정한다.
라)관계명을 기술한다.
마)관계의 참여도를 기술한다.
바)관계의 필수 여부를 기술한다.","3","2","가->나->라->다->마->바"
"171","다음은 ERD 작성 순서이다. 올바른 것을 고르시오.","가)엔터티를 그린다.
나)엔터티를 적절하게 배치한다.
다)엔터티 간에 관계를 설정한다.
라)관계명을 기술한다.
마)관계의 참여도를 기술한다.
바)관계의 필수 여부를 기술한다.","3","3","가->나->다->라->마->바"
"171","다음은 ERD 작성 순서이다. 올바른 것을 고르시오.","가)엔터티를 그린다.
나)엔터티를 적절하게 배치한다.
다)엔터티 간에 관계를 설정한다.
라)관계명을 기술한다.
마)관계의 참여도를 기술한다.
바)관계의 필수 여부를 기술한다.","3","4","나->가->다->라->마->바"
"174","다음 중 테이블명으로 가능한 것은 무엇인가?","","2","1","100_EMP"
"174","다음 중 테이블명으로 가능한 것은 무엇인가?","","2","2","EMP100"
"174","다음 중 테이블명으로 가능한 것은 무엇인가?","","2","3","100EMP"
"174","다음 중 테이블명으로 가능한 것은 무엇인가?","","2","4","EMP-100"
"190","SELECT문의 처리 순서로 올바른 것은?","SELECT deptno,sum(sal)
FROM dept
WHERE deptno > 10
GROUP BY deptno
ORDER BY deptno;","3","1","ORDER BY, SELECT, WHERE, GROUP BY, FROM"
"190","SELECT문의 처리 순서로 올바른 것은?","SELECT deptno,sum(sal)
FROM dept
WHERE deptno > 10
GROUP BY deptno
ORDER BY deptno;","3","2","SELECT, FROM, WHERE, GROUP BY, ORDER BY"
"190","SELECT문의 처리 순서로 올바른 것은?","SELECT deptno,sum(sal)
FROM dept
WHERE deptno > 10
GROUP BY deptno
ORDER BY deptno;","3","3","FROM, WHERE, GROUP BY, SELECT, ORDER BY"
"190","SELECT문의 처리 순서로 올바른 것은?","SELECT deptno,sum(sal)
FROM dept
WHERE deptno > 10
GROUP BY deptno
ORDER BY deptno;","3","4","WHERE, GROUP BY, ORDER BY, FROM, SELECT"
"192","데이터베이스 사용자 AAA에 CREATE TABLE 권한이 부여되었다. ( ) 에 들어가야 하는 것은 무엇인가?","( ) CREATE TABLE TO AAA","4","1","COMMIT"
"192","데이터베이스 사용자 AAA에 CREATE TABLE 권한이 부여되었다. ( ) 에 들어가야 하는 것은 무엇인가?","( ) CREATE TABLE TO AAA","4","2","INSERT"
"192","데이터베이스 사용자 AAA에 CREATE TABLE 권한이 부여되었다. ( ) 에 들어가야 하는 것은 무엇인가?","( ) CREATE TABLE TO AAA","4","3","REVOKE"
"192","데이터베이스 사용자 AAA에 CREATE TABLE 권한이 부여되었다. ( ) 에 들어가야 하는 것은 무엇인가?","( ) CREATE TABLE TO AAA","4","4","GRANT"
"194","다음 주어진 그룹 함수와 동일한 결괏값을 반환하는 그룹 함수를 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","1","1","GROUP BY GROUPING SETS(DEPTNO, JOB, (DEPTNO, JOB),());"
"194","다음 주어진 그룹 함수와 동일한 결괏값을 반환하는 그룹 함수를 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","1","2","GROUP BY DEPTNO UNION ALL GROUP BY JOB UNION ALL GROUP BY (DEPTNO, JOB);"
"194","다음 주어진 그룹 함수와 동일한 결괏값을 반환하는 그룹 함수를 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","1","3","GROUP BY (DEPTNO, JOB, (DEPTNO, JOB),());"
"194","다음 주어진 그룹 함수와 동일한 결괏값을 반환하는 그룹 함수를 고르시오.","GROUP BY CUBE(DEPTNO, JOB);","1","4","GROUP BY ROLLUP(DEPTNO,JOB);"
"270","데이터베이스 정규화 중에서 기본키를 제외하고 칼럼 간에 종속성이 발생하면 테이블을 분할하는 것은?","","2","1","제4정규화"
"270","데이터베이스 정규화 중에서 기본키를 제외하고 칼럼 간에 종속성이 발생하면 테이블을 분할하는 것은?","","2","2","제3정규화"
"270","데이터베이스 정규화 중에서 기본키를 제외하고 칼럼 간에 종속성이 발생하면 테이블을 분할하는 것은?","","2","3","제2정규화"
"270","데이터베이스 정규화 중에서 기본키를 제외하고 칼럼 간에 종속성이 발생하면 테이블을 분할하는 것은?","","2","4","제1정규화"
"278","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","2","1","CONNECT_BY_ISLEAF에서 해당 데이터가 리프 데이터면 1, 그렇지 않으면 0을 반환한다."
"278","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","2","2","CONNECT BY는 부모 자식을 설명하는 것이다."
"278","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","2","3","계층형 쿼리는 계층형 형태로 데이터를 질의할 때 사용된다."
"278","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","2","4","PRIOR 자식 = 부모 형태를 사용하면 계층 구조에서 순방향 전개를 수행한다."
"285","분산 데이터베이스의 투명성과 관련이 없는 것은?","","1","1","이행 투명성"
"285","분산 데이터베이스의 투명성과 관련이 없는 것은?","","1","2","지역사상 투명성"
"285","분산 데이터베이스의 투명성과 관련이 없는 것은?","","1","3","위치 투명성"
"285","분산 데이터베이스의 투명성과 관련이 없는 것은?","","1","4","분할 투명성"
"306","다음 보기에서 설명하고 있는 데이터베이스 키의 종류는 무엇인가?","데이터베이스 키의 종류 중에서 유일성과 최소성을 만족한다.","2","1","외래키"
"306","다음 보기에서 설명하고 있는 데이터베이스 키의 종류는 무엇인가?","데이터베이스 키의 종류 중에서 유일성과 최소성을 만족한다.","2","2","후보키"
"306","다음 보기에서 설명하고 있는 데이터베이스 키의 종류는 무엇인가?","데이터베이스 키의 종류 중에서 유일성과 최소성을 만족한다.","2","3","수퍼키"
"306","다음 보기에서 설명하고 있는 데이터베이스 키의 종류는 무엇인가?","데이터베이스 키의 종류 중에서 유일성과 최소성을 만족한다.","2","4","인조키"
"322","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","1","1","서브쿼리에서 메인쿼리의 칼럼을 사용할 수 있고 메인쿼리에서도 서브쿼리의 칼럼을 사용할 수 있다."
"322","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","1","2","FROM구에 사용되면 인라인 뷰이고 WHERE절에 사용되면 서브쿼리이다."
"322","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","1","3","서브쿼리에서 여러 개의 행이 반환되면 IN, ANY, ALL과 같은 다중행 서브쿼리 함수를 사용해야 한다."
"322","다음 중 서브쿼리에 대한 설명으로 올바르지 않은 것은?","","1","4","서브쿼리에는 Order by구를 사용할 수 없다."
"335","다음 주어진 SQL문을 수행하였을 때 최종적으로 반영되는 값은 무엇인가?","INSERT INTO Mytest VALUES(1);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET CO1=8 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE COL1=8;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(9);
ROLLBACK TO SV2;
COMMIT;","1","1","1,8,9"
"335","다음 주어진 SQL문을 수행하였을 때 최종적으로 반영되는 값은 무엇인가?","INSERT INTO Mytest VALUES(1);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET CO1=8 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE COL1=8;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(9);
ROLLBACK TO SV2;
COMMIT;","1","2","1,8,11,8"
"335","다음 주어진 SQL문을 수행하였을 때 최종적으로 반영되는 값은 무엇인가?","INSERT INTO Mytest VALUES(1);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET CO1=8 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE COL1=8;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(9);
ROLLBACK TO SV2;
COMMIT;","1","3","1,8,11"
"335","다음 주어진 SQL문을 수행하였을 때 최종적으로 반영되는 값은 무엇인가?","INSERT INTO Mytest VALUES(1);
INSERT INTO Mytest VALUES(2);
SAVEPOINT SV1;
UPDATE Mytest SET CO1=8 WHERE COL1=2;
INSERT INTO Mytest VALUES(9);
SAVEPOINT SV2;
DELETE Mytest WHERE COL1=8;
INSERT INTO Mytest VALUES(11);
SAVEPOINT SV3;
INSERT INTO Mytest VALUES(9);
ROLLBACK TO SV2;
COMMIT;","1","4","1,2"
"338","다음 중 CUBE 함수에 대한 설명으로 올바르지 않은 것은?","","1","1","ROLLUP에 비해서 시스템 연산이 적은 장점이 있다."
"338","다음 중 CUBE 함수에 대한 설명으로 올바르지 않은 것은?","","1","2","CUBE 함수를 사용해서 계층별 집계를 구할 수 있다."
"338","다음 중 CUBE 함수에 대한 설명으로 올바르지 않은 것은?","","1","3","CUBE는 ORDER BY를 사용해서 정렬할 수 있다."
"338","다음 중 CUBE 함수에 대한 설명으로 올바르지 않은 것은?","","1","4","CUBE는 칼럼에서 결합이 가능한 모든 다차원 집계를 생성한다."
"368","다음 중 속성에 대한 특징으로 알맞은 것은?","","3","1","서술식 속성명을 사용할 수 있다."
"368","다음 중 속성에 대한 특징으로 알맞은 것은?","","3","2","하나의 속성은 여러 개의 속성명을 가질 수 있다."
"368","다음 중 속성에 대한 특징으로 알맞은 것은?","","3","3","엔터티를 설명하고 인스턴스의 구성요소가 된다."
"368","다음 중 속성에 대한 특징으로 알맞은 것은?","","3","4","한 개의 엔터티는 한 개의 속성만 가질 수 있다."
"376","다음 중 GROUP 함수에 대한 설명으로 올바른 것은?","","4","1","ROLLUP은 CUBE에 비해서 시스템에 부하를 많이 발생시키므로 반드시 튜닝해야 한다."
"376","다음 중 GROUP 함수에 대한 설명으로 올바른 것은?","","4","2","ROLLUP, CUBE, GROUPING SETS은 정렬이 가능하지만, 하나의 칼럼에 대해서만 사용할 수 있다."
"376","다음 중 GROUP 함수에 대한 설명으로 올바른 것은?","","4","3","ROLLUP은 전체합계만을 구하고 싶을 때 사용한다."
"376","다음 중 GROUP 함수에 대한 설명으로 올바른 것은?","","4","4","CUBE는 결합 가능한 모든 값에 대하여 다차원 집계를 생성하는 것이 특징이다."
"382","동일한 순위에 대해서 동일한 순위를 부여하고 다음 순위를 건너뛰지 않는 것은?","","3","1","RATIO.....TO REPORT"
"382","동일한 순위에 대해서 동일한 순위를 부여하고 다음 순위를 건너뛰지 않는 것은?","","3","2","ROW_NUMBER"
"382","동일한 순위에 대해서 동일한 순위를 부여하고 다음 순위를 건너뛰지 않는 것은?","","3","3","DENSE_RANK"
"382","동일한 순위에 대해서 동일한 순위를 부여하고 다음 순위를 건너뛰지 않는 것은?","","3","4","RANK"
"387","아래의 SQL문에 대한 설명으로 올바른 것은?","SELECT * FROM EMP
WHERE EMP_NAME LIKE 'K%';","3","1","테이블의 EMP_NAME이 A 또는 a로 끝나는 모든 행이 검색된다."
"387","아래의 SQL문에 대한 설명으로 올바른 것은?","SELECT * FROM EMP
WHERE EMP_NAME LIKE 'K%';","3","2","테이블의 EMP_NAME이 K로 끝나는 모든 행이 검색된다."
"387","아래의 SQL문에 대한 설명으로 올바른 것은?","SELECT * FROM EMP
WHERE EMP_NAME LIKE 'K%';","3","3","테이블의 EMP_NAME이 K로 시작하는 모든 행이 검색된다."
"387","아래의 SQL문에 대한 설명으로 올바른 것은?","SELECT * FROM EMP
WHERE EMP_NAME LIKE 'K%';","3","4","테이블의 EMP_NAME이 K 또는 k로 시작하는 모든 행이 검색된다."
"398","SELECT UPPER('sqldeveloper') FROM DUAL; 의 결과를 적으시오.","","3","1","SqlDeveloper"
"398","SELECT UPPER('sqldeveloper') FROM DUAL; 의 결과를 적으시오.","","3","2","sqldeveloper"
"398","SELECT UPPER('sqldeveloper') FROM DUAL; 의 결과를 적으시오.","","3","3","SQLDEVELOPER"
"398","SELECT UPPER('sqldeveloper') FROM DUAL; 의 결과를 적으시오.","","3","4","SQLDeveloper"
"400","다음의 SQL 실행 결과는 무엇인가?","SELECT sysdate + NULL FROM DUAL;","1","1","NULL"
"400","다음의 SQL 실행 결과는 무엇인가?","SELECT sysdate + NULL FROM DUAL;","1","2","내일 날짜가 조회된다."
"400","다음의 SQL 실행 결과는 무엇인가?","SELECT sysdate + NULL FROM DUAL;","1","3","오늘 날짜가 조회된다."
"400","다음의 SQL 실행 결과는 무엇인가?","SELECT sysdate + NULL FROM DUAL;","1","4","0"
"412","A 사용자가 ""홍길동"" 데이터를 입력하고 아직 COMMIT 되지 않은 데이터에 대한 설명으로 잘못된 것은?","","1","1","B 사용자는 홍길동 데이터를 수정할 수 있다."
"412","A 사용자가 ""홍길동"" 데이터를 입력하고 아직 COMMIT 되지 않은 데이터에 대한 설명으로 잘못된 것은?","","1","2","A 사용자는 홍길동 데이터를 수정할 수 있다."
"412","A 사용자가 ""홍길동"" 데이터를 입력하고 아직 COMMIT 되지 않은 데이터에 대한 설명으로 잘못된 것은?","","1","3","B 사용자는 홍길동 데이터가 조회되지 않는다."
"412","A 사용자가 ""홍길동"" 데이터를 입력하고 아직 COMMIT 되지 않은 데이터에 대한 설명으로 잘못된 것은?","","1","4","A 사용자는 홍길동 데이터를 조회할 수 있다."
"413","다음 중 COL100에 NULL이 없는 데이터를 찾는 SQL로 올바른 것은?","","2","1","SELECT COL1 FROM T1 WHERE COL100 NOT IN (NULL)"
"413","다음 중 COL100에 NULL이 없는 데이터를 찾는 SQL로 올바른 것은?","","2","2","SELECT COL1 FROM T1 WHERE COL100 IS NOT NULL"
"413","다음 중 COL100에 NULL이 없는 데이터를 찾는 SQL로 올바른 것은?","","2","3","SELECT COL1 FROM T1 WHERE COL100 != ''"
"413","다음 중 COL100에 NULL이 없는 데이터를 찾는 SQL로 올바른 것은?","","2","4","SELECT COL1 FROM T1 WHERE COL100 <> 'NULL'"
"426","다음 중 아래 SQL문의 결괏값으로 올바른 것은?","SELECT SUBSTR('123456789123456789', -4,2) FROM DUAL;","1","1","67"
"426","다음 중 아래 SQL문의 결괏값으로 올바른 것은?","SELECT SUBSTR('123456789123456789', -4,2) FROM DUAL;","1","2","65"
"426","다음 중 아래 SQL문의 결괏값으로 올바른 것은?","SELECT SUBSTR('123456789123456789', -4,2) FROM DUAL;","1","3","43"
"426","다음 중 아래 SQL문의 결괏값으로 올바른 것은?","SELECT SUBSTR('123456789123456789', -4,2) FROM DUAL;","1","4","45"
"428","다음 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","1","고유키로 지정되면 모든 칼럼들은 NULL 값을 가질 수 없다."
"428","다음 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","2","외래키는 테이블 간의 관계를 정의하고 참조 무결성을 준수하게 한다."
"428","다음 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","3","Check 조건은 테이블에 데이터를 입력 하기 전에 검사를 수행한다."
"428","다음 중 데이터베이스 테이블의 제약조건에 대한 설명으로 올바르지 않은 것은?","","1","4","기본키는 테이블당 하나의 제약만을 정의할 수 있다."
"471","다음 보기 중 WHERE에서 사용되는 서브쿼리에 대한 설명으로 옳지 않은 것은?","","3","1","EXISTS는 TRUE와 FALSE만 되돌린다."
"471","다음 보기 중 WHERE에서 사용되는 서브쿼리에 대한 설명으로 옳지 않은 것은?","","3","2","여러 개의 행을 되돌리는 서브쿼리는 다중 행 연산자를 사용해야 한다."
"471","다음 보기 중 WHERE에서 사용되는 서브쿼리에 대한 설명으로 옳지 않은 것은?","","3","3","메인쿼리를 작성할 때 서브쿼리에 있는 칼럼을 자유롭게 사용할 수 있으면 편리하다."
"471","다음 보기 중 WHERE에서 사용되는 서브쿼리에 대한 설명으로 옳지 않은 것은?","","3","4","서브쿼리에서는 정렬을 수행하기 위해서 내부에 ORDER BY를 사용하지 못한다."
"492","테이블에 대한 권한을 부여하는 DCL 명령어는?","","3","1","ROLLBACK"
"492","테이블에 대한 권한을 부여하는 DCL 명령어는?","","3","2","REVOKE"
"492","테이블에 대한 권한을 부여하는 DCL 명령어는?","","3","3","GRANT"
"492","테이블에 대한 권한을 부여하는 DCL 명령어는?","","3","4","COMMIT"
"500","아래의 WINDOW FUNCTION을 사용한 SQL 중 가장 올바르지 않은 것은?","","1","1","SUM(SAL) OVER(PARTITION BY JOB ORDER BY EMPNO RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED PRECEDING)  SAL3"
"500","아래의 WINDOW FUNCTION을 사용한 SQL 중 가장 올바르지 않은 것은?","","1","2","SUM(SAL) OVER(PARTITION BY JOB ORDER BY JOB RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)  SAL2"
"500","아래의 WINDOW FUNCTION을 사용한 SQL 중 가장 올바르지 않은 것은?","","1","3","SUM(SAL) OVER(PARTITION BY JOB ORDER BY EMPNO RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)  SAL1"
"500","아래의 WINDOW FUNCTION을 사용한 SQL 중 가장 올바르지 않은 것은?","","1","4","SUM(SAL) OVER()"
"502","주어진 SQL문을 수행한 결과로 올바른 것은?","INSERT INTO test24 VALUES (1);
INSERT INTO test24 VALUES (2);
COMMIT;
INSERT INTO test24 VALUES (3);
SAVEPOINT SP;
INSERT INTO test24 VALUES (4);
ROLLBACK to SP;
SELECT COUNT(*) FROM test24;","3","1","6"
"502","주어진 SQL문을 수행한 결과로 올바른 것은?","INSERT INTO test24 VALUES (1);
INSERT INTO test24 VALUES (2);
COMMIT;
INSERT INTO test24 VALUES (3);
SAVEPOINT SP;
INSERT INTO test24 VALUES (4);
ROLLBACK to SP;
SELECT COUNT(*) FROM test24;","3","2","5"
"502","주어진 SQL문을 수행한 결과로 올바른 것은?","INSERT INTO test24 VALUES (1);
INSERT INTO test24 VALUES (2);
COMMIT;
INSERT INTO test24 VALUES (3);
SAVEPOINT SP;
INSERT INTO test24 VALUES (4);
ROLLBACK to SP;
SELECT COUNT(*) FROM test24;","3","3","3"
"502","주어진 SQL문을 수행한 결과로 올바른 것은?","INSERT INTO test24 VALUES (1);
INSERT INTO test24 VALUES (2);
COMMIT;
INSERT INTO test24 VALUES (3);
SAVEPOINT SP;
INSERT INTO test24 VALUES (4);
ROLLBACK to SP;
SELECT COUNT(*) FROM test24;","3","4","2"
"523","다음 중 도메인 대한 특징으로 옳지 않은 것은?","","1","1","하나의 릴레이션과 관계된 다른 릴레이션의 FK 제약조건이다."
"523","다음 중 도메인 대한 특징으로 옳지 않은 것은?","","1","2","속성에 값을 입력할 때 CHECK 기능을 사용해서 입력값을 검사한다."
"523","다음 중 도메인 대한 특징으로 옳지 않은 것은?","","1","3","속성에 대해서 NOT NULL 제약사항을 설정하여 NULL 값을 허용하지 않는다."
"523","다음 중 도메인 대한 특징으로 옳지 않은 것은?","","1","4","릴레이션의 속성에 대한 데이터 타입과 크기이다."
"524","다음 중 데이터베이스 모델링에 대한 특징으로 올바르지 않은 것은?","","4","1","명확화"
"524","다음 중 데이터베이스 모델링에 대한 특징으로 올바르지 않은 것은?","","4","2","단순화"
"524","다음 중 데이터베이스 모델링에 대한 특징으로 올바르지 않은 것은?","","4","3","추상화"
"524","다음 중 데이터베이스 모델링에 대한 특징으로 올바르지 않은 것은?","","4","4","내부화"
"553","파티션별 윈도우에서 가장 먼저 나온 값을 구하는 WINDOW FUNCTION은 무엇인가?","","4","1","LEAD"
"553","파티션별 윈도우에서 가장 먼저 나온 값을 구하는 WINDOW FUNCTION은 무엇인가?","","4","2","LAST_VALUE"
"553","파티션별 윈도우에서 가장 먼저 나온 값을 구하는 WINDOW FUNCTION은 무엇인가?","","4","3","LAG"
"553","파티션별 윈도우에서 가장 먼저 나온 값을 구하는 WINDOW FUNCTION은 무엇인가?","","4","4","FIRST_VALUE"
"580","다음 식별자에 대한 설명으로 가장 적절한 것은?","엔터티 내의 여러 인스턴스 중 하나를 유일하게 구분할 수 있으나, 대표성을 가지지 못하는 식별자","4","1","복합식별자"
"580","다음 식별자에 대한 설명으로 가장 적절한 것은?","엔터티 내의 여러 인스턴스 중 하나를 유일하게 구분할 수 있으나, 대표성을 가지지 못하는 식별자","4","2","본질식별자"
"580","다음 식별자에 대한 설명으로 가장 적절한 것은?","엔터티 내의 여러 인스턴스 중 하나를 유일하게 구분할 수 있으나, 대표성을 가지지 못하는 식별자","4","3","인조식별자"
"580","다음 식별자에 대한 설명으로 가장 적절한 것은?","엔터티 내의 여러 인스턴스 중 하나를 유일하게 구분할 수 있으나, 대표성을 가지지 못하는 식별자","4","4","보조식별자"
"620","유저와 권한 중 권한에 대한 설명 중 가장 올바르지 않은 것은?","","3","1","권한 부여를 편리하게 관리하기 위해 만들어진 권한의 집합인 ROLE 이 있다"
"620","유저와 권한 중 권한에 대한 설명 중 가장 올바르지 않은 것은?","","3","2","테이블의 소유자는 해당 테이블의 DML 권한을 다른 유저에게 부여 할 수 있다."
"620","유저와 권한 중 권한에 대한 설명 중 가장 올바르지 않은 것은?","","3","3","DBA 권한을 가진 유저만이 권한을 부여 할 수 있다"
"620","유저와 권한 중 권한에 대한 설명 중 가장 올바르지 않은 것은?","","3","4","사용자가 실행하는 모든 DDL 문장은 그에 해당하는 적절한 권한이 있어야만 문장을 실행 할 수 있다."
"626","데이터 모델링의 정규화에 대한 설명으로 가장 적절하지 않은 것은?","","3","1","제3정규형을 만족하는 엔터티의 일반속성은 주식별자 전체에 종속적이다."
"626","데이터 모델링의 정규화에 대한 설명으로 가장 적절하지 않은 것은?","","3","2","제1정규형은 모든 인스턴스가 반드시 하나의 값을 가져야 함을 의미한다."
"626","데이터 모델링의 정규화에 대한 설명으로 가장 적절하지 않은 것은?","","3","3","개념 모델링 단계에서의 엔터티를 상세화 하는 과정이다."
"626","데이터 모델링의 정규화에 대한 설명으로 가장 적절하지 않은 것은?","","3","4","정규화는 모델의 일관성을 확보하고 중복을 제거하여 모델의 독립성을 확보하는 과정이다."
"631","다음 SQL 중 항상 오류가 발생하는 구문으로 가장 적절한 것은? ","","1","1","SELECT T.COL1 C1, T.COL2 AS ""C1"" FROM TABLE1 T WHERE T.COL2 IN ('A', 'B') ORDER BY 1, ""C1"";"
"631","다음 SQL 중 항상 오류가 발생하는 구문으로 가장 적절한 것은? ","","1","2","SELECT T.COL1 C1, TABLE1.COL2 AS C2 FROM TABLE1 T WHERE TABLE1.COL2 = 'A' ORDER BY 1, 2;"
"631","다음 SQL 중 항상 오류가 발생하는 구문으로 가장 적절한 것은? ","","1","3","SELECT TABLE1.COL1, SUM(TABLE1.COL2) FROM TABLE1 GROUP BY TABLE1.COL1 ORDER BY COL1;"
"631","다음 SQL 중 항상 오류가 발생하는 구문으로 가장 적절한 것은? ","","1","4","SELECT T.COL1 C1, T.COL2 AS C2 FROM TABLE1 T WHERE T.COL1 = 4;"
