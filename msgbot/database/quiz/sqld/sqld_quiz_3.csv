"677","다음이 설명하는 관계로 가장 적절한 것은? ","두 엔터티나 두 속성 간에 동시에 발생할 수 없는 관계를 의미합니다. 즉, 하나의 엔터티나 속성이 특정한 경우 다른 엔터티나 속성은 해당 경우가 될 수 없음을 나타냅니다.","2","1","상호일관적"
"677","다음이 설명하는 관계로 가장 적절한 것은? ","두 엔터티나 두 속성 간에 동시에 발생할 수 없는 관계를 의미합니다. 즉, 하나의 엔터티나 속성이 특정한 경우 다른 엔터티나 속성은 해당 경우가 될 수 없음을 나타냅니다.","2","2","상호배타적"
"677","다음이 설명하는 관계로 가장 적절한 것은? ","두 엔터티나 두 속성 간에 동시에 발생할 수 없는 관계를 의미합니다. 즉, 하나의 엔터티나 속성이 특정한 경우 다른 엔터티나 속성은 해당 경우가 될 수 없음을 나타냅니다.","2","3","상호포괄적"
"677","다음이 설명하는 관계로 가장 적절한 것은? ","두 엔터티나 두 속성 간에 동시에 발생할 수 없는 관계를 의미합니다. 즉, 하나의 엔터티나 속성이 특정한 경우 다른 엔터티나 속성은 해당 경우가 될 수 없음을 나타냅니다.","2","4","상호종속적"
"686","다음 함수 사용시 결과값이 올바르지 않은 것은? ","","4","1","SIGN(0) = 0"
"686","다음 함수 사용시 결과값이 올바르지 않은 것은? ","","4","2","MOD(8,3) = 2"
"686","다음 함수 사용시 결과값이 올바르지 않은 것은? ","","4","3","FLOOR(-12.345) = -13"
"686","다음 함수 사용시 결과값이 올바르지 않은 것은? ","","4","4","CEIL(-12.345) = -13"
"689","다음 중 정상적으로 실행되지 않는 문장은? (단, DBMS는 오라클)","","1","1","SELECT NVL(100, 'NULL') FROM DUAL;"
"689","다음 중 정상적으로 실행되지 않는 문장은? (단, DBMS는 오라클)","","1","2","SELECT TO_DATE('11', 'DD') + 10 FROM DUAL;"
"689","다음 중 정상적으로 실행되지 않는 문장은? (단, DBMS는 오라클)","","1","3","SELECT TO_DATE('20240101', 'YYYYMMDD') - 10 FROM DUAL;"
"689","다음 중 정상적으로 실행되지 않는 문장은? (단, DBMS는 오라클)","","1","4","SELECT 100 + '1' FROM DUAL;"
"724","다음 중 관계를 구성하는 요소가 아닌 것은?","","1","1","관계정의"
"724","다음 중 관계를 구성하는 요소가 아닌 것은?","","1","2","선택성(Optionality)"
"724","다음 중 관계를 구성하는 요소가 아닌 것은?","","1","3","차수(Cardinality)"
"724","다음 중 관계를 구성하는 요소가 아닌 것은?","","1","4","관계명"
"747","서브쿼리에 대한 설명으로 가장 적절한 것은?","","1","1","연관 서브쿼리는 메인쿼리가 먼저 수행된 후에 서브쿼리에서 조건이 맞는지 확인할 때 주로 사용한다."
"747","서브쿼리에 대한 설명으로 가장 적절한 것은?","","1","2","서브쿼리가 메인쿼리 컬럼을 가지고 있을 경우 비연관 서브쿼리라고 한다."
"747","서브쿼리에 대한 설명으로 가장 적절한 것은?","","1","3","단일행 서브쿼리는 비교 연산자 사용이 불가하다."
"747","서브쿼리에 대한 설명으로 가장 적절한 것은?","","1","4","FROM 절에 사용하는 서브쿼리를 스칼라 서브쿼리라고 한다."
"763","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_REPLACE('031-234-4567', '\d+', 'XXX', 1, 2) FROM DUAL;","2","1","031-234-XXX"
"763","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_REPLACE('031-234-4567', '\d+', 'XXX', 1, 2) FROM DUAL;","2","2","031-XXX-4567"
"763","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_REPLACE('031-234-4567', '\d+', 'XXX', 1, 2) FROM DUAL;","2","3","XX1-234-4567"
"763","다음 SQL 실행 결과로 가장 적절한 것은?","SELECT REGEXP_REPLACE('031-234-4567', '\d+', 'XXX', 1, 2) FROM DUAL;","2","4","031-234-4567"
"766","다음 설명 중 가장 적절하지 않은 것은?","","1","1","SAVEPOINT 지점이 COMMIT 이전일때 해당 SAVEPOINT까지 ROLLBACK 시도 시 COMMIT이후 까지만 ROLLBACK 된다."
"766","다음 설명 중 가장 적절하지 않은 것은?","","1","2","ROLLBACK을 한 명령을 다시 ROLLBACK으로 취소할 수 없다."
"766","다음 설명 중 가장 적절하지 않은 것은?","","1","3","INSERT 한 이후 컬럼 추가 시 INSERT 값은 자동 저장되어 ROLLBACK 할 수 없다."
"766","다음 설명 중 가장 적절하지 않은 것은?","","1","4","COMMIT을 한 이후에는 ROLLBACK을 수행해도 이전 값으로 돌아갈 수 없다."
"767","테이블 생성 시 주의 사항으로 옳지 않은 것은?","","3","1","컬럼에 대한 제약조건을 추가하는 경우 CONSTRAINT를 사용한다."
"767","테이블 생성 시 주의 사항으로 옳지 않은 것은?","","3","2","날짜 유형은 별도로 크기를 지정하지 않아도 된다."
"767","테이블 생성 시 주의 사항으로 옳지 않은 것은?","","3","3","문자 데이터 유형은 별도로 크기를 지정하지 않아도 된다."
"767","테이블 생성 시 주의 사항으로 옳지 않은 것은?","","3","4","테이블 생성시 대소문자 구분은 하지 않아도 된다."
"772","엔터티에 대한 설명으로 가장 적절한 것은?","","3","1","주로 약어를 사용하여 엔터티 이름을 정한다."
"772","엔터티에 대한 설명으로 가장 적절한 것은?","","3","2","다른 엔터티와 관계를 꼭 갖지 않아도 된다."
"772","엔터티에 대한 설명으로 가장 적절한 것은?","","3","3","사용되지 않는 고립 엔터티는 제거를 고려한다."
"772","엔터티에 대한 설명으로 가장 적절한 것은?","","3","4","누락된 프로세스의 경우 이후 추가하거나 수정할 수 없다."
"777","관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","1","관계는 존재에 의한 관계와 행위에 의한 관계로 분류한다."
"777","관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","2","관계를 맺는다는 의미는 자식의 식별자를 부모에 상속하는 일이다."
"777","관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","3","학생과 수업 간의 관계는 등록이라는 행위를 통해 형성되므로 행위 관계를 갖는다."
"777","관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","4","주문항목은 반드시 주문이 있어야만 존재할 수 있으므로 존재 관계를 갖는다."
"778","트랜잭션의 특성 그 의미와 맞는 것은?","","2","1","연관성 : 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다."
"778","트랜잭션의 특성 그 의미와 맞는 것은?","","2","2","고립성 : 트랜잭션이 실행되는 도중 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안 된다"
"778","트랜잭션의 특성 그 의미와 맞는 것은?","","2","3","원자성 : 트랜잭션이 실행되기 전 데이터의 내용이 잘못되면 실행 이후에도 내용이 잘못 되어 있지 않다."
"778","트랜잭션의 특성 그 의미와 맞는 것은?","","2","4","일관성 : 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다."
"780","다음 식별자에 대한 설명으로 가장 적절하지 않은 것은?","","2","1","인조식별자를 사용하면 중복 데이터 발생 가능성이 있어 데이터 품질이 저하된다."
"780","다음 식별자에 대한 설명으로 가장 적절하지 않은 것은?","","2","2","본질식별자가 단순한 구성을 가질 때 주로 인조식별자를 생성한다."
"780","다음 식별자에 대한 설명으로 가장 적절하지 않은 것은?","","2","3","꼭 필요하지 않지만 관리의 편이성 등의 이유로 인위적으로 만들어지는 식별자를 인조식별자라 한다."
"780","다음 식별자에 대한 설명으로 가장 적절하지 않은 것은?","","2","4","업무에 의해 만들어지는 식별자를 본질식별자라고 한다."
"781","다음이 설명하는 데이터 무결성의 종류는?","테이블의 기본키를 구성하는 컬럼은 NULL 값이나 중복값을 가질 수 없다.","4","1","NULL 무결성"
"781","다음이 설명하는 데이터 무결성의 종류는?","테이블의 기본키를 구성하는 컬럼은 NULL 값이나 중복값을 가질 수 없다.","4","2","도메인 무결성"
"781","다음이 설명하는 데이터 무결성의 종류는?","테이블의 기본키를 구성하는 컬럼은 NULL 값이나 중복값을 가질 수 없다.","4","3","참조 무결성"
"781","다음이 설명하는 데이터 무결성의 종류는?","테이블의 기본키를 구성하는 컬럼은 NULL 값이나 중복값을 가질 수 없다.","4","4","개체 무결성"
"792","다음 GROUP BY에 대한 설명 중 가장 적절하지 않은 것은?","","3","1","GROUP BY 절에 사용하지 않은 컬럼은 SUM과 같은 집계함수와 함께 SELECT절에 사용 가능하다."
"792","다음 GROUP BY에 대한 설명 중 가장 적절하지 않은 것은?","","3","2","GROUP BY 뒤의 첫 번째 값이 UNIQUE한 경우 뒤에 어떤 컬럼을 추가적으로 명시해도 그룹의 수는 변화없다."
"792","다음 GROUP BY에 대한 설명 중 가장 적절하지 않은 것은?","","3","3","GROUP BY 뒤의 컬럼 순서에 따라 출력되는 그룹의 수가 달라진다."
"792","다음 GROUP BY에 대한 설명 중 가장 적절하지 않은 것은?","","3","4","GROUP BY 절에는 컬럼 별칭을 사용할 수 없다."
"798","5개의 테이블 조인 시 조인 조건의 최소 개수는?","","1","1","4"
"798","5개의 테이블 조인 시 조인 조건의 최소 개수는?","","1","2","3"
"798","5개의 테이블 조인 시 조인 조건의 최소 개수는?","","1","3","2"
"798","5개의 테이블 조인 시 조인 조건의 최소 개수는?","","1","4","1"
"253","서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","1","서브쿼리는 SELECT, FROM, WHERE 등에서 사용이 가능하다."
"253","서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","2","메인쿼리는 스칼라 서브쿼리의 칼럼을 쓸 수 없다."
"253","서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","3","서브쿼리는 비교 연산자와 함께 사용이 가능하다."
"253","서브쿼리에 대한 설명으로 올바르지 않은 것은?","","2","4","서브쿼리는 괄호를 사용해서 SELECT문을 감싸서 사용하는 것이다."
"254","""TEST"" 테이블에 있는 NUM2 칼럼의 총 행은 10개이고 2개의 NULL 값이 있다. 다음의 SQL문을 실행할 경우 결괏값은?","ㄱ : SELECT COUNT(*) FROM TEST;
ㄴ : SELECT COUNT(NUM2) FROM TEST;","3","1","ㄱ:8, ㄴ:8"
"254","""TEST"" 테이블에 있는 NUM2 칼럼의 총 행은 10개이고 2개의 NULL 값이 있다. 다음의 SQL문을 실행할 경우 결괏값은?","ㄱ : SELECT COUNT(*) FROM TEST;
ㄴ : SELECT COUNT(NUM2) FROM TEST;","3","2","ㄱ:8, ㄴ:10"
"254","""TEST"" 테이블에 있는 NUM2 칼럼의 총 행은 10개이고 2개의 NULL 값이 있다. 다음의 SQL문을 실행할 경우 결괏값은?","ㄱ : SELECT COUNT(*) FROM TEST;
ㄴ : SELECT COUNT(NUM2) FROM TEST;","3","3","ㄱ:10, ㄴ:8"
"254","""TEST"" 테이블에 있는 NUM2 칼럼의 총 행은 10개이고 2개의 NULL 값이 있다. 다음의 SQL문을 실행할 경우 결괏값은?","ㄱ : SELECT COUNT(*) FROM TEST;
ㄴ : SELECT COUNT(NUM2) FROM TEST;","3","4","ㄱ:10, ㄴ:10"
"268","데이터베이스 3층 스키마에 해당 되지 않는 것은?","","3","1","내부 단계"
"268","데이터베이스 3층 스키마에 해당 되지 않는 것은?","","3","2","개념 단계"
"268","데이터베이스 3층 스키마에 해당 되지 않는 것은?","","3","3","사용 단계"
"268","데이터베이스 3층 스키마에 해당 되지 않는 것은?","","3","4","외부 단계"
"803","논리적 데이터 모델링 단계에서 수행하는 주요 작업은 무엇인가?","","1","1","속성 정제 및 도메인 정의"
"803","논리적 데이터 모델링 단계에서 수행하는 주요 작업은 무엇인가?","","1","2","테이블 생성"
"803","논리적 데이터 모델링 단계에서 수행하는 주요 작업은 무엇인가?","","1","3","화면 설계"
"803","논리적 데이터 모델링 단계에서 수행하는 주요 작업은 무엇인가?","","1","4","하드웨어 구조 분석"
"808","약한 엔터티(Weak Entity)의 특징은?","","3","1","기본 키가 있음"
"808","약한 엔터티(Weak Entity)의 특징은?","","3","2","독립적으로 존재 가능"
"808","약한 엔터티(Weak Entity)의 특징은?","","3","3","강한 엔터티에 의존"
"808","약한 엔터티(Weak Entity)의 특징은?","","3","4","항상 1:1 관계"
"809","식별자 관계에 대한 설명으로 옳은 것은?","","3","1","부모 엔터티의 키를 참조하지 않는다"
"809","식별자 관계에 대한 설명으로 옳은 것은?","","3","2","자식 엔터티가 부모 없이 독립 가능하다"
"809","식별자 관계에 대한 설명으로 옳은 것은?","","3","3","자식의 기본키에 부모의 키가 포함된다"
"809","식별자 관계에 대한 설명으로 옳은 것은?","","3","4","비식별 관계보다 느슨한 관계이다"
"812","정규형(Normal Form)의 올바른 순서는?","","2","1","2NF → 1NF → 3NF"
"812","정규형(Normal Form)의 올바른 순서는?","","2","2","1NF → 2NF → 3NF"
"812","정규형(Normal Form)의 올바른 순서는?","","2","3","3NF → 2NF → 1NF"
"812","정규형(Normal Form)의 올바른 순서는?","","2","4","1NF → 3NF → 2NF"
"12","다음 중 다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지며 사원, 부서, 고객, 상품, 자재 등이 예가 될 수 있는 엔터티로 가장 적절한 것은?","","4","1","개념 엔터티"
"12","다음 중 다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지며 사원, 부서, 고객, 상품, 자재 등이 예가 될 수 있는 엔터티로 가장 적절한 것은?","","4","2","행위 엔터티"
"12","다음 중 다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지며 사원, 부서, 고객, 상품, 자재 등이 예가 될 수 있는 엔터티로 가장 적절한 것은?","","4","3","중심 엔터티(메인엔터티)"
"12","다음 중 다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지며 사원, 부서, 고객, 상품, 자재 등이 예가 될 수 있는 엔터티로 가장 적절한 것은?","","4","4","기본 엔터티(키엔터티)"
"38","다음 중 데이터 제어어(DCL)에 해당하는 명령어는?","","1","1","REVOKE"
"38","다음 중 데이터 제어어(DCL)에 해당하는 명령어는?","","1","2","COMMIT"
"38","다음 중 데이터 제어어(DCL)에 해당하는 명령어는?","","1","3","RENAME"
"38","다음 중 데이터 제어어(DCL)에 해당하는 명령어는?","","1","4","INSERT"
"56","개발 프로젝트의 표준은 모든 삭제 데이터에 대한 로그를남가는것을 원칙으로 하고, 테이블 삭제의 경우는 허가된 인력만이 정기적으로 수행 가능하도록 정하고 있다. 개발팀에서 사용 용도가 없다고 판단한 STADIUM 테이블의 데이터를 삭제하는 가장 좋은 방법은 무엇인가?","","4","1","DROP TABLE STADIUM;"
"56","개발 프로젝트의 표준은 모든 삭제 데이터에 대한 로그를남가는것을 원칙으로 하고, 테이블 삭제의 경우는 허가된 인력만이 정기적으로 수행 가능하도록 정하고 있다. 개발팀에서 사용 용도가 없다고 판단한 STADIUM 테이블의 데이터를 삭제하는 가장 좋은 방법은 무엇인가?","","4","2","TRUNCATE TABLE STADIUM;"
"56","개발 프로젝트의 표준은 모든 삭제 데이터에 대한 로그를남가는것을 원칙으로 하고, 테이블 삭제의 경우는 허가된 인력만이 정기적으로 수행 가능하도록 정하고 있다. 개발팀에서 사용 용도가 없다고 판단한 STADIUM 테이블의 데이터를 삭제하는 가장 좋은 방법은 무엇인가?","","4","3","DELETE * FROM STADIUM;"
"56","개발 프로젝트의 표준은 모든 삭제 데이터에 대한 로그를남가는것을 원칙으로 하고, 테이블 삭제의 경우는 허가된 인력만이 정기적으로 수행 가능하도록 정하고 있다. 개발팀에서 사용 용도가 없다고 판단한 STADIUM 테이블의 데이터를 삭제하는 가장 좋은 방법은 무엇인가?","","4","4","DELETE FROM STADIUM;"
"58","다음 중 DELETE 와 TRUNCATE, DROP 명령어에 대해 비교한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,4","1","DROP은 Auto Commit 되고, DELETE와 TRUNCATE는 사용자 Commit으로 수행된다."
"58","다음 중 DELETE 와 TRUNCATE, DROP 명령어에 대해 비교한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,4","2","TRUNCATE 명령어는 UNDO를 위한 데이터를 생성하지 않기 때문에 동일 데이터량 삭제시 DELETE보다 빠르다."
"58","다음 중 DELETE 와 TRUNCATE, DROP 명령어에 대해 비교한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,4","3","DROP 명령어는 테이블 정의 자체를 삭제하고, TRUNCATE 명령어는 테이블을 초기상태로 만든다."
"58","다음 중 DELETE 와 TRUNCATE, DROP 명령어에 대해 비교한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,4","4","특정 테이블에 대하여 WHERE 조건절이 없는 DELETE 명령을 수행하면 DROP TABLE 명령을 수행했을 때와 똑같은 결과를 얻을 수 있다."
"59","데이터베이스 트랜잭션에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,3","1","지속성(durability) : 트랜잭션이 실행 되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다."
"59","데이터베이스 트랜잭션에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,3","2","고립성(isolation) ： 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다."
"59","데이터베이스 트랜잭션에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,3","3","일관성(consistency) ： 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다."
"59","데이터베이스 트랜잭션에 대한 설명으로 가장 부적절한 것을 2개 고르시오.","","1,3","4","원자성(atomicity) ： 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다."
"82","다음 SQL 중 오류가 발생하는 것은?","","2","1","SELECT 지역, SUM(매출금액) AS 매출금액
FROM 지역별매출
GROUP BY 지역
HAVING SUM(매출금액) > 1000
ORDER BY COUNT(*) ASC;"
"82","다음 SQL 중 오류가 발생하는 것은?","","2","2","SELECT 지역, SUM(매출금액) AS 매출금액
FROM 지역별매출
GROUP BY 지역
ORDER BY 년 DESC;"
"82","다음 SQL 중 오류가 발생하는 것은?","","2","3","SELECT 지역, 매출금액
FROM 지역별매출
ORDER BY 년 ASC;"
"82","다음 SQL 중 오류가 발생하는 것은?","","2","4","SELECT 지역, SUM(매출금액) AS 매출금액
FROM 지역별매출
GROUP BY 지역
ORDER BY 매출금액 DESC;"
"115","아래 테이블은 어느 회사의 사원들과 이들이 부양하는 가족에 대한 것으로 밑줄 친 칼럼은 기본키(Primary Key)를 표시한 것이다. 다음 중 '현재 부양하는 가족들이 없는 사원들의 이름을 구하라'는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 내용으로 가장 적절한 것은?","[테이블]
사원 (사번, 이름, 나이)
가족 (이름, 나이, 부양사번)
* 가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래키(Foreign Key) 이다.
[SQL 문장]
SELECT 이름
FROM 사원
WHERE (ㄱ) (SELECT * FROM 가족 WHERE (ㄴ))","2","1","(ㄱ) : NOT EXISTS (ㄴ) : 사번 <> 부양사번"
"115","아래 테이블은 어느 회사의 사원들과 이들이 부양하는 가족에 대한 것으로 밑줄 친 칼럼은 기본키(Primary Key)를 표시한 것이다. 다음 중 '현재 부양하는 가족들이 없는 사원들의 이름을 구하라'는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 내용으로 가장 적절한 것은?","[테이블]
사원 (사번, 이름, 나이)
가족 (이름, 나이, 부양사번)
* 가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래키(Foreign Key) 이다.
[SQL 문장]
SELECT 이름
FROM 사원
WHERE (ㄱ) (SELECT * FROM 가족 WHERE (ㄴ))","2","2","(ㄱ) : NOT EXISTS (ㄴ) : 사번 = 부양사번"
"115","아래 테이블은 어느 회사의 사원들과 이들이 부양하는 가족에 대한 것으로 밑줄 친 칼럼은 기본키(Primary Key)를 표시한 것이다. 다음 중 '현재 부양하는 가족들이 없는 사원들의 이름을 구하라'는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 내용으로 가장 적절한 것은?","[테이블]
사원 (사번, 이름, 나이)
가족 (이름, 나이, 부양사번)
* 가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래키(Foreign Key) 이다.
[SQL 문장]
SELECT 이름
FROM 사원
WHERE (ㄱ) (SELECT * FROM 가족 WHERE (ㄴ))","2","3","(ㄱ) : EXISTS (ㄴ) : 사번 <> 부양사번"
"115","아래 테이블은 어느 회사의 사원들과 이들이 부양하는 가족에 대한 것으로 밑줄 친 칼럼은 기본키(Primary Key)를 표시한 것이다. 다음 중 '현재 부양하는 가족들이 없는 사원들의 이름을 구하라'는 질의에 대해 아래 SQL 문장의 (ㄱ), (ㄴ) 에 들어 갈 내용으로 가장 적절한 것은?","[테이블]
사원 (사번, 이름, 나이)
가족 (이름, 나이, 부양사번)
* 가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래키(Foreign Key) 이다.
[SQL 문장]
SELECT 이름
FROM 사원
WHERE (ㄱ) (SELECT * FROM 가족 WHERE (ㄴ))","2","4","(ㄱ) : EXISTS (ㄴ) : 사번 = 부양사번"
"130","다음 중 윈도우 함수 (Window Function, Analytic Function)에 대한 설명으로 가장 부적절한 것은?","","2","1","윈도우 함수 적용 범위는 Partition을 넘을 수 없다."
"130","다음 중 윈도우 함수 (Window Function, Analytic Function)에 대한 설명으로 가장 부적절한 것은?","","2","2","윈도우 함수 처리로 인해 결과 건수가 줄어든다."
"130","다음 중 윈도우 함수 (Window Function, Analytic Function)에 대한 설명으로 가장 부적절한 것은?","","2","3","Partition 구문이 없으면 전체 집합을 하나의 Partition으로 정의한 것과 동일하다."
"130","다음 중 윈도우 함수 (Window Function, Analytic Function)에 대한 설명으로 가장 부적절한 것은?","","2","4","Partition과 Group By 구문은 의미적으로 유사하다."
"137","다음 중 B_User가 아래의 직업을 수행할 수있도록 권한을 부여하는 DCL로 가장 적절한 것은?","UPDATE A_User.TB_A 
SET col1='AAA' 
WHERE col2=3","1","1","GRANT SELECT, UPDATE ON A_User.TB_A TO B_User;"
"137","다음 중 B_User가 아래의 직업을 수행할 수있도록 권한을 부여하는 DCL로 가장 적절한 것은?","UPDATE A_User.TB_A 
SET col1='AAA' 
WHERE col2=3","1","2","DENY UPDATE ON A_User.TB_A TO B_User;"
"137","다음 중 B_User가 아래의 직업을 수행할 수있도록 권한을 부여하는 DCL로 가장 적절한 것은?","UPDATE A_User.TB_A 
SET col1='AAA' 
WHERE col2=3","1","3","REVOKE SELECT ON A_User.TB_A FROM B_User;"
"137","다음 중 B_User가 아래의 직업을 수행할 수있도록 권한을 부여하는 DCL로 가장 적절한 것은?","UPDATE A_User.TB_A 
SET col1='AAA' 
WHERE col2=3","1","4","GRANT SELECT, UPDATE TO B_User;"
"138","사용자 Lee가 릴레이션 R을 생성한 후,이래와 같은 권한부여 SQL문들을 실행하였다. 그 이후에 가능이 실행 가능한 SQL을 2개 고르시오. (단, A, B의 데이터 타입은 정수형이다)","Lee :GRANT SELECT, INSERT, DELETE ON R TO Kim WITH
 GRANT OPTION;
kim :GRANT SELECT, INSERT, DELETE ON R TO Park；
Lee: REVOKE DELETE ON R FROM Kim;
Lee:REVOKE INSERT ON R FROM Kim CASCADE;","2,4","1","Kim : INSERT INTO R VALUES(500, 600);"
"138","사용자 Lee가 릴레이션 R을 생성한 후,이래와 같은 권한부여 SQL문들을 실행하였다. 그 이후에 가능이 실행 가능한 SQL을 2개 고르시오. (단, A, B의 데이터 타입은 정수형이다)","Lee :GRANT SELECT, INSERT, DELETE ON R TO Kim WITH
 GRANT OPTION;
kim :GRANT SELECT, INSERT, DELETE ON R TO Park；
Lee: REVOKE DELETE ON R FROM Kim;
Lee:REVOKE INSERT ON R FROM Kim CASCADE;","2,4","2","Park : DELETE FROM R WHERE B = 800;"
"138","사용자 Lee가 릴레이션 R을 생성한 후,이래와 같은 권한부여 SQL문들을 실행하였다. 그 이후에 가능이 실행 가능한 SQL을 2개 고르시오. (단, A, B의 데이터 타입은 정수형이다)","Lee :GRANT SELECT, INSERT, DELETE ON R TO Kim WITH
 GRANT OPTION;
kim :GRANT SELECT, INSERT, DELETE ON R TO Park；
Lee: REVOKE DELETE ON R FROM Kim;
Lee:REVOKE INSERT ON R FROM Kim CASCADE;","2,4","3","Park : INSERT INTO R VALUES(400, 600);"
"138","사용자 Lee가 릴레이션 R을 생성한 후,이래와 같은 권한부여 SQL문들을 실행하였다. 그 이후에 가능이 실행 가능한 SQL을 2개 고르시오. (단, A, B의 데이터 타입은 정수형이다)","Lee :GRANT SELECT, INSERT, DELETE ON R TO Kim WITH
 GRANT OPTION;
kim :GRANT SELECT, INSERT, DELETE ON R TO Park；
Lee: REVOKE DELETE ON R FROM Kim;
Lee:REVOKE INSERT ON R FROM Kim CASCADE;","2,4","4","Park : SELECT * FROM R WHERE A = 400;"
"146","다음 중 엔터티의 특징에 포함되지 않는 것은?","","2","1","엔터티는 업무 프로세스에 의해 이용되어야 한다."
"146","다음 중 엔터티의 특징에 포함되지 않는 것은?","","2","2","엔터티는 속성이 없어도 된다."
"146","다음 중 엔터티의 특징에 포함되지 않는 것은?","","2","3","유일한 식별자에 의해 식별이 가능해야 한다."
"146","다음 중 엔터티의 특징에 포함되지 않는 것은?","","2","4","반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다."
"150","식별자의 대체 여부에 따라 분류하는 방식은?","","4","1","단일 식별자 - 복합 식별자"
"150","식별자의 대체 여부에 따라 분류하는 방식은?","","4","2","주식별자 - 보조 식별자"
"150","식별자의 대체 여부에 따라 분류하는 방식은?","","4","3","내부 식별자 - 외부 식별자"
"150","식별자의 대체 여부에 따라 분류하는 방식은?","","4","4","본질 식별자 - 인조 식별자"
"169","데이터 모델링이 최종적으로 완료된 상태라고 정의할 수 있는, 즉 물리적인 스키마 설계를 하기 전 단계를 가리키는 말은?","","3","1","개념적 데이터 모델링"
"169","데이터 모델링이 최종적으로 완료된 상태라고 정의할 수 있는, 즉 물리적인 스키마 설계를 하기 전 단계를 가리키는 말은?","","3","2","개괄 데이터 모델링"
"169","데이터 모델링이 최종적으로 완료된 상태라고 정의할 수 있는, 즉 물리적인 스키마 설계를 하기 전 단계를 가리키는 말은?","","3","3","논리적 데이터 모델링"
"169","데이터 모델링이 최종적으로 완료된 상태라고 정의할 수 있는, 즉 물리적인 스키마 설계를 하기 전 단계를 가리키는 말은?","","3","4","물리적 데이터 모델링"
"186","일반적으로 FROM절에 정의된 후 먼저 수행되어 SQL 문장 내에서 절차성을 주는 효과를 볼 수 있는 것은 어떤 유형의 서브쿼리 문장인가?","","3","1","NESTED SUBQUERY"
"186","일반적으로 FROM절에 정의된 후 먼저 수행되어 SQL 문장 내에서 절차성을 주는 효과를 볼 수 있는 것은 어떤 유형의 서브쿼리 문장인가?","","3","2","CORRELATED SUBQUERY"
"186","일반적으로 FROM절에 정의된 후 먼저 수행되어 SQL 문장 내에서 절차성을 주는 효과를 볼 수 있는 것은 어떤 유형의 서브쿼리 문장인가?","","3","3","INLINE VIEW"
"186","일반적으로 FROM절에 정의된 후 먼저 수행되어 SQL 문장 내에서 절차성을 주는 효과를 볼 수 있는 것은 어떤 유형의 서브쿼리 문장인가?","","3","4","SCALAR SUBQUERY"
"188","소계, 중계, 합계처럼 계층적 분류를 포함하고 있는 데이터의 집계에 적합한 GROUP 함수 두 가지는 무엇인가?","","2","1","CUBE, SUM"
"188","소계, 중계, 합계처럼 계층적 분류를 포함하고 있는 데이터의 집계에 적합한 GROUP 함수 두 가지는 무엇인가?","","2","2","ROLLUP, CUBE"
"188","소계, 중계, 합계처럼 계층적 분류를 포함하고 있는 데이터의 집계에 적합한 GROUP 함수 두 가지는 무엇인가?","","2","3","GROUPING, SUM"
"188","소계, 중계, 합계처럼 계층적 분류를 포함하고 있는 데이터의 집계에 적합한 GROUP 함수 두 가지는 무엇인가?","","2","4","ROLLUP, SUM"
"232","ANSI/ISO 표준 SQL에서 두 테이블 간에 동일한 칼럼 이름을 가지는 것을 모두 출력하는 조인 방식은 무엇인가?","","2","1","Using"
"232","ANSI/ISO 표준 SQL에서 두 테이블 간에 동일한 칼럼 이름을 가지는 것을 모두 출력하는 조인 방식은 무엇인가?","","2","2","Natural Join"
"232","ANSI/ISO 표준 SQL에서 두 테이블 간에 동일한 칼럼 이름을 가지는 것을 모두 출력하는 조인 방식은 무엇인가?","","2","3","Cross Join"
"232","ANSI/ISO 표준 SQL에서 두 테이블 간에 동일한 칼럼 이름을 가지는 것을 모두 출력하는 조인 방식은 무엇인가?","","2","4","Inner Join"
"281","다음 중 계층형 쿼리문의 내장 함수가 아닌 것은 무엇인가?","","3","1","CONNECT_BY_ROOT"
"281","다음 중 계층형 쿼리문의 내장 함수가 아닌 것은 무엇인가?","","3","2","SYS_CONNECT_BY_PATH"
"281","다음 중 계층형 쿼리문의 내장 함수가 아닌 것은 무엇인가?","","3","3","TRIM"
"281","다음 중 계층형 쿼리문의 내장 함수가 아닌 것은 무엇인가?","","3","4","LEVEL"
"316","정규화를 수행하지 않고 엔터티에 데이터를 입력할 때 불필요한 데이터를 같이 입력하거나 삭제하면 다른 데이터까지 같이 삭제되는 문제는?","","2","1","연결 함정"
"316","정규화를 수행하지 않고 엔터티에 데이터를 입력할 때 불필요한 데이터를 같이 입력하거나 삭제하면 다른 데이터까지 같이 삭제되는 문제는?","","2","2","이상현상"
"316","정규화를 수행하지 않고 엔터티에 데이터를 입력할 때 불필요한 데이터를 같이 입력하거나 삭제하면 다른 데이터까지 같이 삭제되는 문제는?","","2","3","제2정규화"
"316","정규화를 수행하지 않고 엔터티에 데이터를 입력할 때 불필요한 데이터를 같이 입력하거나 삭제하면 다른 데이터까지 같이 삭제되는 문제는?","","2","4","제3정규화"
"317","다음 중 3차 정규화에 대한 설명으로 가장 올바른 것은?","","1","1","이행함수 종속성을 제거"
"317","다음 중 3차 정규화에 대한 설명으로 가장 올바른 것은?","","1","2","다치종속성을 제거"
"317","다음 중 3차 정규화에 대한 설명으로 가장 올바른 것은?","","1","3","복합 속성으로 구성된 식별자에 대해 부분적인 속성으로도 식별이 되는 부분 종속성을 제거"
"317","다음 중 3차 정규화에 대한 설명으로 가장 올바른 것은?","","1","4","속성의 원자값 제거"
"319","데이터베이스 파티션 기법 중 날짜 및 숫자처럼 연속된 값을 기준으로 만드는 파티션 기법은?","","4","1","Composite Partition"
"319","데이터베이스 파티션 기법 중 날짜 및 숫자처럼 연속된 값을 기준으로 만드는 파티션 기법은?","","4","2","Hash Partition"
"319","데이터베이스 파티션 기법 중 날짜 및 숫자처럼 연속된 값을 기준으로 만드는 파티션 기법은?","","4","3","List Partition"
"319","데이터베이스 파티션 기법 중 날짜 및 숫자처럼 연속된 값을 기준으로 만드는 파티션 기법은?","","4","4","Range Partition"
"320","다음은 데이터베이스 모델링 단계에 대한 설명이다. 올바르지 않은 것은?","","4","1","개념적 모델링 이후에 구체적인 업무 중심의 모델링과 정규화를 수행하는 단계가 논리적 모델링 단계이다."
"320","다음은 데이터베이스 모델링 단계에 대한 설명이다. 올바르지 않은 것은?","","4","2","데이터베이스 모델링 단계는 개념적, 논리적, 물리적 단계로 수행하고 개념적 단계부터 물리적 모델링 진행될수록 상세화된다."
"320","다음은 데이터베이스 모델링 단계에 대한 설명이다. 올바르지 않은 것은?","","4","3","성능, 데이터 저장 방법 등을 고려하는 모델링은 물리적 모델링이다."
"320","다음은 데이터베이스 모델링 단계에 대한 설명이다. 올바르지 않은 것은?","","4","4","개념적 데이터베이스 모델링은 추상화 수준이 낮고 재사용성이 매우 높은 모델링 방법이다."
"325","다음 중 SQL문의 실행 순서로 올바른 것은?","","3","1","FROM -> WHERE -> GROUP BY -> SELECT -> HAVING -> ORDER BY"
"325","다음 중 SQL문의 실행 순서로 올바른 것은?","","3","2","FROM -> WHERE -> HAVING -> GROUP BY -> ORDER BY -> SELECT"
"325","다음 중 SQL문의 실행 순서로 올바른 것은?","","3","3","FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY"
"325","다음 중 SQL문의 실행 순서로 올바른 것은?","","3","4","FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY -> SELECT"
"330","다음 중 LIKE문에서 세 번째 문자가 'K'인 문자열을 조회하는 것으로 가장 올바른 것은?","","1","1","SELECT * FROM EMP WHERE like '_ _K%'"
"330","다음 중 LIKE문에서 세 번째 문자가 'K'인 문자열을 조회하는 것으로 가장 올바른 것은?","","1","2","SELECT * FROM EMP WHERE like '[_ _K]%'"
"330","다음 중 LIKE문에서 세 번째 문자가 'K'인 문자열을 조회하는 것으로 가장 올바른 것은?","","1","3","SELECT * FROM EMP WHERE like '%K%'"
"330","다음 중 LIKE문에서 세 번째 문자가 'K'인 문자열을 조회하는 것으로 가장 올바른 것은?","","1","4","SELECT * FROM EMP WHERE like 'K%'"
"332","다음 중 세 번째 문자가 'N'인 문자열을 검색하는  조건으로 적절한 것은?","","1","1","SELECT * FROM 테이블명 WHERE like '_ _N%'"
"332","다음 중 세 번째 문자가 'N'인 문자열을 검색하는  조건으로 적절한 것은?","","1","2","SELECT * FROM 테이블명 WHERE like '[_ _N]%'"
"332","다음 중 세 번째 문자가 'N'인 문자열을 검색하는  조건으로 적절한 것은?","","1","3","SELECT * FROM 테이블명 WHERE like '%N%'"
"332","다음 중 세 번째 문자가 'N'인 문자열을 검색하는  조건으로 적절한 것은?","","1","4","SELECT * FROM 테이블명 WHERE like '_N%'"
"340","SQL문을 ANSI 표준 SQL문으로 변환한 것으로 올바른 것은?","SELECT *
FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNMAE ='KIM'","1","1","SELECT * FROM SCOTT.EMP A INNER JOIN SCOTT.DEPT B
ON A.DEPTNO = B.DEPTNO WHERE 1=1
AND B.DNAME = 'KIM';"
"340","SQL문을 ANSI 표준 SQL문으로 변환한 것으로 올바른 것은?","SELECT *
FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNMAE ='KIM'","1","2","SELECT * FROM SCOTT.EMP A INNER JOIN SCOTT.DEPT B
ON (A.DEPTNO = B.DEPTNO 
AND B.DNAME = 'KIM') WHERE 1=1;"
"340","SQL문을 ANSI 표준 SQL문으로 변환한 것으로 올바른 것은?","SELECT *
FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNMAE ='KIM'","1","3","SELECT * FROM SCOTT.EMP A RIGHT OUTER JOIN SCOTT.DEPT B
ON (A.DEPTNO = B.DEPTNO 
AND B.DNAME = 'KIM') WHERE 1=1;"
"340","SQL문을 ANSI 표준 SQL문으로 변환한 것으로 올바른 것은?","SELECT *
FROM SCOTT.EMP A, SCOTT.DEPT B
WHERE A.DEPTNO = B.DEPTNO
AND B.DNMAE ='KIM'","1","4","SELECT * FROM SCOTT.EMP A LEFT OUTER JOIN SCOTT.DEPT B
ON (A.DEPTNO = B.DEPTNO 
AND B.DNAME = 'KIM') ;"
"348","다음은 테이블 생성 시 사용하는 제약조건에 대한 설명이다. 가장 올바르지 않은 것은?","","4","1","NOT NULL : 칼럼에 NULL 값을 입력할 수 없도록 한다. 기본키의 경우 별도로 지정하지 않아도 된다."
"348","다음은 테이블 생성 시 사용하는 제약조건에 대한 설명이다. 가장 올바르지 않은 것은?","","4","2","FOREIGN KEY : 다른 테이블의 기본키를 참조한다."
"348","다음은 테이블 생성 시 사용하는 제약조건에 대한 설명이다. 가장 올바르지 않은 것은?","","4","3","PRIMARY KEY : 기본키로 테이블당 한 개만 생성이 가능하고 자동으로 인덱스가 생성된다."
"348","다음은 테이블 생성 시 사용하는 제약조건에 대한 설명이다. 가장 올바르지 않은 것은?","","4","4","UNIQUE : 칼럼에 중복된 값이 없을 때도 NULL 값은 입력되지 않는다."
"370","아래의 SQL문을 수행한 후 보기의 쿼리문을 실행할 때 잘못된 것은?","CREATE TABLE MYTEST (N1 NUMBER(20), N2 NUMBER(20) );
INSERT INTO MYTEST VALUES(1,100);
INSERT INTO MYTEST VALUES(2,200);
COMMIT;","1","1","SELECT N1 FROM (SELECT * FROM MYTEST) ORDER BY 2;"
"370","아래의 SQL문을 수행한 후 보기의 쿼리문을 실행할 때 잘못된 것은?","CREATE TABLE MYTEST (N1 NUMBER(20), N2 NUMBER(20) );
INSERT INTO MYTEST VALUES(1,100);
INSERT INTO MYTEST VALUES(2,200);
COMMIT;","1","2","SELECT N1 FROM (SELECT * FROM MYTEST) ORDER BY N2;"
"370","아래의 SQL문을 수행한 후 보기의 쿼리문을 실행할 때 잘못된 것은?","CREATE TABLE MYTEST (N1 NUMBER(20), N2 NUMBER(20) );
INSERT INTO MYTEST VALUES(1,100);
INSERT INTO MYTEST VALUES(2,200);
COMMIT;","1","3","SELECT * FROM MYTEST ORDER BY 2;"
"370","아래의 SQL문을 수행한 후 보기의 쿼리문을 실행할 때 잘못된 것은?","CREATE TABLE MYTEST (N1 NUMBER(20), N2 NUMBER(20) );
INSERT INTO MYTEST VALUES(1,100);
INSERT INTO MYTEST VALUES(2,200);
COMMIT;","1","4","SELECT N1 FROM MYTEST ORDER BY N2;"
"395","다음 중 Window Function에 대한 설명으로 알맞은 것은?","","3","1","GROUP BY와 Window Function은 병행하여 사용할 수 있다."
"395","다음 중 Window Function에 대한 설명으로 알맞은 것은?","","3","2","Window Function 처리로 인해 결과 건수가 줄어들 수 있어 성능이 빠르다."
"395","다음 중 Window Function에 대한 설명으로 알맞은 것은?","","3","3","sum, min, max 등과 같은 집계 Window Function을 사용할 때 window 절과 함께 사용하면 집계의 대상이 되는 레코드 범위를 지정할 수 있다."
"395","다음 중 Window Function에 대한 설명으로 알맞은 것은?","","3","4","Window Function은 내부적으로 자동 튜닝을 실시한다."
"416","다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?","","2","1","intersect"
"416","다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?","","2","2","except"
"416","다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?","","2","3","union all"
"416","다음 중 차집합을 구할 수 있는 집합 연산자로 올바른 것은?","","2","4","union"
