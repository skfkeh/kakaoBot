"85","다음 중 SELECT 문장의 실행 순서를 올바르게 나열한 것은?","","1","1","FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY"
"85","다음 중 SELECT 문장의 실행 순서를 올바르게 나열한 것은?","","1","2","FROM - WHERE - GROUP BY - HAVING - ORDER BY - SELECT"
"85","다음 중 SELECT 문장의 실행 순서를 올바르게 나열한 것은?","","1","3","FROM - SELECT - WHERE - GROUP BY - HAVING - ORDER BY"
"85","다음 중 SELECT 문장의 실행 순서를 올바르게 나열한 것은?","","1","4","SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY"
"126","다음 설명 중 가장 적절한 것은?","","1","1","CUBE 그룹 함수는 인자로 주어진 컬럼의 결합 가능한 모든 조합에 대해서 집계를 수행하므로 다른 그룹 함수에 비해 시스템에 대한 부하가 크다."
"126","다음 설명 중 가장 적절한 것은?","","1","2","CUBE, ROLLUP, GROUPING SETS 함수들의 대상 컬럼 중 집계된 컬럼 이외의 대상 컬럼 값은 해당 컬럼의 데이터 중 가장 작은 값을 반환한다."
"126","다음 설명 중 가장 적절한 것은?","","1","3","GROUPING SETS 함수의 경우에는 함수의 인자로 주어진 컬럼의 순서에 따라 결과가 달라지므로 컬럼의 순서가 중요하다."
"126","다음 설명 중 가장 적절한 것은?","","1","4","일반 그룹 함수를 사용하여 CUBE, GROUPING SETS와 같은 그룹함수와 동일한 결과를 추출할 수 있으나, ROLLUP 그룹 함수와 동일한 결과는 추출할 수 없다."
"142","다음 중 정보시스템을 모델링할 때 세가지 관점에 해당하지 않는 것은?","모델링을 할 때의 세 가지 관점은 데이터에 대한 관점, 프로세스에 대한 관점, 그리고 데이터와 프로세스가 서로 연관성이 표현되는 상관 관점이다.","2","1","업무에서 처리하는 일의 방법에 따라 데이터가 어떻게 영향을 받는지 분석"
"142","다음 중 정보시스템을 모델링할 때 세가지 관점에 해당하지 않는 것은?","모델링을 할 때의 세 가지 관점은 데이터에 대한 관점, 프로세스에 대한 관점, 그리고 데이터와 프로세스가 서로 연관성이 표현되는 상관 관점이다.","2","2","업무를 처리할 수 있는 프로그램 구성을 어떻게 해야 하는지 분석"
"142","다음 중 정보시스템을 모델링할 때 세가지 관점에 해당하지 않는 것은?","모델링을 할 때의 세 가지 관점은 데이터에 대한 관점, 프로세스에 대한 관점, 그리고 데이터와 프로세스가 서로 연관성이 표현되는 상관 관점이다.","2","3","업무에서 실제로 하는 일은 무엇인지 또는 무엇을 해야 하는지 분석"
"142","다음 중 정보시스템을 모델링할 때 세가지 관점에 해당하지 않는 것은?","모델링을 할 때의 세 가지 관점은 데이터에 대한 관점, 프로세스에 대한 관점, 그리고 데이터와 프로세스가 서로 연관성이 표현되는 상관 관점이다.","2","4","업무가 어떤 데이터와 관련이 있는지 분석"
"155","다음 중 분산 데이터베이스의 특징으로 가장 부적절한 것은?","","1","1","처리 비용의 감소"
"155","다음 중 분산 데이터베이스의 특징으로 가장 부적절한 것은?","","1","2","오류의 잠재성 증대"
"155","다음 중 분산 데이터베이스의 특징으로 가장 부적절한 것은?","","1","3","빠른 응답 속도와 통신 비용 절감"
"155","다음 중 분산 데이터베이스의 특징으로 가장 부적절한 것은?","","1","4","지역 자치성, 점증적 시스템 용량 확장"
"182","JOIN의 종류에 대한 설명으로 틀린 것은 무엇인가?","","3","1","SELF JOIN은 하나의 테이블을 논리적으로 분리시켜 EQUI JOIN을 이용하는 방법이다."
"182","JOIN의 종류에 대한 설명으로 틀린 것은 무엇인가?","","3","2","OUTER JOIN은 JOIN 조건을 만족하지 않는 데이터도 볼 수 있는 JOIN 방법이다."
"182","JOIN의 종류에 대한 설명으로 틀린 것은 무엇인가?","","3","3","EQUI JOIN은 반드시 기본키, 외래키 관계에 의해서만 성립된다."
"182","JOIN의 종류에 대한 설명으로 틀린 것은 무엇인가?","","3","4","NON-EQUI JOIN은 등가 조건이 성립되지 않은 테이블에 JOIN을 걸어주는 방법이다."
"193","다음 주어진 SQL문을 수행한 결과 영구적으로 반영되는 것은 무엇인가?","INSERT INTO TAB1 VALUES(1);
INSERT INTO TAB1 VALUES(2);
SAVEPOINT SV1;
UPDATE TAB1 SET COL1=7 WHERE COL1=2;
INSERT INTO TAB1 VALUES(9);
SAVEPOINT SV2;
DELETE TAB1 WHERE COL1=7;
INSERT INTO TAB1 VALUES(11);
SAVEPOINT SV3;
INSERT INTO TAB1 VALUES(9);
ROLLBACK TO SV2;
COMMIT;","4","1","1,2"
"193","다음 주어진 SQL문을 수행한 결과 영구적으로 반영되는 것은 무엇인가?","INSERT INTO TAB1 VALUES(1);
INSERT INTO TAB1 VALUES(2);
SAVEPOINT SV1;
UPDATE TAB1 SET COL1=7 WHERE COL1=2;
INSERT INTO TAB1 VALUES(9);
SAVEPOINT SV2;
DELETE TAB1 WHERE COL1=7;
INSERT INTO TAB1 VALUES(11);
SAVEPOINT SV3;
INSERT INTO TAB1 VALUES(9);
ROLLBACK TO SV2;
COMMIT;","4","2","1,9,11,9"
"193","다음 주어진 SQL문을 수행한 결과 영구적으로 반영되는 것은 무엇인가?","INSERT INTO TAB1 VALUES(1);
INSERT INTO TAB1 VALUES(2);
SAVEPOINT SV1;
UPDATE TAB1 SET COL1=7 WHERE COL1=2;
INSERT INTO TAB1 VALUES(9);
SAVEPOINT SV2;
DELETE TAB1 WHERE COL1=7;
INSERT INTO TAB1 VALUES(11);
SAVEPOINT SV3;
INSERT INTO TAB1 VALUES(9);
ROLLBACK TO SV2;
COMMIT;","4","3","1,9,11"
"193","다음 주어진 SQL문을 수행한 결과 영구적으로 반영되는 것은 무엇인가?","INSERT INTO TAB1 VALUES(1);
INSERT INTO TAB1 VALUES(2);
SAVEPOINT SV1;
UPDATE TAB1 SET COL1=7 WHERE COL1=2;
INSERT INTO TAB1 VALUES(9);
SAVEPOINT SV2;
DELETE TAB1 WHERE COL1=7;
INSERT INTO TAB1 VALUES(11);
SAVEPOINT SV3;
INSERT INTO TAB1 VALUES(9);
ROLLBACK TO SV2;
COMMIT;","4","4","1,7,9"
"231","다음 중에서 집합 연산자의 종류에 해당되지 않은 것을 고르시오.","","2","1","Except"
"231","다음 중에서 집합 연산자의 종류에 해당되지 않은 것을 고르시오.","","2","2","Project"
"231","다음 중에서 집합 연산자의 종류에 해당되지 않은 것을 고르시오.","","2","3","Union"
"231","다음 중에서 집합 연산자의 종류에 해당되지 않은 것을 고르시오.","","2","4","Union all"
"272","다음에서 설명하는 DDL문으로 올바른 것은?","Mytest 테이블 칼럼을 데이터 타입 조건으로 not null을 기본으로 수정하시오.","2","1","ALTER table Mytest add
constraint column 칼럼명
default not null"
"272","다음에서 설명하는 DDL문으로 올바른 것은?","Mytest 테이블 칼럼을 데이터 타입 조건으로 not null을 기본으로 수정하시오.","2","2","ALTER table Mytest modify (칼럼명 not null)"
"272","다음에서 설명하는 DDL문으로 올바른 것은?","Mytest 테이블 칼럼을 데이터 타입 조건으로 not null을 기본으로 수정하시오.","2","3","ALTER table Mytest add column 칼럼명 default not null"
"272","다음에서 설명하는 DDL문으로 올바른 것은?","Mytest 테이블 칼럼을 데이터 타입 조건으로 not null을 기본으로 수정하시오.","2","4","ALTER table Mytest alter column 칼럼명 not null"
"282","다음 중 SQL문의 실행 순서로 올바른 것은?","","1","1","FROM-WHERE-GROUP BY-HAVING-SELECT-ORDER BY"
"282","다음 중 SQL문의 실행 순서로 올바른 것은?","","1","2","FROM-WHERE-GROUP BY-SELECT-HAVING-ORDER BY"
"282","다음 중 SQL문의 실행 순서로 올바른 것은?","","1","3","FROM-WHERE-HAVING-GROUP BY-ORDER BY-SELECT"
"282","다음 중 SQL문의 실행 순서로 올바른 것은?","","1","4","FROM-WHERE-GROUP BY-HAVING-ORDER BY-SELECT"
"326","다음 중 Oracle과 SQL Server의 트랜잭션 처리 방식에 대한 설명으로 올바르지 않은 것은?","","1","1","Oracle에서 INSERT를 실행하면 자동적으로 COMMIT까지 완료된다."
"326","다음 중 Oracle과 SQL Server의 트랜잭션 처리 방식에 대한 설명으로 올바르지 않은 것은?","","1","2","암시적(묵시적) 트랜잭션 처리는 트랜잭션이 자동으로 시작되며 자동으로 완료 혹은 취소되는 것이다."
"326","다음 중 Oracle과 SQL Server의 트랜잭션 처리 방식에 대한 설명으로 올바르지 않은 것은?","","1","3","명시적 트랜잭션의 시작과 끝은 모두 SQL을 실행하는 사용자가 지정한다."
"326","다음 중 Oracle과 SQL Server의 트랜잭션 처리 방식에 대한 설명으로 올바르지 않은 것은?","","1","4","SQL의 DML과 DDL을 실행할 때 COMMIT을 자동으로 처리하는 것이 AUTO COMMIT이다."
"337","다음 중 해시 조인에 대해서 올바르지 않은 것은?","","2","1","조인 칼럼에 인덱스가 없어도 사용이 가능하다."
"337","다음 중 해시 조인에 대해서 올바르지 않은 것은?","","2","2","Equal Join 과 Non-Equal Join 모두 사용이 가능하다."
"337","다음 중 해시 조인에 대해서 올바르지 않은 것은?","","2","3","해시 조인을 위해서 해시 함수를 사용하기 때문에 CPU를 많이 사용한다."
"337","다음 중 해시 조인에 대해서 올바르지 않은 것은?","","2","4","해시 조인 시에 선행 테이블은 작은 테이블이 먼저와야 한다."
"357","DEPT 테이블에는 총4개의 데이터가 있다. 다음의 SQL문을 실행하면 총 몇 개의 행이 조회되는가?","SELECT * FROM DEPT CROSS JOIN DEPT;","1","1","16"
"357","DEPT 테이블에는 총4개의 데이터가 있다. 다음의 SQL문을 실행하면 총 몇 개의 행이 조회되는가?","SELECT * FROM DEPT CROSS JOIN DEPT;","1","2","12"
"357","DEPT 테이블에는 총4개의 데이터가 있다. 다음의 SQL문을 실행하면 총 몇 개의 행이 조회되는가?","SELECT * FROM DEPT CROSS JOIN DEPT;","1","3","8"
"357","DEPT 테이블에는 총4개의 데이터가 있다. 다음의 SQL문을 실행하면 총 몇 개의 행이 조회되는가?","SELECT * FROM DEPT CROSS JOIN DEPT;","1","4","4"
"390","다음 SQL문을 실행했을 때 오류가 발생하는 것은?","CREATE TABLE T_ORDER(
C1 NUMBER(10),
C2 DATE,
C3 VARCHAR(10),
C4 NUMBER DEFAULT 1000
);","4","1","UPDATE T_ORDER SET C1=1"
"390","다음 SQL문을 실행했을 때 오류가 발생하는 것은?","CREATE TABLE T_ORDER(
C1 NUMBER(10),
C2 DATE,
C3 VARCHAR(10),
C4 NUMBER DEFAULT 1000
);","4","2","DELETE FROM T_ORDER"
"390","다음 SQL문을 실행했을 때 오류가 발생하는 것은?","CREATE TABLE T_ORDER(
C1 NUMBER(10),
C2 DATE,
C3 VARCHAR(10),
C4 NUMBER DEFAULT 1000
);","4","3","DELETE T_ORDER"
"390","다음 SQL문을 실행했을 때 오류가 발생하는 것은?","CREATE TABLE T_ORDER(
C1 NUMBER(10),
C2 DATE,
C3 VARCHAR(10),
C4 NUMBER DEFAULT 1000
);","4","4","INSERT INTO T_ORDER VALUES(2, SYSDATE-1, 'ABC')"
"409","다음 중 UNION구에 대한 설명으로 가장 올바른 것은?","","4","1","정렬을 수행하지 않고 교집합을 생성한다."
"409","다음 중 UNION구에 대한 설명으로 가장 올바른 것은?","","4","2","UNION구는 두 개의 테이블에 포함된 모든 행을 검색한다."
"409","다음 중 UNION구에 대한 설명으로 가장 올바른 것은?","","4","3","두 개의 테이블을 UNION하면 중복행은 제거되지 않으므로 UNION은 SORT를 유발한다."
"409","다음 중 UNION구에 대한 설명으로 가장 올바른 것은?","","4","4","두 개의 테이블을 UNION하면 중복행은 제거되므로 UNION은 SORT를 유발한다."
"418","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","4","1","PL/SQL은 절차형 언어이다."
"418","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","4","2","User Stored Procedure, User Defined Function, Trigger 등의 객체를 PL/SQL로 생성할 수 있다."
"418","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","4","3","변수와 상수 등을 사용해서 일반 SELECT 문장을 실행할 때 WHERE절의 조건을 대입할 수 있다."
"418","다음 중 PL/SQL에 대한 설명으로 적절하지 않은 것은?","","4","4","PL/SQL문의 기본 구조로 DECLARE, BEGIN ~ END, EXCEPTION은 반드시 사용해야 한다."
"430","다음 중 문자열의 m번째 위치에서 n개의 길이에 해당하는 문자열을 반환하는 함수는?","","1","1","SUBSTR(문자열,M,N)"
"430","다음 중 문자열의 m번째 위치에서 n개의 길이에 해당하는 문자열을 반환하는 함수는?","","1","2","STRING_SPLIT(문자열,M,N)"
"430","다음 중 문자열의 m번째 위치에서 n개의 길이에 해당하는 문자열을 반환하는 함수는?","","1","3","CONCAT(문자열,M,N)"
"430","다음 중 문자열의 m번째 위치에서 n개의 길이에 해당하는 문자열을 반환하는 함수는?","","1","4","TRIM(문자열,M,N)"
"436","다음의 SQL문 실행 결과를 고르시오.","SELECT ROUND(3.47,1)
AS DATA1 FROM DUAL;","3","1","4"
"436","다음의 SQL문 실행 결과를 고르시오.","SELECT ROUND(3.47,1)
AS DATA1 FROM DUAL;","3","2","3"
"436","다음의 SQL문 실행 결과를 고르시오.","SELECT ROUND(3.47,1)
AS DATA1 FROM DUAL;","3","3","3,5"
"436","다음의 SQL문 실행 결과를 고르시오.","SELECT ROUND(3.47,1)
AS DATA1 FROM DUAL;","3","4","3,4"
"437","다음 중 ROWID에 대한 설명으로 올바르지 않은 것은?","","4","1","오브젝트 번호, 상대파일 번호, 블록 번호, 데이터 번호로 구성된다."
"437","다음 중 ROWID에 대한 설명으로 올바르지 않은 것은?","","4","2","ROWID를 사용하면 조회를 원하는 블록을 바로 참조할 수 있다."
"437","다음 중 ROWID에 대한 설명으로 올바르지 않은 것은?","","4","3","ROWID는 ORACLE 데이터베이스 내에서 데이터를 구분할 수 있는 유일한 값이다."
"437","다음 중 ROWID에 대한 설명으로 올바르지 않은 것은?","","4","4","ORACLE 데이터베이스가 내부적으로 관리하는 값이기 때문에, 개발자가 ROWID 값을 확인할 수 없다."
"447","ERD 작성 순서로 올바른 것을 고르시오.","가) 엔터티를 그린다.
나) 엔터티를 적절하게 배치한다.
다) 엔터티 간에 관계를 설정한다.
라) 관계명을 기술한다.
마) 관계의 참여도를 기술한다.
바) 관계의 필수 여부를 기술한다.","4","1","가->나->다->마->바->라"
"447","ERD 작성 순서로 올바른 것을 고르시오.","가) 엔터티를 그린다.
나) 엔터티를 적절하게 배치한다.
다) 엔터티 간에 관계를 설정한다.
라) 관계명을 기술한다.
마) 관계의 참여도를 기술한다.
바) 관계의 필수 여부를 기술한다.","4","2","가->나->라->다->마->바"
"447","ERD 작성 순서로 올바른 것을 고르시오.","가) 엔터티를 그린다.
나) 엔터티를 적절하게 배치한다.
다) 엔터티 간에 관계를 설정한다.
라) 관계명을 기술한다.
마) 관계의 참여도를 기술한다.
바) 관계의 필수 여부를 기술한다.","4","3","나->가->다->라->마->바"
"447","ERD 작성 순서로 올바른 것을 고르시오.","가) 엔터티를 그린다.
나) 엔터티를 적절하게 배치한다.
다) 엔터티 간에 관계를 설정한다.
라) 관계명을 기술한다.
마) 관계의 참여도를 기술한다.
바) 관계의 필수 여부를 기술한다.","4","4","가->나->다->라->마->바"
"457","주어진 SQL문에서 오류가 발생하지 않는 것은?","CREATE TABLE TEST20
(
ID NUMBER PRIMARY KEY,
AGE NUMBER NOT NULL,
NAME VARCHAR2(1)
);

(1) insert into test20 values(10,20,sysdate);
(2)insert into test20 values(20,null,'a');
(3)insert into test20(age, name) values(20,'a');
(4)insert into test20(id,age,name) values(20,10,null);","1","1","4"
"457","주어진 SQL문에서 오류가 발생하지 않는 것은?","CREATE TABLE TEST20
(
ID NUMBER PRIMARY KEY,
AGE NUMBER NOT NULL,
NAME VARCHAR2(1)
);

(1) insert into test20 values(10,20,sysdate);
(2)insert into test20 values(20,null,'a');
(3)insert into test20(age, name) values(20,'a');
(4)insert into test20(id,age,name) values(20,10,null);","1","2","3"
"457","주어진 SQL문에서 오류가 발생하지 않는 것은?","CREATE TABLE TEST20
(
ID NUMBER PRIMARY KEY,
AGE NUMBER NOT NULL,
NAME VARCHAR2(1)
);

(1) insert into test20 values(10,20,sysdate);
(2)insert into test20 values(20,null,'a');
(3)insert into test20(age, name) values(20,'a');
(4)insert into test20(id,age,name) values(20,10,null);","1","3","2"
"457","주어진 SQL문에서 오류가 발생하지 않는 것은?","CREATE TABLE TEST20
(
ID NUMBER PRIMARY KEY,
AGE NUMBER NOT NULL,
NAME VARCHAR2(1)
);

(1) insert into test20 values(10,20,sysdate);
(2)insert into test20 values(20,null,'a');
(3)insert into test20(age, name) values(20,'a');
(4)insert into test20(id,age,name) values(20,10,null);","1","4","1"
"482","성능 데이터 모델링에서 고려해야 할 사항으로 올바르지 않은 것은?","","4","1","데이터베이스 모델링 시에 성능을 고려한 모델링을 수행하면 성능 비용을 감소시킬 수 있다."
"482","성능 데이터 모델링에서 고려해야 할 사항으로 올바르지 않은 것은?","","4","2","성능 향상을 위해서 튜닝을 수행하면 데이터베이스 모델링이 변경될 수 있다."
"482","성능 데이터 모델링에서 고려해야 할 사항으로 올바르지 않은 것은?","","4","3","배치를 통해서 입력되는 데이터 용량이 크면 클수록 성능 튜닝을 위한 비용은 증가된다."
"482","성능 데이터 모델링에서 고려해야 할 사항으로 올바르지 않은 것은?","","4","4","성능 튜닝을 위해서 애플리케이션이 데이터베이스에 접근하는 트랜잭션 유형은 무시해도 된다."
"485","릴레이션을 정규화하는 목적에 관한 설명 중 가장 거리가 먼 것은?","","3","1","정보의 중복을 막는다."
"485","릴레이션을 정규화하는 목적에 관한 설명 중 가장 거리가 먼 것은?","","3","2","정보의 손실을 막는다."
"485","릴레이션을 정규화하는 목적에 관한 설명 중 가장 거리가 먼 것은?","","3","3","정보의 보안을 목적으로 한다."
"485","릴레이션을 정규화하는 목적에 관한 설명 중 가장 거리가 먼 것은?","","3","4","정보의 갱신 이상이 생기지 않도록 한다."
"486","속성에 대한 아래의 설명에서 빈칸에 들어갈 것으로 올바른 것은?","(ㄱ)은 엔터티를 식별할 수 있는 속성이고 (ㄴ)은 다른 엔터티의 관계에 포함되는 속성이다.
다른 엔터티의 관계에 포함되지 않는 속성을 (ㄷ)이라고 한다.","4","1","일반속성 - 기본키 속성 - 외래키 속성"
"486","속성에 대한 아래의 설명에서 빈칸에 들어갈 것으로 올바른 것은?","(ㄱ)은 엔터티를 식별할 수 있는 속성이고 (ㄴ)은 다른 엔터티의 관계에 포함되는 속성이다.
다른 엔터티의 관계에 포함되지 않는 속성을 (ㄷ)이라고 한다.","4","2","파생속성 - 외래키 속성 - 기본키 속성"
"486","속성에 대한 아래의 설명에서 빈칸에 들어갈 것으로 올바른 것은?","(ㄱ)은 엔터티를 식별할 수 있는 속성이고 (ㄴ)은 다른 엔터티의 관계에 포함되는 속성이다.
다른 엔터티의 관계에 포함되지 않는 속성을 (ㄷ)이라고 한다.","4","3","외래키속성 - 기본키 속성 - 파생 속성"
"486","속성에 대한 아래의 설명에서 빈칸에 들어갈 것으로 올바른 것은?","(ㄱ)은 엔터티를 식별할 수 있는 속성이고 (ㄴ)은 다른 엔터티의 관계에 포함되는 속성이다.
다른 엔터티의 관계에 포함되지 않는 속성을 (ㄷ)이라고 한다.","4","4","기본키 속성 - 외래키 속성 - 일반 속성"
"493","다음 중 SQL 명령어가 올바르지 않은 것은?","","1","1","DML : RENAME"
"493","다음 중 SQL 명령어가 올바르지 않은 것은?","","1","2","DCL : REVOKE"
"493","다음 중 SQL 명령어가 올바르지 않은 것은?","","1","3","DDL : ALTER"
"493","다음 중 SQL 명령어가 올바르지 않은 것은?","","1","4","DDL : TRUNCATE"
"499","SELECT NVL(COUNT(*), 9999) FROM TABLE WHERE 1=2의 결괏값은?","","3","1","1"
"499","SELECT NVL(COUNT(*), 9999) FROM TABLE WHERE 1=2의 결괏값은?","","3","2","NULL"
"499","SELECT NVL(COUNT(*), 9999) FROM TABLE WHERE 1=2의 결괏값은?","","3","3","0"
"499","SELECT NVL(COUNT(*), 9999) FROM TABLE WHERE 1=2의 결괏값은?","","3","4","9999"
"503","TEST24 테이블에는 1,2,3의 3개의 행이 있을 때 다음의 SQL 실행 결과로 올바른 것은?","SELECT * FROM test24
minus
SELECT 1 FROM DUAL;","3","1","1"
"503","TEST24 테이블에는 1,2,3의 3개의 행이 있을 때 다음의 SQL 실행 결과로 올바른 것은?","SELECT * FROM test24
minus
SELECT 1 FROM DUAL;","3","2","1,2"
"503","TEST24 테이블에는 1,2,3의 3개의 행이 있을 때 다음의 SQL 실행 결과로 올바른 것은?","SELECT * FROM test24
minus
SELECT 1 FROM DUAL;","3","3","2,3"
"503","TEST24 테이블에는 1,2,3의 3개의 행이 있을 때 다음의 SQL 실행 결과로 올바른 것은?","SELECT * FROM test24
minus
SELECT 1 FROM DUAL;","3","4","1,2,3"
"505","릴레이션 Emp, Dept가 다음과 같이 정의 되어 있다. 부서에 사원이 한명도 없는 부서를 검색하는 질의를 작성할 때, 가장 올바르지 않은 것은? (단, Emp 테이블의 deptno는 Dept의 deptno를 참조하는 외래키이며, Emp의 deptno에는 NULL인 값이 없음)","Emp(empno, ename, job, mgr, hiredate, sal, comm, deptno)
Dept(deptno, dname, loc)","1","1","SELECT deptno FROM Dept WHERE deptno <> ANY (SELECT deptno FROM Emp);"
"505","릴레이션 Emp, Dept가 다음과 같이 정의 되어 있다. 부서에 사원이 한명도 없는 부서를 검색하는 질의를 작성할 때, 가장 올바르지 않은 것은? (단, Emp 테이블의 deptno는 Dept의 deptno를 참조하는 외래키이며, Emp의 deptno에는 NULL인 값이 없음)","Emp(empno, ename, job, mgr, hiredate, sal, comm, deptno)
Dept(deptno, dname, loc)","1","2","SELECT b.deptno FROM Emp a RIGHT OUTER JOIN Dept b ON a.deptno = b.deptno WHERE empno IS NULL;"
"505","릴레이션 Emp, Dept가 다음과 같이 정의 되어 있다. 부서에 사원이 한명도 없는 부서를 검색하는 질의를 작성할 때, 가장 올바르지 않은 것은? (단, Emp 테이블의 deptno는 Dept의 deptno를 참조하는 외래키이며, Emp의 deptno에는 NULL인 값이 없음)","Emp(empno, ename, job, mgr, hiredate, sal, comm, deptno)
Dept(deptno, dname, loc)","1","3","SELECT deptno FROM Dept a WHERE NOT EXISTS (SELECT * FROM Emp b WHERE a.deptno = b.deptno);"
"505","릴레이션 Emp, Dept가 다음과 같이 정의 되어 있다. 부서에 사원이 한명도 없는 부서를 검색하는 질의를 작성할 때, 가장 올바르지 않은 것은? (단, Emp 테이블의 deptno는 Dept의 deptno를 참조하는 외래키이며, Emp의 deptno에는 NULL인 값이 없음)","Emp(empno, ename, job, mgr, hiredate, sal, comm, deptno)
Dept(deptno, dname, loc)","1","4","SELECT deptno FROM Dept WHERE Deptno NOT IN (SELECT deptno FROM Emp);"
"506","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","4","1","계층형 질의는 하나의 테이블에서 자기 자신을 조인하는 형태를 사용한다."
"506","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","4","2","재무제표 및 조직도와 같은 구조에서 사용할 수 있다."
"506","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","4","3","순방향과 역방향 모두 수행할 수 있다."
"506","다음 중 계층형 쿼리에 대한 설명으로 올바르지 않은 것은?","","4","4","루트 노드의 LEVEL 값은 가장 큰 값을 가진다."
"565","다음 중 뷰의 특징 중 틀린 것을 고르시오.","","1","1","뷰는 물리적으로 구현되어 있다."
"565","다음 중 뷰의 특징 중 틀린 것을 고르시오.","","1","2","데이터의 논리적 독립성을 제공할 수 있다."
"565","다음 중 뷰의 특징 중 틀린 것을 고르시오.","","1","3","일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다."
"565","다음 중 뷰의 특징 중 틀린 것을 고르시오.","","1","4","뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다."
"567","개념 스키마에 대한 설명으로 틀린 것을 고르시오.","","2","1","설계자 관점의 스키마다."
"567","개념 스키마에 대한 설명으로 틀린 것을 고르시오.","","2","2","데이터베이스의 물리적 저장 구조를 표현한다."
"567","개념 스키마에 대한 설명으로 틀린 것을 고르시오.","","2","3","전체 데이터베이스 내의 규칙과 구조를 표현한다."
"567","개념 스키마에 대한 설명으로 틀린 것을 고르시오.","","2","4","사용자 전체 집단의 데이터베이스 구조이다."
"570","3층 스키마의 물리적 저장 구조를 의미하는 것은?","","3","1","외부스키마"
"570","3층 스키마의 물리적 저장 구조를 의미하는 것은?","","3","2","구조스키마"
"570","3층 스키마의 물리적 저장 구조를 의미하는 것은?","","3","3","내부스키마"
"570","3층 스키마의 물리적 저장 구조를 의미하는 것은?","","3","4","개념스키마"
"573","속성의 분류 중 속성의 특성에 따른 분류가 아닌 것은? ","","2","1","설계속성"
"573","속성의 분류 중 속성의 특성에 따른 분류가 아닌 것은? ","","2","2","일반속성"
"573","속성의 분류 중 속성의 특성에 따른 분류가 아닌 것은? ","","2","3","파생속성"
"573","속성의 분류 중 속성의 특성에 따른 분류가 아닌 것은? ","","2","4","기본속성"
"583","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가정 적절한 것은?","","3","1","SELECT DEPTNO, ROUND(AVG(SAL)) AS ROUND_VALUE"
"583","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가정 적절한 것은?","","3","2","FROM EMP E"
"583","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가정 적절한 것은?","","3","3","WHERE ROUND_VALUE >= 3000"
"583","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가정 적절한 것은?","","3","4","GROUP BY DEPTNO;"
"584","다음의 함수 실행 결과 중 틀린 것은?","","3","1","LTRIM('AABABAA', 'A') : 'BABAA'"
"584","다음의 함수 실행 결과 중 틀린 것은?","","3","2","INSTR('WWW.ABCDEFGH.CO.KR','.', 5, 2) : 16 "
"584","다음의 함수 실행 결과 중 틀린 것은?","","3","3","LPAD('X',5,'X') : 'XXXXXX' 
"
"584","다음의 함수 실행 결과 중 틀린 것은?","","3","4","SUBSTR('WWW.ABCDEFGH.CO.KR', -5) : 'CO.KR' "
"596","다음 중 실행이 불가한 구문은?","","1","1","SELECT COL1, COL2, COL3 C1 FROM TAB1 T ORDER BY COL1, COL1, T.C1;"
"596","다음 중 실행이 불가한 구문은?","","1","2","SELECT COL1, COL2, COL3 C1 FROM TAB1 T ORDER BY 1, COL2, C1;"
"596","다음 중 실행이 불가한 구문은?","","1","3","SELECT COL1, COL2, COL3 C1 FROM TAB1 T ORDER BY 1, 2, 3;"
"596","다음 중 실행이 불가한 구문은?","","1","4","SELECT COL1, COL2, COL3 C1 FROM TAB1 T ORDER BY 1, COL2, COL3;"
"607","아래 쿼리중 결과값이 다른 하나는? ","","2","1","SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B 
   WHERE A.DEPTNO = B.DEPTNO 
   GROUP BY DNAME, JOB 
   UNION ALL 
  SELECT DNAME, '' AS JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B 
   WHERE A.DEPTNO = B.DEPTNO 
   GROUP BY DNAME 
   UNION ALL 
  SELECT '' AS DNAME, '' AS JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B 
   WHERE A.DEPTNO = B.DEPTNO 
   ORDER BY 1, 2;"
"607","아래 쿼리중 결과값이 다른 하나는? ","","2","2"," SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B 
   WHERE A.DEPTNO = B.DEPTNO 
   GROUP BY CUBE(DNAME, JOB) 
   ORDER BY 1, 2;"
"607","아래 쿼리중 결과값이 다른 하나는? ","","2","3","SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B  
   WHERE A.DEPTNO = B.DEPTNO 
   GROUP BY GROUPING SETS((DNAME,JOB), DNAME, NULL) 
   ORDER BY 1, 2;"
"607","아래 쿼리중 결과값이 다른 하나는? ","","2","4","SELECT DNAME, JOB, COUNT(*) AS CNT, SUM(SAL) AS TOTAL_SAL 
    FROM SCOTT.EMP A, SCOTT.DEPT B    
   WHERE A.DEPTNO = B.DEPTNO  
   GROUP BY ROLLUP(DNAME,JOB) 
   ORDER BY DNAME, JOB;"
"621","데이터 모델링을 할 때 유의해야 할 사항으로 가장 적절하지 않은 것은?","","1","1","사용자가 처리하는 프로세스에 따라 매핑이 될 수 있도록 프로그램과 테이블 간의 연계성을 높인다."
"621","데이터 모델링을 할 때 유의해야 할 사항으로 가장 적절하지 않은 것은?","","1","2","데이터의 정의를 프로세스와 분리하여 유연성을 높인다."
"621","데이터 모델링을 할 때 유의해야 할 사항으로 가장 적절하지 않은 것은?","","1","3","데이터 간의 상호 연관관계를 명확하게 정의하여 일관성 있게 데이터가 유지되도록 한다. "
"621","데이터 모델링을 할 때 유의해야 할 사항으로 가장 적절하지 않은 것은?","","1","4","같은 정보를 저장하지 않도록 하여 중복성을 최소화한다."
"632","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","1","1","SELECT문의 6개 절 중에서 SELECT절이 가장 마지막에 실행된다."
"632","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","1","2","HAVING절에서는 그룹함수가 없는 일반 조건을 사용할 수 있다."
"632","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","1","3","WHERE절에는 그룹함수를 사용한 조건 전달이 불가하다."
"632","SELECT 문에 대한 설명으로 가장 적절하지 않은 것은? ","","1","4","GROUP BY절에는 컬럼별칭을 사용할 수 없다."
"633","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가장 적절한 것은?","","4","1","SELECT T.COL1, COL2, SUM(COL3) AS ""SUM VALUE"""
"633","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가장 적절한 것은?","","4","2","FROM TAB1 T"
"633","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가장 적절한 것은?","","4","3","GROUP BY COL1, COL2"
"633","SQL 문을 실행했을 때 오류가 발생하는 부분으로 가장 적절한 것은?","","4","4","ORDER BY COL3;"
"671","다음 중 아래에서 설명하는 데이터모델의 개념으로 가장 적절한 것은? ","학생이라는 엔터티에서 학년이라는 속성 값의 범위는 1~4 사이의 정수이며, 주민번호 속성은 13자리 이내 문자열로 정의할 수 있다. ","4","1","속성사전"
"671","다음 중 아래에서 설명하는 데이터모델의 개념으로 가장 적절한 것은? ","학생이라는 엔터티에서 학년이라는 속성 값의 범위는 1~4 사이의 정수이며, 주민번호 속성은 13자리 이내 문자열로 정의할 수 있다. ","4","2","시스템카탈로그"
"671","다음 중 아래에서 설명하는 데이터모델의 개념으로 가장 적절한 것은? ","학생이라는 엔터티에서 학년이라는 속성 값의 범위는 1~4 사이의 정수이며, 주민번호 속성은 13자리 이내 문자열로 정의할 수 있다. ","4","3","릴레이션"
"671","다음 중 아래에서 설명하는 데이터모델의 개념으로 가장 적절한 것은? ","학생이라는 엔터티에서 학년이라는 속성 값의 범위는 1~4 사이의 정수이며, 주민번호 속성은 13자리 이내 문자열로 정의할 수 있다. ","4","4","도메인"
"674","엔터티간 1:1, 1:M 과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가? ","","3","1","관계정의"
"674","엔터티간 1:1, 1:M 과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가? ","","3","2","관계선택성"
"674","엔터티간 1:1, 1:M 과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가? ","","3","3","관계차수"
"674","엔터티간 1:1, 1:M 과 같이 관계의 기수성을 나타내는 것을 무엇이라 하는가? ","","3","4","관계명"
"682","테이블 생성 시 주의 할 사항으로 적절하지 않은 것은? ","","3","1","소유자가 다를 경우 같은 이름의 테이블을 생성할 수 있다."
"682","테이블 생성 시 주의 할 사항으로 적절하지 않은 것은? ","","3","2","테이블 생성시 대소문자 구분은 하지 않는다."
"682","테이블 생성 시 주의 할 사항으로 적절하지 않은 것은? ","","3","3","테이블명과 컬럼명은 숫자로 시작해도 무관하다."
"682","테이블 생성 시 주의 할 사항으로 적절하지 않은 것은? ","","3","4","컬럼 뒤에 데이터 유형은 꼭 지정되어야 한다."
"715","컬럼 변경 시 주의 사항으로 옳지 않은 것은? ","","4","1","컬럼의 DEFAULT 값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미친다."
"715","컬럼 변경 시 주의 사항으로 옳지 않은 것은? ","","4","2","컬럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다."
"715","컬럼 변경 시 주의 사항으로 옳지 않은 것은? ","","4","3","컬럼이 NULL 값만 가지고 있으면 데이터 유형을 변경할 수 있다."
"715","컬럼 변경 시 주의 사항으로 옳지 않은 것은? ","","4","4","컬럼의 크기를 늘릴 수는 있지만 줄일 수는 없다."
"719","다음 설명 중 가장 적절하지 않은 것은?","","1","1","NULL값이 삽입되어 있는 경우 UNIQUE 제약조건을 추가할 수 없다."
"719","다음 설명 중 가장 적절하지 않은 것은?","","1","2","이미 존재하는 컬럼에 대해 NOT NULL 제약조건 추가 시 반드시 MODIFY로 처리한다."
"719","다음 설명 중 가장 적절하지 않은 것은?","","1","3","제약 조건 추가 시 제약조건 이름을 명시하지 않을 수 있다."
"719","다음 설명 중 가장 적절하지 않은 것은?","","1","4","외래키를 생성 한 경우 부모 테이블의 참조키 컬럼을 삭제할 수 없다."
"720","권한에 대한 설명으로 가장 적절한 것은?","","2","1","WITH ADMIN OPTION을 통해 부여받은 테이블 조회 권한을 다른 유저에게 부여할 수 있다."
"720","권한에 대한 설명으로 가장 적절한 것은?","","2","2","롤에 있는 권한을 회수한 이후 롤을 부여받은 유저는 해당 권한을 갖지 않게 된다."
"720","권한에 대한 설명으로 가장 적절한 것은?","","2","3","테이블에 대한 조회 권한 부여 시 즉시 반영되지 않고 재접속을 해야 조회가 가능하다."
"720","권한에 대한 설명으로 가장 적절한 것은?","","2","4","권한은 테이블 소유자만이 부여할 수 있다."
"728","트랜잭션의 특징 중 옳지 않은 것은?","","1","1","중복성"
"728","트랜잭션의 특징 중 옳지 않은 것은?","","1","2","지속성"
"728","트랜잭션의 특징 중 옳지 않은 것은?","","1","3","원자성"
"728","트랜잭션의 특징 중 옳지 않은 것은?","","1","4","일관성"
"730","다음의 주식별자가 나타내는 특징을 가장 잘 설명한 것은?","주식별자를 구성하는 속성 중에서 유일성을 만족하는 최소한의 속성으로 구성한다.","3","1","존재성"
"730","다음의 주식별자가 나타내는 특징을 가장 잘 설명한 것은?","주식별자를 구성하는 속성 중에서 유일성을 만족하는 최소한의 속성으로 구성한다.","3","2","단일성"
"730","다음의 주식별자가 나타내는 특징을 가장 잘 설명한 것은?","주식별자를 구성하는 속성 중에서 유일성을 만족하는 최소한의 속성으로 구성한다.","3","3","최소성"
"730","다음의 주식별자가 나타내는 특징을 가장 잘 설명한 것은?","주식별자를 구성하는 속성 중에서 유일성을 만족하는 최소한의 속성으로 구성한다.","3","4","유일성"
"732","관계형 데이터베이스에 대한 특징 중 가장 적절하지 않은 것은?","","1","1","데이터베이스의 부하를 분석하기 쉽다."
"732","관계형 데이터베이스에 대한 특징 중 가장 적절하지 않은 것은?","","1","2","기존의 작성된 스키마를 수정하기 어렵다."
"732","관계형 데이터베이스에 대한 특징 중 가장 적절하지 않은 것은?","","1","3","데이터를 분류, 정렬, 탐색하는 속도가 빠르다."
"732","관계형 데이터베이스에 대한 특징 중 가장 적절하지 않은 것은?","","1","4","데이터의 무결성을 보장할 수 있다."
"734","다음 중 오류가 발생하는 문장으로 가장 적절한 것은?","","1","1","SELECT T.COL2, SUM(T.COL1), SUM(T.COL3) FROM TAB1 T GROUP BY T.COL2 ORDER BY T.COL3;"
"734","다음 중 오류가 발생하는 문장으로 가장 적절한 것은?","","1","2","SELECT T.COL2, SUM(T.COL1) AS SUM_VALUE FROM TAB1 T GROUP BY T.COL2 ORDER BY SUM_VALUE, T.COL2;"
"734","다음 중 오류가 발생하는 문장으로 가장 적절한 것은?","","1","3","SELECT T.COL2, SUM(T.COL1) FROM TAB1 T WHERE COL1 >= 100 GROUP BY COL2;"
"734","다음 중 오류가 발생하는 문장으로 가장 적절한 것은?","","1","4","SELECT COL1, T.COL2, T.COL3 FROM TAB1 T WHERE COL1 >= 100;"
"749","아래 SQL 중 결과가 다른 하나는?","","1","1","SELECT CODE, NAME, (SELECT PRICE FROM PRODUCT WHERE P1.CODE = P2.CODE) FROM PRODUCT P1;"
"749","아래 SQL 중 결과가 다른 하나는?","","1","2","SELECT CODE, NAME, PRICE FROM PRODUCT P1 WHERE PRICE = (SELECT MAX(PRICE) FROM PRODUCT P2 WHERE P1.CODE = P2.CODE);"
"749","아래 SQL 중 결과가 다른 하나는?","","1","3","SELECT CODE, NAME, PRICE FROM PRODUCT WHERE (CODE, PRICE) IN (SELECT CODE, MAX(PRICE) FROM PRODUCT GROUP BY CODE);"
"749","아래 SQL 중 결과가 다른 하나는?","","1","4","SELECT P.CODE, P.NAME, P.PRICE FROM PRODUCT P, (SELECT CODE, MAX(PRICE) AS MAX_PRICE FROM PRODUCT GROUP BY CODE) I WHERE P.CODE = I.CODE AND P.PRICE = I.MAX_PRICE;"
"762","PIVOT과 UNPIVOT에 대한 설명으로 가장 적절한 것은?","","1","1","PIVOT 시 FOR 앞에는 반드시 집계함수(SUM, AVG 등)의 형태여야 한다."
"762","PIVOT과 UNPIVOT에 대한 설명으로 가장 적절한 것은?","","1","2","UNPIVOT시 쌓을 컬럼을 지정할 수 없다."
"762","PIVOT과 UNPIVOT에 대한 설명으로 가장 적절한 것은?","","1","3","UNPIVOT은 LONG 데이터를 WIDE 데이터로 변환하는 기법이다."
"762","PIVOT과 UNPIVOT에 대한 설명으로 가장 적절한 것은?","","1","4","PIVOT은 교차표 형태의 데이터를 TIDY 데이터로 변경하는 문법이다."
