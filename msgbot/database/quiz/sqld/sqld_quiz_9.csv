"585","함수의 실행 결과로 적절하지 않은 것은?","","2","1","SIGN(120) : 1"
"585","함수의 실행 결과로 적절하지 않은 것은?","","2","2","ROUND(12345.678, -2) : 12350"
"585","함수의 실행 결과로 적절하지 않은 것은?","","2","3","FLOOR(3.5) : 3"
"585","함수의 실행 결과로 적절하지 않은 것은?","","2","4","CEIL(3.5) : 4"
"589","아래 SQL의 실행 결과로 가장 적절한 것은?(단, DBMS는 ORACLE로 가정)","SELECT TO_CHAR(TO_DATE('2024/08/24 10:00', 'YYYY/MM/DD HH24:MI') - 30/24/60, 'YYYY.MM.DD HH24:MI:SS') FROM DUAL;","2","1","2024.08.24 09:59:30"
"589","아래 SQL의 실행 결과로 가장 적절한 것은?(단, DBMS는 ORACLE로 가정)","SELECT TO_CHAR(TO_DATE('2024/08/24 10:00', 'YYYY/MM/DD HH24:MI') - 30/24/60, 'YYYY.MM.DD HH24:MI:SS') FROM DUAL;","2","2","2024.08.24 09:30:00"
"589","아래 SQL의 실행 결과로 가장 적절한 것은?(단, DBMS는 ORACLE로 가정)","SELECT TO_CHAR(TO_DATE('2024/08/24 10:00', 'YYYY/MM/DD HH24:MI') - 30/24/60, 'YYYY.MM.DD HH24:MI:SS') FROM DUAL;","2","3","2024.08.24 06:00:00"
"589","아래 SQL의 실행 결과로 가장 적절한 것은?(단, DBMS는 ORACLE로 가정)","SELECT TO_CHAR(TO_DATE('2024/08/24 10:00', 'YYYY/MM/DD HH24:MI') - 30/24/60, 'YYYY.MM.DD HH24:MI:SS') FROM DUAL;","2","4","2024.07.25 10:00:00"
"603","다음 SQL 중 정상 수행이 불가한 것은? ","","3","1","UPDATE TAB1 A 
     SET A.NAME = (SELECT B.NAME 
                     FROM TAB2 B 
                    WHERE A.NO = B.NO);"
"603","다음 SQL 중 정상 수행이 불가한 것은? ","","3","2","SELECT NO  
    FROM TAB1 A JOIN TAB2 B 
   USING (NO);"
"603","다음 SQL 중 정상 수행이 불가한 것은? ","","3","3","SELECT A.NO, (SELECT B.NAME 
                   FROM TAB2 B) 
    FROM TAB1 A 
   WHERE A.NO = B.NO;"
"603","다음 SQL 중 정상 수행이 불가한 것은? ","","3","4","SELECT * 
    FROM TAB1 A 
   WHERE NOT EXISTS (SELECT 'X' 
                         FROM TAB2 B 
                        WHERE A.NO = B.NO); "
"624","데이터 모델링의 관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","1","관계의 표기법은 관계명, 관계차수, 선택성 3가지 개념을 사용한다."
"624","데이터 모델링의 관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","2","관계의 페어링은 하나의 엔터티와 다른 엔터티 간의 레코드 연결 방식을 나타낸다."
"624","데이터 모델링의 관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","3","부서와 사원 엔터티 간의 ‘소속’ 관계는 존재적 관계의 사례이다."
"624","데이터 모델링의 관계에 대한 설명으로 가장 적절하지 않은 것은?","","2","4","관계는 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있으나 ERD에서는 존재와 행위를 구분하지 않는다."
"627","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?  ","","3","1","관계는 엔터티간의 논리적 연관성을 의미한다."
"627","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?  ","","3","2","엔터티 간의 관계를 통해 데이터의 중복을 피하고, 각 데이터 요소를 한 번만 저장하여 유지관리의 복잡성을 줄일 수 있다."
"627","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?  ","","3","3","부모의 식별자를 자식의 일반속성으로 상속하면 식별 관계, 부모의 식별자를 자식의 식별자에 포함하면 비식별 관계라고 할 수 있다."
"627","관계(Relationship)와 조인(Join)에 대한 설명으로 가장 적절하지 않은 것은?  ","","3","4","조인(Join)이란 식별자를 상속하고, 상속된 속성을 매핑키로 활용하여 데이터를 결합하는 것을 의미한다."
"628","트랜잭션에 대한 설명 중 가장 적절하지 않은 것은?","","4","1","하나의 트랜잭션으로 구성된 작업은 부분 COMMIT이 불가하다."
"628","트랜잭션에 대한 설명 중 가장 적절하지 않은 것은?","","4","2","순차적으로 수행되는 작업 A와 B가 하나의 트랜잭션일 경우 A만 실행되고 시스템 장애가 발생했다면 A를 undo해야 한다."
"628","트랜잭션에 대한 설명 중 가장 적절하지 않은 것은?","","4","3","원자성이란 하나의 트랜잭션의 작업이 모두 성공하거나 모두 취소되어야 하는 특징을 말한다."
"628","트랜잭션에 대한 설명 중 가장 적절하지 않은 것은?","","4","4","트랜잭션에 의한 관계는 선택적인 관계 형태를 가진다."
"634","아래의 SQL 에 대해서 결과값이 다른 것은? ","","1","1","SELECT 'RDBMS' & ' SQL' FROM DUAL;"
"634","아래의 SQL 에 대해서 결과값이 다른 것은? ","","1","2","SELECT 'RDBMS' + ' SQL';"
"634","아래의 SQL 에 대해서 결과값이 다른 것은? ","","1","3","SELECT 'RDMBS' || ' SQL' FROM DUAL;"
"634","아래의 SQL 에 대해서 결과값이 다른 것은? ","","1","4","SELECT CONCAT ('RDBMS', ' SQL') FROM DUAL;"
"635","아래 SQL에서 밑줄 친 자리에 쓰인 함수의 결과가 다른 하나는? ","SELECT _________(5.47) FROM DUAL; ","3","1","ROUND"
"635","아래 SQL에서 밑줄 친 자리에 쓰인 함수의 결과가 다른 하나는? ","SELECT _________(5.47) FROM DUAL; ","3","2","FLOOR"
"635","아래 SQL에서 밑줄 친 자리에 쓰인 함수의 결과가 다른 하나는? ","SELECT _________(5.47) FROM DUAL; ","3","3","CEIL"
"635","아래 SQL에서 밑줄 친 자리에 쓰인 함수의 결과가 다른 하나는? ","SELECT _________(5.47) FROM DUAL; ","3","4","TRUNC"
"666","아래 SQL 실행 결과로 가장 적절한 것은? ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
 
INSERT INTO TAB1 VALUES(1,10); 
INSERT INTO TAB1 VALUES(2,20); 
INSERT INTO TAB1 VALUES(3,30); 
COMMIT; 
 
ALTER TABLE TAB1 ADD (COL3 NUMBER); 
 
INSERT INTO TAB1 VALUES(4,40,100); 
UPDATE TAB1 SET COL2 = 50 WHERE COL1 = 1; 
DELETE TAB1 WHERE COL1 = 3; 
 
ALTER TABLE TAB1 DROP COLUMN COL1; 
 
ROLLBACK; 
 
SELECT SUM(COL2 + COL3) FROM TAB1; ","1","1","140"
"666","아래 SQL 실행 결과로 가장 적절한 것은? ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
 
INSERT INTO TAB1 VALUES(1,10); 
INSERT INTO TAB1 VALUES(2,20); 
INSERT INTO TAB1 VALUES(3,30); 
COMMIT; 
 
ALTER TABLE TAB1 ADD (COL3 NUMBER); 
 
INSERT INTO TAB1 VALUES(4,40,100); 
UPDATE TAB1 SET COL2 = 50 WHERE COL1 = 1; 
DELETE TAB1 WHERE COL1 = 3; 
 
ALTER TABLE TAB1 DROP COLUMN COL1; 
 
ROLLBACK; 
 
SELECT SUM(COL2 + COL3) FROM TAB1; ","1","2","130"
"666","아래 SQL 실행 결과로 가장 적절한 것은? ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
 
INSERT INTO TAB1 VALUES(1,10); 
INSERT INTO TAB1 VALUES(2,20); 
INSERT INTO TAB1 VALUES(3,30); 
COMMIT; 
 
ALTER TABLE TAB1 ADD (COL3 NUMBER); 
 
INSERT INTO TAB1 VALUES(4,40,100); 
UPDATE TAB1 SET COL2 = 50 WHERE COL1 = 1; 
DELETE TAB1 WHERE COL1 = 3; 
 
ALTER TABLE TAB1 DROP COLUMN COL1; 
 
ROLLBACK; 
 
SELECT SUM(COL2 + COL3) FROM TAB1; ","1","3","120"
"666","아래 SQL 실행 결과로 가장 적절한 것은? ","CREATE TABLE TAB1(COL1 NUMBER, COL2 NUMBER); 
 
INSERT INTO TAB1 VALUES(1,10); 
INSERT INTO TAB1 VALUES(2,20); 
INSERT INTO TAB1 VALUES(3,30); 
COMMIT; 
 
ALTER TABLE TAB1 ADD (COL3 NUMBER); 
 
INSERT INTO TAB1 VALUES(4,40,100); 
UPDATE TAB1 SET COL2 = 50 WHERE COL1 = 1; 
DELETE TAB1 WHERE COL1 = 3; 
 
ALTER TABLE TAB1 DROP COLUMN COL1; 
 
ROLLBACK; 
 
SELECT SUM(COL2 + COL3) FROM TAB1; ","1","4","110"
"668","다음 설명 중 가장 적절하지 않은 것은? (단, DBMS는 오라클) ","","4","1","컬럼은 동시에 여러 개를 삭제할 수 없다."
"668","다음 설명 중 가장 적절하지 않은 것은? (단, DBMS는 오라클) ","","4","2","컬럼 추가 시 DEFAULT값을 선언하면 기존 데이터의 새로운 컬럼 값은 DEFAULT값이 된다."
"668","다음 설명 중 가장 적절하지 않은 것은? (단, DBMS는 오라클) ","","4","3","컬럼 사이즈는 언제든지 늘릴 수 있다."
"668","다음 설명 중 가장 적절하지 않은 것은? (단, DBMS는 오라클) ","","4","4","데이터 타입을 변경할 경우에는 반드시 빈 컬럼이어야 한다."
"670","다음 중 유저가 갖는 권한에 대한 설명으로 가장 적절한 것은?","SYSTEM) GRANT SELECT, INSERT ON SCOTT.EMP TO HR WITH GRANT OPTION; 
SYSTEM) GRANT CREATE VIEW TO HR WITH ADMIN OPTION; 
HR) GRANT SELECT, INSERT ON SCOTT.EMP TO HONG; 
HR) GRANT CREATE VIEW TO HONG; 
SYSTEM) REVOKE INSERT ON SCOTT.EMP FROM HR; 
SYSTEM) REVOKE CREATE VIEW FROM HR;","1","1","HR 유저에게 부여된 EMP 테이블 입력 권한 회수 시 HONG에게 부여된 권한도 함께 회수되었다."
"670","다음 중 유저가 갖는 권한에 대한 설명으로 가장 적절한 것은?","SYSTEM) GRANT SELECT, INSERT ON SCOTT.EMP TO HR WITH GRANT OPTION; 
SYSTEM) GRANT CREATE VIEW TO HR WITH ADMIN OPTION; 
HR) GRANT SELECT, INSERT ON SCOTT.EMP TO HONG; 
HR) GRANT CREATE VIEW TO HONG; 
SYSTEM) REVOKE INSERT ON SCOTT.EMP FROM HR; 
SYSTEM) REVOKE CREATE VIEW FROM HR;","1","2","HR이 HONG에게 부여한 EMP 테이블의 조회 권한은 SYSTEM 계정에서 직접 회수가 가능하다."
"670","다음 중 유저가 갖는 권한에 대한 설명으로 가장 적절한 것은?","SYSTEM) GRANT SELECT, INSERT ON SCOTT.EMP TO HR WITH GRANT OPTION; 
SYSTEM) GRANT CREATE VIEW TO HR WITH ADMIN OPTION; 
HR) GRANT SELECT, INSERT ON SCOTT.EMP TO HONG; 
HR) GRANT CREATE VIEW TO HONG; 
SYSTEM) REVOKE INSERT ON SCOTT.EMP FROM HR; 
SYSTEM) REVOKE CREATE VIEW FROM HR;","1","3","HR 유저에게 부여된 CREATE TABLE 권한 회수 시 HONG에게 부여된 CREATE TABLE 권한도 함께 회수되었다."
"670","다음 중 유저가 갖는 권한에 대한 설명으로 가장 적절한 것은?","SYSTEM) GRANT SELECT, INSERT ON SCOTT.EMP TO HR WITH GRANT OPTION; 
SYSTEM) GRANT CREATE VIEW TO HR WITH ADMIN OPTION; 
HR) GRANT SELECT, INSERT ON SCOTT.EMP TO HONG; 
HR) GRANT CREATE VIEW TO HONG; 
SYSTEM) REVOKE INSERT ON SCOTT.EMP FROM HR; 
SYSTEM) REVOKE CREATE VIEW FROM HR;","1","4","HR 계정에게 부여된 SCOTT.EMP에 대한 SELECT 권한도 함께 회수된다."
"679","NULL에 대한 설명으로 틀린 것은? ","","1","1","공백과 같은 ASCII 값을 가진다."
"679","NULL에 대한 설명으로 틀린 것은? ","","1","2","NULL과의 수치연산은 NULL 값을 리턴한다."
"679","NULL에 대한 설명으로 틀린 것은? ","","1","3","NULL과의 비교연산은 FALSE(거짓)를 리턴한다."
"679","NULL에 대한 설명으로 틀린 것은? ","","1","4","값이 존재하지 않거나 확정되지 않은 값을 의미한다."
"683","다음 설명 중 틀린 하나는? ","","2","1","SELECT 문은 ORDER BY 절이 가장 나중에 실행된다."
"683","다음 설명 중 틀린 하나는? ","","2","2","GROUP BY 절을 사용하는 경우 ORDER BY 절에는 GROUP BY절에 정의되지 않은 컬럼을 사용할 수 있다."
"683","다음 설명 중 틀린 하나는? ","","2","3","테이블 별칭을 선언하면 컬럼 앞의 구분자는 반드시 테이블명 대신 테이블 별칭을 사용한다."
"683","다음 설명 중 틀린 하나는? ","","2","4","ORDER BY 절에 SELECT 절에 정의되지 않은 컬럼을 사용할 수 있다."
"725","다음 중 아래 개념이 설명하는 관계로 가장 적절한 것은?","부모 엔터티의 주식별자를 상속받아 자식 엔터티에서 외부식별자이면서 주식별자로 사용하는 관계","4","1","선택관계"
"725","다음 중 아래 개념이 설명하는 관계로 가장 적절한 것은?","부모 엔터티의 주식별자를 상속받아 자식 엔터티에서 외부식별자이면서 주식별자로 사용하는 관계","4","2","필수관계"
"725","다음 중 아래 개념이 설명하는 관계로 가장 적절한 것은?","부모 엔터티의 주식별자를 상속받아 자식 엔터티에서 외부식별자이면서 주식별자로 사용하는 관계","4","3","비식별관계"
"725","다음 중 아래 개념이 설명하는 관계로 가장 적절한 것은?","부모 엔터티의 주식별자를 상속받아 자식 엔터티에서 외부식별자이면서 주식별자로 사용하는 관계","4","4","식별관계"
"746","다음 중 실행 오류가 발생하는 조인 문법은?","","1","1","SELECT * FROM TAB1 NATURAL JOIN TAB2 USING (COL1);"
"746","다음 중 실행 오류가 발생하는 조인 문법은?","","1","2","SELECT * FROM TAB1 INNER JOIN TAB2 USING (COL1);"
"746","다음 중 실행 오류가 발생하는 조인 문법은?","","1","3","SELECT * FROM TAB1 JOIN TAB2 ON (TAB1.COL1 = TAB2.COL1);"
"746","다음 중 실행 오류가 발생하는 조인 문법은?","","1","4","SELECT * FROM TAB1 LEFT JOIN TAB2 ON TAB1.COL1 = TAB2.COL1;"
"771","다음이 설명하는 모델링 개념으로 가장 적절한 것은?","사용자 관점의 데이터베이스 스키마를 통합하여 데이터베이스의 전체 논리적 구조를 정의하는 단계로  전체 데이터베이스의 개체, 속성, 관계, 데이터 타입 등을 정의한다.","3","1","내부 스키마"
"771","다음이 설명하는 모델링 개념으로 가장 적절한 것은?","사용자 관점의 데이터베이스 스키마를 통합하여 데이터베이스의 전체 논리적 구조를 정의하는 단계로  전체 데이터베이스의 개체, 속성, 관계, 데이터 타입 등을 정의한다.","3","2","논리 스키마"
"771","다음이 설명하는 모델링 개념으로 가장 적절한 것은?","사용자 관점의 데이터베이스 스키마를 통합하여 데이터베이스의 전체 논리적 구조를 정의하는 단계로  전체 데이터베이스의 개체, 속성, 관계, 데이터 타입 등을 정의한다.","3","3","개념 스키마"
"771","다음이 설명하는 모델링 개념으로 가장 적절한 것은?","사용자 관점의 데이터베이스 스키마를 통합하여 데이터베이스의 전체 논리적 구조를 정의하는 단계로  전체 데이터베이스의 개체, 속성, 관계, 데이터 타입 등을 정의한다.","3","4","외부 스키마"
"774","두 개의 엔터티 사이의 관계 도출 시 고려사항이 아닌 것은?","","1","1","업무기술서, 장표에 관계연결을 가능하게 하는 명사가 있는가?"
"774","두 개의 엔터티 사이의 관계 도출 시 고려사항이 아닌 것은?","","1","2","업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?"
"774","두 개의 엔터티 사이의 관계 도출 시 고려사항이 아닌 것은?","","1","3","두 개의 엔터티 사이에 관련 있는 연관규칙이 존재하는가?"
"774","두 개의 엔터티 사이의 관계 도출 시 고려사항이 아닌 것은?","","1","4","두 개의 엔터티 사이에 정보의 조합이 발생되는가?"
"782","다음이 설명하는 용어로 가장 적절한 것은?","데이터베이스의 속성(ATTRIBUTE, 또는 필드)이 가질 수 있는 값들의 범위 또는 집합을 의미한다.","3","1","키"
"782","다음이 설명하는 용어로 가장 적절한 것은?","데이터베이스의 속성(ATTRIBUTE, 또는 필드)이 가질 수 있는 값들의 범위 또는 집합을 의미한다.","3","2","튜플"
"782","다음이 설명하는 용어로 가장 적절한 것은?","데이터베이스의 속성(ATTRIBUTE, 또는 필드)이 가질 수 있는 값들의 범위 또는 집합을 의미한다.","3","3","도메인"
"782","다음이 설명하는 용어로 가장 적절한 것은?","데이터베이스의 속성(ATTRIBUTE, 또는 필드)이 가질 수 있는 값들의 범위 또는 집합을 의미한다.","3","4","릴레이션"
"236","다음과 같은 문장으로 사원 테이블을 생성하였을 때, 사원 테이블에 유효한 데이터를 로드한 후, 아래 두 SQL문을 성공적으로 실행하였다. SQL A와 SQL B의 실행 결과로 옳은 것은?","create table 사원(번호 char(10) primary key, 월급 integer);

SQL A : select count(번호) from 사원 where 월급 > = 100000 or 월급 < 100000;
SQL B : select count(번호) from 사원;","2","1","SQL A와 SQL B의 결과는 다를 수 있으며, 그 이유는 번호 필드에 널(NULL)값이 존재할 수 있기 때문이다."
"236","다음과 같은 문장으로 사원 테이블을 생성하였을 때, 사원 테이블에 유효한 데이터를 로드한 후, 아래 두 SQL문을 성공적으로 실행하였다. SQL A와 SQL B의 실행 결과로 옳은 것은?","create table 사원(번호 char(10) primary key, 월급 integer);

SQL A : select count(번호) from 사원 where 월급 > = 100000 or 월급 < 100000;
SQL B : select count(번호) from 사원;","2","2","SQL A와 SQL B의 결과는 다를 수 있으며, 그 이유는 월급 필드에 널(NULL)값이 존재할 수 있기 때문이다."
"236","다음과 같은 문장으로 사원 테이블을 생성하였을 때, 사원 테이블에 유효한 데이터를 로드한 후, 아래 두 SQL문을 성공적으로 실행하였다. SQL A와 SQL B의 실행 결과로 옳은 것은?","create table 사원(번호 char(10) primary key, 월급 integer);

SQL A : select count(번호) from 사원 where 월급 > = 100000 or 월급 < 100000;
SQL B : select count(번호) from 사원;","2","3","SQL A와 SQL B의 결과는 항상 다르다."
"236","다음과 같은 문장으로 사원 테이블을 생성하였을 때, 사원 테이블에 유효한 데이터를 로드한 후, 아래 두 SQL문을 성공적으로 실행하였다. SQL A와 SQL B의 실행 결과로 옳은 것은?","create table 사원(번호 char(10) primary key, 월급 integer);

SQL A : select count(번호) from 사원 where 월급 > = 100000 or 월급 < 100000;
SQL B : select count(번호) from 사원;","2","4","SQL A와 SQL B의 결과는항상 같다."
"237","다음 SQL 문장 중 COLUMN1의 값이 널이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","1","SELECT * FROM T_TEST WHERE COLUMN1 NOT NULL;"
"237","다음 SQL 문장 중 COLUMN1의 값이 널이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","2","SELECT * FROM T_TEST WHERE COLUMN1 != NULL;"
"237","다음 SQL 문장 중 COLUMN1의 값이 널이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","3","SELECT * FROM T_TEST WHERE COLUMN1 <> NULL;"
"237","다음 SQL 문장 중 COLUMN1의 값이 널이 아닌 경우를 찾아내는 문장으로 가장 적절한 것은?","","4","4","SELECT * FROM T_TEST WHERE COLUMN1 IS NOT NULL;"
"257","다음의 SQL문에 대한 설명으로 올바른 것은?","SELECT 'A', 1 FROM DUAL
UNION ALL
SELECT 1, 'A' FROM DUAL;","2","1","실행 결과로 아무것도 출력되지 않는다."
"257","다음의 SQL문에 대한 설명으로 올바른 것은?","SELECT 'A', 1 FROM DUAL
UNION ALL
SELECT 1, 'A' FROM DUAL;","2","2","위의 SQL문은 실행되지 않는다."
"257","다음의 SQL문에 대한 설명으로 올바른 것은?","SELECT 'A', 1 FROM DUAL
UNION ALL
SELECT 1, 'A' FROM DUAL;","2","3","UNION ALL을 사용해서 합집합을 만들고 중복을 제거한다."
"257","다음의 SQL문에 대한 설명으로 올바른 것은?","SELECT 'A', 1 FROM DUAL
UNION ALL
SELECT 1, 'A' FROM DUAL;","2","4","위의 SQL문 실행 결과는 A, 1, 1 ,A가 조회된다."
"263","다음의 SQL문에 대한 설명 중 옳지 않은 것은?","SELECT * FROM EMP
WHERE EMPNO LIKE '100%';","2","1","기능상으로는 문제가 없지만 성능 문제가 있다."
"263","다음의 SQL문에 대한 설명 중 옳지 않은 것은?","SELECT * FROM EMP
WHERE EMPNO LIKE '100%';","2","2","EMP 테이블을 FULL SCAN한 것은 인덱스가 없어서이다."
"263","다음의 SQL문에 대한 설명 중 옳지 않은 것은?","SELECT * FROM EMP
WHERE EMPNO LIKE '100%';","2","3","LIKE 조건을 사용하지 말고 "">""를 사용해야 한다."
"263","다음의 SQL문에 대한 설명 중 옳지 않은 것은?","SELECT * FROM EMP
WHERE EMPNO LIKE '100%';","2","4","내부적으로 형변환이 발생했다."
"804","다음 중 관계형 데이터베이스의 특징이 아닌 것은?","","3","1","테이블 기반 구조"
"804","다음 중 관계형 데이터베이스의 특징이 아닌 것은?","","3","2","관계를 통해 데이터 연결"
"804","다음 중 관계형 데이터베이스의 특징이 아닌 것은?","","3","3","절차적 데이터 저장"
"804","다음 중 관계형 데이터베이스의 특징이 아닌 것은?","","3","4","SQL 사용"
"807","ERD에서 관계(Relationship)는 어떤 기호로 표현되는가?","","3","1","원"
"807","ERD에서 관계(Relationship)는 어떤 기호로 표현되는가?","","3","2","사각형"
"807","ERD에서 관계(Relationship)는 어떤 기호로 표현되는가?","","3","3","다이아몬드"
"807","ERD에서 관계(Relationship)는 어떤 기호로 표현되는가?","","3","4","삼각형"
"811","ERD에서 식별자는 무엇을 의미하는가?","","2","1","속성 이름"
"811","ERD에서 식별자는 무엇을 의미하는가?","","2","2","유일하게 개체를 구분하는 키"
"811","ERD에서 식별자는 무엇을 의미하는가?","","2","3","테이블 간의 관계"
"811","ERD에서 식별자는 무엇을 의미하는가?","","2","4","속성 값의 범위"
"9","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","s병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리해야 한다. (단, 업무범위와 데이터의 특성은 상기 시나리오에 기술되어 있는 사항만을 근거하여 판단해야 함)","3","1","주소"
"9","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","s병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리해야 한다. (단, 업무범위와 데이터의 특성은 상기 시나리오에 기술되어 있는 사항만을 근거하여 판단해야 함)","3","2","이름"
"9","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","s병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리해야 한다. (단, 업무범위와 데이터의 특성은 상기 시나리오에 기술되어 있는 사항만을 근거하여 판단해야 함)","3","3","환자"
"9","다음 중 아래 시나리오에서 엔터티로 가장 적절한 것은?","s병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리해야 한다. (단, 업무범위와 데이터의 특성은 상기 시나리오에 기술되어 있는 사항만을 근거하여 판단해야 함)","3","4","병원"
"10","다음 중 엔터티의 특징으로 가장 부적절한 것은?","","2","1","데이터로서 존재하지만 업무에서 필요로 하지 않으면 해당 업무의 엔터티로 성립될 수 없다."
"10","다음 중 엔터티의 특징으로 가장 부적절한 것은?","","2","2","객체지향의 디자인패턴에는 싱글턴패턴이 있어 하나의 인스턴스를 가지는 클래스가 존재한다. 이와 유사하게 엔터티는 한 개의 인스턴스를 가지는 것만으로도 충분한 의미를 부여할 수 있다."
"10","다음 중 엔터티의 특징으로 가장 부적절한 것은?","","2","3","엔터티는 다른 엔터티와 관계가 있을 수 밖에 없다. 단, 통계성 엔터티나, 코드성 엔터티의 경우 관계를 생략할 수 있다."
"10","다음 중 엔터티의 특징으로 가장 부적절한 것은?","","2","4","속성이 없는 엔터티는 있을 수 없다. 엔터티는 반드시 속성을 가져야 한다."
"27","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 가준을 묶은 것으로 가장 적절한 것은?","가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다.
다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다.
라. 자주 수정되는 속성을 주식별자로 지정한다.","3","1","나, 라"
"27","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 가준을 묶은 것으로 가장 적절한 것은?","가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다.
다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다.
라. 자주 수정되는 속성을 주식별자로 지정한다.","3","2","다, 라"
"27","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 가준을 묶은 것으로 가장 적절한 것은?","가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다.
다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다.
라. 자주 수정되는 속성을 주식별자로 지정한다.","3","3","가, 다"
"27","다음 중 아래에서 엔터티 내에 주식별자를 도출하는 가준을 묶은 것으로 가장 적절한 것은?","가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
나. 명칭, 내역 등과 같이 이름으로 기술되는 것들을 주식별자로 지정한다.
다. 복합으로 주식별자를 구성할 경우 너무 많은 속성을 포함하지 않도록 한다.
라. 자주 수정되는 속성을 주식별자로 지정한다.","3","4","가, 나"
"28","프로젝트를 전개할 때는 식별자관계와 비식별자관계를 선택하여 연결해야 하는 높은 수준의 데이터모델링 기술이 필요하다. 다음 중 비식별자관계를 선택하는 가준으로 가장 부적절한 것은?","","1","1","부모엔터티의 주식별자를 자식엔터티에서 받아 손자엔터티까지 계속 흘려보내기 위해 비식별자관계를 고려한다."
"28","프로젝트를 전개할 때는 식별자관계와 비식별자관계를 선택하여 연결해야 하는 높은 수준의 데이터모델링 기술이 필요하다. 다음 중 비식별자관계를 선택하는 가준으로 가장 부적절한 것은?","","1","2","모든 관계가 식별자 관계로 연결되면 SQL Where절에서 비교하는 항목이 증가되어 조인에 참여하는 테이블에 따라 SQL문장이 길어져 SQL문의 복잡성이 증가되는 것을 방지하기 위해 비식별자관계를 고려한다."
"28","프로젝트를 전개할 때는 식별자관계와 비식별자관계를 선택하여 연결해야 하는 높은 수준의 데이터모델링 기술이 필요하다. 다음 중 비식별자관계를 선택하는 가준으로 가장 부적절한 것은?","","1","3","자식테이블에서 독립적인 Primary Key의 구조를 가지기 원할 때 비식별자관계를 고려한다."
"28","프로젝트를 전개할 때는 식별자관계와 비식별자관계를 선택하여 연결해야 하는 높은 수준의 데이터모델링 기술이 필요하다. 다음 중 비식별자관계를 선택하는 가준으로 가장 부적절한 것은?","","1","4","관계의 강약을 분석하여 상호간에 연관성이 약할 경우 비식별자관계를 고려한다."
"41","다음 중 데이터베아스 시스템 언어의 종류와 해당되는 명령어를 바르게 연결한 것을 2개 고르시오.","","3,4","1","DML - ALTER"
"41","다음 중 데이터베아스 시스템 언어의 종류와 해당되는 명령어를 바르게 연결한 것을 2개 고르시오.","","3,4","2","DCL - DROP"
"41","다음 중 데이터베아스 시스템 언어의 종류와 해당되는 명령어를 바르게 연결한 것을 2개 고르시오.","","3,4","3","TCL - COMMIT"
"41","다음 중 데이터베아스 시스템 언어의 종류와 해당되는 명령어를 바르게 연결한 것을 2개 고르시오.","","3,4","4","DML - SELECT"
"110","다음 중 계층형 질의문에 대한 설명으로 가장 부적절한 것은?","","1","1","오라클의 계층형 질의문에서 PRIOR 키워드는 CONNECT BY 절에만 사용할 수 있으며 'prior 자식 = 부모' 형태로 사용하면 순방향 전개로 수행 된다."
"110","다음 중 계층형 질의문에 대한 설명으로 가장 부적절한 것은?","","1","2","오라클의 계층형 질의문에서 WHERE 절은 모든 전개를 진행한 이후 필터 조건으로서 조건을 만족하는 데이터만을 추출하는데 활용된다."
"110","다음 중 계층형 질의문에 대한 설명으로 가장 부적절한 것은?","","1","3","SQL Server에서의 계층형 질의문은 앵커 멤버를 실행하여 기본 결과 집합을 만들고 이후 재귀 멤버를 지속적으로 실행한다."
"110","다음 중 계층형 질의문에 대한 설명으로 가장 부적절한 것은?","","1","4","SQL Server에서의 게층형 질의문은 CTE(Common Table Expression)를 재귀 호출함으로써 계층 구조를 전개한다."
"119","다음 중 아래 SQL에 대한 설명으로 가장 부적절한 것은?","[SQL]
SELECT B.사원번호, B.사원명, A.부서번호, A.부서명
, (SELECT COUNT(*)  FROM 부양가족 Y WHERE
Y.사원번호 = B.사원번호)  AS 부양가족수
FROM 부서 A, (SELECT *
FROM 사원
WHERE 입사년도 = '2014')  B
WHERE A.부서번호 = B.부서번호
AND EXISTS (SELECT 1 FROM 사원 X WHERE X.부서번호 =
A.부서번호);
","2","1","FROM 절의 서브쿼리는 동적 뷰(Dynamic View)라고도 하며, SQL문장 중 테이블 명이 올 수 있는 곳에서 사용할 수 있다."
"119","다음 중 아래 SQL에 대한 설명으로 가장 부적절한 것은?","[SQL]
SELECT B.사원번호, B.사원명, A.부서번호, A.부서명
, (SELECT COUNT(*)  FROM 부양가족 Y WHERE
Y.사원번호 = B.사원번호)  AS 부양가족수
FROM 부서 A, (SELECT *
FROM 사원
WHERE 입사년도 = '2014')  B
WHERE A.부서번호 = B.부서번호
AND EXISTS (SELECT 1 FROM 사원 X WHERE X.부서번호 =
A.부서번호);
","2","2","WHERE 절의 서브쿼리에 사원 테이블 검색 조건으로 입사년도 조건을 FROM절의 서브쿼리와 동일하게 추가해야 원하는 결과를 추출할 수 있다."
"119","다음 중 아래 SQL에 대한 설명으로 가장 부적절한 것은?","[SQL]
SELECT B.사원번호, B.사원명, A.부서번호, A.부서명
, (SELECT COUNT(*)  FROM 부양가족 Y WHERE
Y.사원번호 = B.사원번호)  AS 부양가족수
FROM 부서 A, (SELECT *
FROM 사원
WHERE 입사년도 = '2014')  B
WHERE A.부서번호 = B.부서번호
AND EXISTS (SELECT 1 FROM 사원 X WHERE X.부서번호 =
A.부서번호);
","2","3","SELECT절에 사용된 서브쿼리는 스칼라 서브쿼리라고도하며, 이러한 형태의 서브쿼리는 JOIN 으로 동일한 결과를 추출할 수도 있다.
"
"119","다음 중 아래 SQL에 대한 설명으로 가장 부적절한 것은?","[SQL]
SELECT B.사원번호, B.사원명, A.부서번호, A.부서명
, (SELECT COUNT(*)  FROM 부양가족 Y WHERE
Y.사원번호 = B.사원번호)  AS 부양가족수
FROM 부서 A, (SELECT *
FROM 사원
WHERE 입사년도 = '2014')  B
WHERE A.부서번호 = B.부서번호
AND EXISTS (SELECT 1 FROM 사원 X WHERE X.부서번호 =
A.부서번호);
","2","4","위 SQL에는 다중 행 연관 서브쿼리, 단일 행 연관 서브쿼리, Inline View 가 사용되었다"
"139","다음 중 PL/SQL에 대한 설명으로 가장 부적절한 것은?","","2","1","Procedure 내부에 작성된 절차적 코드는 PL/SQL엔진이 처 리하고 일반적인 SQL 문장은 SQL실행기가 처리한다."
"139","다음 중 PL/SQL에 대한 설명으로 가장 부적절한 것은?","","2","2","PL/SQL로 작성된 Procedure, User Defined Fimction은 전체가 하나의 트랜젝션으로 처리되어야 한다"
"139","다음 중 PL/SQL에 대한 설명으로 가장 부적절한 것은?","","2","3","Procedure, User Defined Function, Trigger 객체를 PL/SQL로 작성할 수 있다."
"139","다음 중 PL/SQL에 대한 설명으로 가장 부적절한 것은?","","2","4","변수와 상수 등을 사용하여 일반 SQL 문장을 실행할 때 WHERE절의 조건 등으로 대입할 수 있다."
"140","아래는 임시부서(TMP_DEPT)  테이블로부터 부서(DEPT) 테이블에 데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기 전에 부서 테이블의 모든 데이터를 ROLLBACKOI 불가능 하도록 삭제 하려고 한다. 다음 중 (ㄱ)에 들어갈 내용으로 옳은 것은?","[PL/SQL]
 create or replace procedure insert_dept authid_current_user 
as
 begin
(ㄱ)
 INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME, LOC)
 SELECT DEPTNO, DNAME, LOC
 FROM TMP_DEPT；
commit；
end；","2","1","execute 'TRUNCATE TABLE DEPT’;"
"140","아래는 임시부서(TMP_DEPT)  테이블로부터 부서(DEPT) 테이블에 데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기 전에 부서 테이블의 모든 데이터를 ROLLBACKOI 불가능 하도록 삭제 하려고 한다. 다음 중 (ㄱ)에 들어갈 내용으로 옳은 것은?","[PL/SQL]
 create or replace procedure insert_dept authid_current_user 
as
 begin
(ㄱ)
 INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME, LOC)
 SELECT DEPTNO, DNAME, LOC
 FROM TMP_DEPT；
commit；
end；","2","2","execute immediate 'TRUNCATE TABLE DEPT';"
"140","아래는 임시부서(TMP_DEPT)  테이블로부터 부서(DEPT) 테이블에 데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기 전에 부서 테이블의 모든 데이터를 ROLLBACKOI 불가능 하도록 삭제 하려고 한다. 다음 중 (ㄱ)에 들어갈 내용으로 옳은 것은?","[PL/SQL]
 create or replace procedure insert_dept authid_current_user 
as
 begin
(ㄱ)
 INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME, LOC)
 SELECT DEPTNO, DNAME, LOC
 FROM TMP_DEPT；
commit；
end；","2","3","DELETE FROM DEPT;"
"140","아래는 임시부서(TMP_DEPT)  테이블로부터 부서(DEPT) 테이블에 데이터를 입력하는 PL/SQL 이다. 부서 테이블에 데이터를 입력하기 전에 부서 테이블의 모든 데이터를 ROLLBACKOI 불가능 하도록 삭제 하려고 한다. 다음 중 (ㄱ)에 들어갈 내용으로 옳은 것은?","[PL/SQL]
 create or replace procedure insert_dept authid_current_user 
as
 begin
(ㄱ)
 INSERT /*+ APPEND */ INTO DEPT (DEPTNO, DNAME, LOC)
 SELECT DEPTNO, DNAME, LOC
 FROM TMP_DEPT；
commit；
end；","2","4","TRUNCATE TABLE DEPT;"
"145","자신의 속성이 없어도 다른 속성을 이용하여 결과를 도출할 수 있는 특징을 가진 속성의 이름은?","","2","1","관계 속성"
"145","자신의 속성이 없어도 다른 속성을 이용하여 결과를 도출할 수 있는 특징을 가진 속성의 이름은?","","2","2","파생 속성"
"145","자신의 속성이 없어도 다른 속성을 이용하여 결과를 도출할 수 있는 특징을 가진 속성의 이름은?","","2","3","기본 속성"
"145","자신의 속성이 없어도 다른 속성을 이용하여 결과를 도출할 수 있는 특징을 가진 속성의 이름은?","","2","4","설계 속성"
"151","다음 개념에 해당하는 관계는 무엇인가?","부모 엔터티로부터 속성을 받았지만, 자식 엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용한다.","3","1","외부 식별 관계"
"151","다음 개념에 해당하는 관계는 무엇인가?","부모 엔터티로부터 속성을 받았지만, 자식 엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용한다.","3","2","일반 속성 관계"
"151","다음 개념에 해당하는 관계는 무엇인가?","부모 엔터티로부터 속성을 받았지만, 자식 엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용한다.","3","3","비식별자 관계"
"151","다음 개념에 해당하는 관계는 무엇인가?","부모 엔터티로부터 속성을 받았지만, 자식 엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용한다.","3","4","식별자 관계"
"154","엔터티 - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오.","","3","1","엔터티 하나의 인스턴스는 다른 엔터티의 인스턴스 간 관계인 Pariring을 가진다."
"154","엔터티 - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오.","","3","2","한 개의 엔터티는 두 개 이상의 속성을 갖는다."
"154","엔터티 - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오.","","3","3","하나의 속성은 하나 이상의 속성값을 가진다."
"154","엔터티 - 인스턴스 - 속성 - 속성값에 대한 관계 설명 중 틀린 것을 고르시오.","","3","4","한 개의 엔터티는 두 개 이상의 인스턴스 집합이어야 한다."
"156","다음 설명에 해당하는 모델링 관점은 무엇인가?","업무가 어떤 데이터와 관련이 있는지 또는 데이터 간의 관계는 무엇인지에 대해서 모델링 하는 관점","1","1","데이터 관점"
"156","다음 설명에 해당하는 모델링 관점은 무엇인가?","업무가 어떤 데이터와 관련이 있는지 또는 데이터 간의 관계는 무엇인지에 대해서 모델링 하는 관점","1","2","데이터와 데이터 간의 상관 관점"
"156","다음 설명에 해당하는 모델링 관점은 무엇인가?","업무가 어떤 데이터와 관련이 있는지 또는 데이터 간의 관계는 무엇인지에 대해서 모델링 하는 관점","1","3","데이터와 프로세스의 상관 관점"
"156","다음 설명에 해당하는 모델링 관점은 무엇인가?","업무가 어떤 데이터와 관련이 있는지 또는 데이터 간의 관계는 무엇인지에 대해서 모델링 하는 관점","1","4","프로세스 관점"
"162","다음 중 설계 단계에서 데이터 모델의 성능을 고려하는 절차와 방법에 포함되지 않는 것은?","","1","1","데이터 모델링을 할 때 분석 단계에서부터 반정규화를 수행한다."
"162","다음 중 설계 단계에서 데이터 모델의 성능을 고려하는 절차와 방법에 포함되지 않는 것은?","","1","2","데이터베이스에 발생되는 트랜잭션의 유형을 파악한다."
"162","다음 중 설계 단계에서 데이터 모델의 성능을 고려하는 절차와 방법에 포함되지 않는 것은?","","1","3","데이터베이스 용량 산정을 수행한다."
"162","다음 중 설계 단계에서 데이터 모델의 성능을 고려하는 절차와 방법에 포함되지 않는 것은?","","1","4","이력모델의 조정, 기본키/외래키 조정, 슈퍼타입/서브타입 조정 등을 수행한다."
"164","다음 중 분산 데이터베이스의 투명성에 속하지 않는 것은?","","1","1","병렬 투명성"
"164","다음 중 분산 데이터베이스의 투명성에 속하지 않는 것은?","","1","2","중복 투명성"
"164","다음 중 분산 데이터베이스의 투명성에 속하지 않는 것은?","","1","3","병행 투명성"
"164","다음 중 분산 데이터베이스의 투명성에 속하지 않는 것은?","","1","4","분할 투명성"
"168","발생 시점에 따른 엔터티 분류에 의한 중심 엔터티가 아닌 것은?","","2","1","계약"
"168","발생 시점에 따른 엔터티 분류에 의한 중심 엔터티가 아닌 것은?","","2","2","사원"
"168","발생 시점에 따른 엔터티 분류에 의한 중심 엔터티가 아닌 것은?","","2","3","주문"
"168","발생 시점에 따른 엔터티 분류에 의한 중심 엔터티가 아닌 것은?","","2","4","매출"
"172","다음 설명 중 옳은 것은 무엇인가?","","4","1","데이터베이스에는 단 한 개의 테이블만 존재할 수 있다."
"172","다음 설명 중 옳은 것은 무엇인가?","","4","2","아주 복잡한 자료도 테이블은 하나만 만드는 것이 바람직하다."
"172","다음 설명 중 옳은 것은 무엇인가?","","4","3","데이터베이스 내에 테이블이란 존재하지 않는다."
"172","다음 설명 중 옳은 것은 무엇인가?","","4","4","모든 자료는 실질적으로 테이블에 저장되며 테이블에 있는 자료들을 꺼내 볼 수 있다."
"211","다음 중 자신과 성별이 같은 부양가족을 가진 직원의 이름을 검색하는 질의를 SQL로 적절하게 표현한 것을 고르시오.","","2","1","SELECT E.이름
FROM 직원 AS E
WHERE NOT EXISTS (SELECT * FROM 부양가족 WHERE E.직원번호 = 직원번호 AND E.성별 = 성별);"
"211","다음 중 자신과 성별이 같은 부양가족을 가진 직원의 이름을 검색하는 질의를 SQL로 적절하게 표현한 것을 고르시오.","","2","2","SELECT E.이름
FROM 직원 AS E
WHERE EXISTS (SELECT * FROM 부양가족 WHERE E.직원번호 = 직원번호 AND E.성별 = 성별);"
"211","다음 중 자신과 성별이 같은 부양가족을 가진 직원의 이름을 검색하는 질의를 SQL로 적절하게 표현한 것을 고르시오.","","2","3","SELECT E.이름
FROM 직원 AS E
WHERE NOT EXISTS (SELECT * FROM 부양가족 WHERE E.직원번호 = 직원번호);"
"211","다음 중 자신과 성별이 같은 부양가족을 가진 직원의 이름을 검색하는 질의를 SQL로 적절하게 표현한 것을 고르시오.","","2","4","SELECT E.이름
FROM 직원 AS E
WHERE E.직원번호 LIKE (SELECT 직원번호 FROM 부양가족 WHERE E.성별 = 성별);"
"216","다음의 데이터베이스에서 '부양가족을 2명 이상 가진 사원의 사번(eno), 성명(ename), 부양가족 수를 검색'하는 질의를 SQL로 적절하게 표현한 것은?","employee(eno, ename, address, score, dno)
dependent(eno, ename, birthday, relation)","2","1","SELECT e.eno, e.ename, count(*)
FROM employee e, dependent d
WHERE e.eno = d.eno
GROUP BY e.eno, e.name
HAVING count(*) >= 3;"
"216","다음의 데이터베이스에서 '부양가족을 2명 이상 가진 사원의 사번(eno), 성명(ename), 부양가족 수를 검색'하는 질의를 SQL로 적절하게 표현한 것은?","employee(eno, ename, address, score, dno)
dependent(eno, ename, birthday, relation)","2","2","SELECT e.eno, e.ename, t.cnt
FROM employee e,
(SELECT eno, count(*) as cnt
FROM dependent GROUP BY
eno HAVING count(*) >= 2) t
WHERE e.eno = t.eno;"
"216","다음의 데이터베이스에서 '부양가족을 2명 이상 가진 사원의 사번(eno), 성명(ename), 부양가족 수를 검색'하는 질의를 SQL로 적절하게 표현한 것은?","employee(eno, ename, address, score, dno)
dependent(eno, ename, birthday, relation)","2","3","SELECT e.eno, e.ename, count(*)
FROM employee e, dependent d
WHERE EXISTS (SELECT * FROM dependent 
GROUP BY eno
HAVING count(*) >=2)
GROUP BY e.eno, e.ename;"
"216","다음의 데이터베이스에서 '부양가족을 2명 이상 가진 사원의 사번(eno), 성명(ename), 부양가족 수를 검색'하는 질의를 SQL로 적절하게 표현한 것은?","employee(eno, ename, address, score, dno)
dependent(eno, ename, birthday, relation)","2","4","SELECT eno, ename, count(*)
FROM employee e, dependent d
WHERE e.eno = d.eno and count(*) >= 2
GROUP BY d.eno;"
"220","그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.","","2","1","LAG"
"220","그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.","","2","2","RANK"
"220","그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.","","2","3","LAST_VALUE"
"220","그룹 내 행 순서 관련 함수에 속하지 않는 함수를 모두 고르시오.","","2","4","FIRST_VALUE"
"222","CONNECT BY에 대한 설명으로 맞지 않은 것은?","","4","1","SYS_CONNECT_BY_PATH는 하위 레벨의 칼럼까지 모두 표시한다."
"222","CONNECT BY에 대한 설명으로 맞지 않은 것은?","","4","2","CONNECT_BY_ROOT는 ROOT 노드의 정보를 표시한다."
"222","CONNECT BY에 대한 설명으로 맞지 않은 것은?","","4","3","CONNECT_BY_ISCYCLE는 ROOT까지의 경로에 존재하는 데이터를 의미한다."
"222","CONNECT BY에 대한 설명으로 맞지 않은 것은?","","4","4","CONNECT_BY_ISLEAF는 전개과정에서 LEAF 데이터이면 0, 아니면 1을 가진다."
"224","다음은 Order by에 대한 설명이다. 올바르지 않은 것은?","","1","1","날짜형 데이터 타입을 오름차순으로 정렬하면 날짜 값이 가장 늦은 날짜가 먼저 출력된다."
"224","다음은 Order by에 대한 설명이다. 올바르지 않은 것은?","","1","2","SQL Server에서 오름차순으로 정렬하면 NULL 값이 가장 먼저 나온다."
"224","다음은 Order by에 대한 설명이다. 올바르지 않은 것은?","","1","3","오름차순으로 숫자형 데이터 타입을 정렬하면 가장 작은 값부터 출력된다."
"224","다음은 Order by에 대한 설명이다. 올바르지 않은 것은?","","1","4","기본적으로 정렬순서는 오름차순으로 정렬되지만 DESC를 사용하면 내림차순으로 정렬한다."
"226","다음의 SQL문과 동일한 것을 고르시오.","Select NVL(Name,'없음') From Emp;","2","1","Select Case When Name IS NULL THEN '없음' ELSE '0' END AS USER_NAME
FROM Emp;"
"226","다음의 SQL문과 동일한 것을 고르시오.","Select NVL(Name,'없음') From Emp;","2","2","Select Case When Name IS NULL THEN '없음' ELSE NAME END AS USER_NAME
FROM Emp;"
"226","다음의 SQL문과 동일한 것을 고르시오.","Select NVL(Name,'없음') From Emp;","2","3","Select Case When Name IS NOT NULL THEN '0' ELSE NAME END AS USER_NAME
FROM Emp;"
"226","다음의 SQL문과 동일한 것을 고르시오.","Select NVL(Name,'없음') From Emp;","2","4","Select Case When Name IS NOT NULL THEN NAME ELSE '0' END AS USER_NAME
FROM Emp;"
"228","서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?","","3","1","Access Subquery"
"228","서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?","","3","2","Associative Subquery"
"228","서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?","","3","3","Scala Subquery"
"228","서브쿼리의 종류 중에 서브쿼리를 실행하고 한 행, 한 칼럼을 반환하는 서브쿼리를 무엇이라고 하는가?","","3","4","Looping"
"276","다음 주어진 CUBE문과 동일한 것은?","GROUP BY CUBE(DEPTNO, JOB);","3","1","GROUP BY (DEPTNO, JOB, (DEPTNO, JOB), 0);"
"276","다음 주어진 CUBE문과 동일한 것은?","GROUP BY CUBE(DEPTNO, JOB);","3","2","GROUP BY DEPTNO UNION
GROUP BY JOB UNION GROUP
BY (DEPTNO, JOB)"
"276","다음 주어진 CUBE문과 동일한 것은?","GROUP BY CUBE(DEPTNO, JOB);","3","3","GROUP BY GROUPING
SETS(DEPTNO, JOB, (DEPTNO, JOB), ());"
"276","다음 주어진 CUBE문과 동일한 것은?","GROUP BY CUBE(DEPTNO, JOB);","3","4","GROUP BY ROLLUP(DEPTNO, JOB);"
